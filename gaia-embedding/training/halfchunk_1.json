[
  {
    "title": "Potential Reentrancy Into Strategies",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe `StrategyManager` contract is the entry point for deposits into and withdrawals from strategies. More specifically, to deposit into a strategy, a staker calls `depositIntoStrategy` (or anyone calls `depositIntoStrategyWithSignature` with the staker's signature), and then the asset is transferred from the staker to the strategy contract. After that, the strategy's `deposit` function is called, followed by some bookkeeping in the `StrategyManager`. For withdrawals (and slashing), the `StrategyManager` calls the strategy's `withdraw` function, which transfers the given amount of the asset to the given recipient. Both token transfers are a potential source of reentrancy if the token allows it.\r\n\r\nThe `StrategyManager` uses OpenZeppelin's `ReentrancyGuardUpgradeable` as reentrancy protection, and the relevant functions have a `nonReentrant` modifier. The `StrategyBase` contract – from which concrete strategies should be derived – does not have reentrancy protection. However, the functions `deposit` and `withdraw` can only be called from the `StrategyManager`, so reentering these is impossible.\r\n\r\nNevertheless, other functions could be reentered, for example, `sharesToUnderlyingView` and `underlyingToSharesView`, as well as their (supposedly) non-`view` counterparts. \r\n\r\nLet's look at the `withdraw` function in `StrategyBase`. First, the `amountShares` shares are burnt, and at the end of the function, the equivalent amount of `token` is transferred to the `depositor`:\r\n\r\n\n**src/contracts/strategies/StrategyBase.sol:L108-L143**\n```solidity\nfunction withdraw(address depositor, IERC20 token, uint256 amountShares)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED_WITHDRAWALS)\n    onlyStrategyManager\n{\n    require(token == underlyingToken, \"StrategyBase.withdraw: Can only withdraw the strategy token\");\n    // copy `totalShares` value to memory, prior to any decrease\n    uint256 priorTotalShares = totalShares;\n    require(\n        amountShares <= priorTotalShares,\n        \"StrategyBase.withdraw: amountShares must be less than or equal to totalShares\"\n    );\n\n    // Calculate the value that `totalShares` will decrease to as a result of the withdrawal\n    uint256 updatedTotalShares = priorTotalShares - amountShares;\n    // check to avoid edge case where share rate can be massively inflated as a 'griefing' sort of attack\n    require(updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES || updatedTotalShares == 0,\n        \"StrategyBase.withdraw: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES\");\n    // Actually decrease the `totalShares` value\n    totalShares = updatedTotalShares;\n\n    /**\n     * @notice calculation of amountToSend *mirrors* `sharesToUnderlying(amountShares)`, but is different since the `totalShares` has already\n     * been decremented. Specifically, notice how we use `priorTotalShares` here instead of `totalShares`.\n     */\n    uint256 amountToSend;\n    if (priorTotalShares == amountShares) {\n        amountToSend = _tokenBalance();\n    } else {\n        amountToSend = (_tokenBalance() * amountShares) / priorTotalShares;\n    }\n\n    underlyingToken.safeTransfer(depositor, amountToSend);\n}\n```\n\r\nIf we assume that the `token` contract has a callback to the recipient of the transfer _before_ the actual balance changes take place, then the recipient could reenter the strategy contract, for example, in `sharesToUnderlyingView`:\r\n\r\n\n**src/contracts/strategies/StrategyBase.sol:L159-L165**\n```solidity\nfunction sharesToUnderlyingView(uint256 amountShares) public view virtual override returns (uint256) {\n    if (totalShares == 0) {\n        return amountShares;\n    } else {\n        return (_tokenBalance() * amountShares) / totalShares;\n    }\n}\n```\n\r\nThe crucial point is: If the callback is executed _before_ the actual balance change, then `sharesToUnderlyingView` will report a bad result because the shares have already been burnt but the token balance has not been updated yet.\r\n\r\nFor deposits, the token transfer to the strategy happens first, and the shares are minted after that:\r\n\r\n\n**src/contracts/core/StrategyManager.sol:L643-L652**\n```solidity\nfunction _depositIntoStrategy(address depositor, IStrategy strategy, IERC20 token, uint256 amount)\n    internal\n    onlyStrategiesWhitelistedForDeposit(strategy)\n    returns (uint256 shares)\n{\n    // transfer tokens from the sender to the strategy\n    token.safeTransferFrom(msg.sender, address(strategy), amount);\n\n    // deposit the assets into the specified strategy and get the equivalent amount of shares in that strategy\n    shares = strategy.deposit(token, amount);\n```\n\r\n\n**src/contracts/strategies/StrategyBase.sol:L69-L99**\n```solidity\nfunction deposit(IERC20 token, uint256 amount)\n    external\n    virtual\n    override\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    onlyStrategyManager\n    returns (uint256 newShares)\n{\n    require(token == underlyingToken, \"StrategyBase.deposit: Can only deposit underlyingToken\");\n\n    /**\n     * @notice calculation of newShares *mirrors* `underlyingToShares(amount)`, but is different since the balance of `underlyingToken`\n     * has already been increased due to the `strategyManager` transferring tokens to this strategy prior to calling this function\n     */\n    uint256 priorTokenBalance = _tokenBalance() - amount;\n    if (priorTokenBalance == 0 || totalShares == 0) {\n        newShares = amount;\n    } else {\n        newShares = (amount * totalShares) / priorTokenBalance;\n    }\n\n    // checks to ensure correctness / avoid edge case where share rate can be massively inflated as a 'griefing' sort of attack\n    require(newShares != 0, \"StrategyBase.deposit: newShares cannot be zero\");\n    uint256 updatedTotalShares = totalShares + newShares;\n    require(updatedTotalShares >= MIN_NONZERO_TOTAL_SHARES,\n        \"StrategyBase.deposit: updated totalShares amount would be nonzero but below MIN_NONZERO_TOTAL_SHARES\");\n\n    // update total share amount\n    totalShares = updatedTotalShares;\n    return newShares;\n}\n```\n\r\nThat means if there is a callback in the token's `transferFrom` function and it is executed _after_ the balance change, a reentering call to `sharesToUnderlyingView` (for example) will again return a wrong result because shares and token balances are not \"in sync.\"\r\n\r\nIn addition to the reversed order of token transfer and shares update, there's another vital difference between `withdraw` and `deposit`: For withdrawals, the call to the token contract originates in the strategy, while for deposits, it is the strategy _manager_ that initiates the call to the token contract (before calling into the strategy). That's a technicality that has consequences for reentrancy protection: Note that for withdrawals, it is the strategy contract that is reentered, while for deposits, there is not a single contract that is reentered; instead, it is the contract _system_ that is in an inconsistent state when the reentrancy happens. Hence, reentrancy protection on the level of individual contracts is not sufficient.\r\n\r\nFinally, we want to discuss through _which_ functions in the strategy contract the system could be reentered. As mentioned, `deposit` and `withdraw` can only be called by the strategy manager, so these two can be ruled out. For the examples above, we considered `sharesToUnderlyingView`, which (as the name suggests) is a `view` function. As such, it can't change the state of the contract, so reentrancy through a `view` function can only be a problem for _other_ contracts that use this function and rely on its return value. However, there is also a potentially state-changing variant, `sharesToUnderlying`, and similar potentially state-changing functions, such as `underlyingToShares` and `userUnderlying`. Currently, these functions are not _actually_ state-changing, but the idea is that they could be and, in some concrete strategy implementations that inherit from `StrategyBase`, will be. In such cases, these functions could make wrong state changes due to state inconsistency during reentrancy.\r\n\r\nThe examples above assume that the token contract allows reentrancy through its `transfer` function _before_ the balance change has been made or in its `transferFrom` function _after_. It might be tempting to argue that tokens which don't fall into this category are safe to use. While the examples discussed above are the most interesting attack vectors we found, there might still be others: To illustrate this point, assume a token contract that allows reentrancy through `transferFrom` only before any state change in the token takes place. The token transfer is the first thing that happens in `StrategyManager._depositIntoStrategy`, and the state changes (user shares) and calling the strategy's `deposit` function occur later, so this might look safe. However, if the deposit happens via `StrategyManager.depositIntoStrategyWithSignature`, then it can be seen, for example, that the staker's nonce is updated before the internal `_depositIntoStrategy` function is called:\r\n\r\n\n**src/contracts/core/StrategyManager.sol:L244-L286**\n```solidity\nfunction depositIntoStrategyWithSignature(\n    IStrategy strategy,\n    IERC20 token,\n    uint256 amount,\n    address staker,\n    uint256 expiry,\n    bytes memory signature\n)\n    external\n    onlyWhenNotPaused(PAUSED_DEPOSITS)\n    onlyNotFrozen(staker)\n    nonReentrant\n    returns (uint256 shares)\n{\n    require(\n        expiry >= block.timestamp,\n        \"StrategyManager.depositIntoStrategyWithSignature: signature expired\"\n    );\n    // calculate struct hash, then increment `staker`'s nonce\n    uint256 nonce = nonces[staker];\n    bytes32 structHash = keccak256(abi.encode(DEPOSIT_TYPEHASH, strategy, token, amount, nonce, expiry));\n    unchecked {\n        nonces[staker] = nonce + 1;\n    }\n    bytes32 digestHash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR, structHash));\n\n\n    /**\n     * check validity of signature:\n     * 1) if `staker` is an EOA, then `signature` must be a valid ECSDA signature from `staker`,\n     * indicating their intention for this action\n     * 2) if `staker` is a contract, then `signature` must will be checked according to EIP-1271\n     */\n    if (Address.isContract(staker)) {\n        require(IERC1271(staker).isValidSignature(digestHash, signature) == ERC1271_MAGICVALUE,\n            \"StrategyManager.depositIntoStrategyWithSignature: ERC1271 signature verification failed\");\n    } else {\n        require(ECDSA.recover(digestHash, signature) == staker,\n            \"StrategyManager.depositIntoStrategyWithSignature: signature not from staker\");\n    }\n\n    shares = _depositIntoStrategy(staker, strategy, token, amount);\n}\n```\n\r\nHence, querying the staker's nonce in reentrancy would still give a result based on an \"incomplete state change.\" It is, for example, conceivable that the staker still has zero shares, and yet their nonce is already 1. This particular situation is most likely not an issue, but the example shows that reentrancy can be subtle.\r\n\r\n#### Recommendation\r\n\r\nThis is fine if the token doesn't allow reentrancy in the first place. As discussed above, among the tokens that do allow reentrancy, some variants of when reentrancy can happen in relation to state changes in the token seem more dangerous than others, but we have also argued that this kind of reasoning can be dangerous and error-prone. Hence, we recommend employing comprehensive and defensive reentrancy protection based on reentrancy guards such as OpenZeppelin's `ReentrancyGuardUpgradeable`, which is already used in the `StrategyManager`.\r\n\r\nUnfortunately, securing a multi-contract system against reentrancy can be challenging, but we hope the preceding discussion and the following pointers will prove helpful:\r\n\r\n1. External functions in strategies that should only be callable by the strategy manager (such as `deposit` and `withdraw`) should have the `onlyStrategyManager` modifier. This is already the case in the current codebase and is listed here only for completeness.\r\n2. External functions in strategies for which item 1 doesn't apply (such as `sharesToUnderlying` and `underlyingToShares`) should query the strategy manager's reentrancy lock and revert if it is set.\r\n3. In principle, the restrictions above also apply to `public` functions, but if a `public` function is also used internally, checks against reentrancy can cause problems (if used in an internal context) or at least be redundant. In the context of reentrancy protection, it is often easier to split public functions into an `internal` and an `external` one.\r\n4. If `view` functions are supposed to give reliable results (either internally – which is typically the case – or for other contracts), they have to be protected too.\r\n5. The previous item also applies to the `StrategyManager`: `view` functions that have to provide correct results should query the reentrancy lock and revert if it is set.\r\n6. Solidity automatically generates getters for `public` state variables. Again, if these (`external view`) functions must deliver correct results, the same measures must be taken as for explicit `view` functions. In practice, the state variable has to become `internal` or `private`, and the getter function must be hand-written.\r\n7. The `StrategyBase` contract provides some basic functionality. Concrete strategy implementations can inherit from this contract, meaning that some functions may be overridden (and might or might not call the overridden version via `super`), and new functions might be added. While the guidelines above should be helpful, derived contracts must be reviewed and assessed separately on a case-by-case basis. As mentioned before, reentrancy protection can be challenging, especially in a multi-contract system.",
    "dataSource": {
      "name": "/diligence/audits/2023/03/eigenlabs-eigenlayer/",
      "repo": "https://consensys.net//diligence/audits/2023/03/eigenlabs-eigenlayer/",
      "url": "https://consensys.net//diligence/audits/2023/03/eigenlabs-eigenlayer/"
    }
  },
  {
    "title": "Owner Can Add Arbitrary Code to Be Executed From the SocketGateway Contract",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe Socket system is managed by the `SocketGateway` contract that maintains all routes and controller addresses within its state. There, the address with the `Owner` role of the `SocketGateway` contract can add new routes and controllers that would have a `delegatecall()` executed upon them from the `SocketGateway` so user transactions can go through the logic required for the bridge, swap, or any other solution integrated with Socket. These routes and controllers would then have arbitrary code that is entirely up to the `Owner`, though users are not required to go through any specific routes and can decide which routes to pick.\r\n\r\nSince these routes are called via `delegatecall()`, they don't hold any storage variables that would be used in the Socket systems. However, as Socket aggregates more solutions, unexpected complexities may arise that could require storing and accessing variables through additional contracts. Those contracts would be access control protected to only have the `SocketGateway` contract have the privileges to modify its variables.\r\n\r\nThis together with the `Owner` of the `SocketGateway` being able to add routes with arbitrary code creates an attack vector where a compromised address with `Owner` privileges may add a route that would contain code that exploits the special privileges assigned to the `SocketGateway` contract for their benefit.\r\n\r\nFor example, the Celer bridge needs extra logic to account for its refund mechanism, so there is an additional `CelerStorageWrapper` contract that maintains a mapping between individual bridge transfer transactions and their associated `msg.sender`:\r\n\n**src/bridges/cbridge/CelerImpl.sol:L145**\n```solidity\ncelerStorageWrapper.setAddressForTransferId(transferId, msg.sender);\n```\n\n**src/bridges/cbridge/CelerStorageWrapper.sol:L6-L12**\n```solidity\n/**\n * @title CelerStorageWrapper\n * @notice handle storageMappings used while bridging ERC20 and native on CelerBridge\n * @dev all functions ehich mutate the storage are restricted to Owner of SocketGateway\n * @author Socket dot tech.\n */\ncontract CelerStorageWrapper {\n```\n\r\nConsequently, this contract has access-protected functions that may only be called by the SocketGateway to set and delete the transfer IDs:\r\n\n**src/bridges/cbridge/CelerStorageWrapper.sol:L32**\n```solidity\nfunction setAddressForTransferId(\n```\n\n**src/bridges/cbridge/CelerStorageWrapper.sol:L52**\n```solidity\nfunction deleteTransferId(bytes32 transferId) external {\n```\n\r\nA compromised `Owner` of SocketGateway could then create a route that calls into the `CelerStorageWrapper` contract and updates the transfer IDs associated addresses to be under their control via `deleteTransferId()` and `setAddressForTransferId()` functions. This could create a significant drain of user funds, though, it depends on a compromised privileged `Owner` address.\r\n\r\n#### Recommendation\r\n\r\nAlthough it may indeed be unlikely, for aggregating solutions it is especially important to try and minimize compromised access issues. As future solutions require more complexity, consider architecting their integrations in such a way that they require as few administrative and SocketGateway-initiated transactions as possible. Through conversations with the Socket team, it appears that solutions such as timelocks on adding new routes are being considered as well, which would help catch the problem before it appears as well.",
    "dataSource": {
      "name": "/diligence/audits/2023/02/socket/",
      "repo": "https://consensys.net//diligence/audits/2023/02/socket/",
      "url": "https://consensys.net//diligence/audits/2023/02/socket/"
    }
  },
  {
    "title": "`NativeOptimismImpl` - Events Will Not Be Emitted in Case of Non-Native Tokens Bridging",
    "severity": "medium",
    "body": "#### Description\r\nIn the case of the usage of non-native tokens by users, the `SocketBridge` event will not be emitted since the code will return early. \r\n#### Examples\r\n\r\n\n**src/bridges/optimism/l1/NativeOptimism.sol:L110**\n```solidity\nfunction bridgeAfterSwap(\n```\n\r\n\n**src/bridges/optimism/l1/NativeOptimism.sol:L187**\n```solidity\nfunction swapAndBridge(\n```\n\r\n\n**src/bridges/optimism/l1/NativeOptimism.sol:L283**\n```solidity\nfunction bridgeERC20To(\n```\n\r\n#### Recommendation\r\nMake sure that the `SocketBridge` event is emitted for non-native tokens as well.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/02/socket/",
      "repo": "https://consensys.net//diligence/audits/2023/02/socket/",
      "url": "https://consensys.net//diligence/audits/2023/02/socket/"
    }
  },
  {
    "title": "Inconsistent Comments",
    "severity": "minor",
    "body": "#### Description\r\nSome of the contracts in the code have incorrect developer comments annotated for them. This could create confusion for future readers of this code that may be trying to maintain, audit, update, fork, integrate it, and so on.\r\n\r\n#### Examples\r\n\r\n\n**src/bridges/stargate/l2/Stargate.sol:L174-L183**\n```solidity\n/**\n * @notice function to bridge tokens after swap. This is used after swap function call\n * @notice This method is payable because the caller is doing token transfer and briding operation\n * @dev for usage, refer to controller implementations\n *      encodedData for bridge should follow the sequence of properties in Stargate-BridgeData struct\n * @param swapId routeId for the swapImpl\n * @param swapData encoded data for swap\n * @param stargateBridgeData encoded data for StargateBridgeData\n */\nfunction swapAndBridge(\n```\nThis is the same comment as `bridgeAfterSwap`, whereas it instead does swapping and bridging together\r\n\n**src/bridges/cbridge/CelerStorageWrapper.sol:L24-L32**\n```solidity\n/**\n * @notice function to store the transferId and message-sender of a bridging activity\n * @notice This method is payable because the caller is doing token transfer and briding operation\n * @dev for usage, refer to controller implementations\n *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n * @param transferIdAddress message sender who is making the bridging on CelerBridge\n */\nfunction setAddressForTransferId(\n```\nThis comment refers to a payable property of this function when it isn't.\r\n\n**src/bridges/cbridge/CelerStorageWrapper.sol:L45-L52**\n```solidity\n/**\n * @notice function to store the transferId and message-sender of a bridging activity\n * @notice This method is payable because the caller is doing token transfer and briding operation\n * @dev for usage, refer to controller implementations\n *      encodedData for bridge should follow the sequence of properties in CelerBridgeData struct\n * @param transferId transferId generated during the bridging of ERC20 or native on CelerBridge\n */\nfunction deleteTransferId(bytes32 transferId) external {\n```\nThis comment is copied from the above function when it does the opposite of storing - it deletes the `transferId`\r\n<!--\r\nCode URLs get formatted nicely, i.e. Vulnerable.sol#L27-L33\r\n-->\r\n\r\n#### Recommendation\r\nAdjust comments so they reflect what the functions are actually doing.\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/02/socket/",
      "repo": "https://consensys.net//diligence/audits/2023/02/socket/",
      "url": "https://consensys.net//diligence/audits/2023/02/socket/"
    }
  },
  {
    "title": "Redundant double casts",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`_rocketStorageAddress ` is already of contract type `RocketStorageInterface`.\r\n\r\n\n**code/contracts/contract/RocketBase.sol:L78-L82**\n```solidity\n/// @dev Set the main Rocket Storage address\nconstructor(RocketStorageInterface _rocketStorageAddress) {\n    // Update the contract address\n    rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n}\n```\n\r\n`_tokenAddress ` is already of contract type `ERC20Burnable`.\r\n\r\n\n**code/contracts/contract/RocketVault.sol:L132-L138**\n```solidity\nfunction burnToken(ERC20Burnable _tokenAddress, uint256 _amount) override external onlyLatestNetworkContract {\n    // Get contract key\n    bytes32 contractKey = keccak256(abi.encodePacked(getContractName(msg.sender), _tokenAddress));\n    // Update balances\n    tokenBalances[contractKey] = tokenBalances[contractKey].sub(_amount);\n    // Get the token ERC20 instance\n    ERC20Burnable tokenContract = ERC20Burnable(_tokenAddress);\n```\n\r\n`_rocketTokenRPLFixedSupplyAddress` is already of contract type `IERC20`.\r\n\r\n\n**code/contracts/contract/token/RocketTokenRPL.sol:L47-L51**\n```solidity\nconstructor(RocketStorageInterface _rocketStorageAddress, IERC20 _rocketTokenRPLFixedSupplyAddress) RocketBase(_rocketStorageAddress) ERC20(\"Rocket Pool Protocol\", \"RPL\") {\n    // Version\n    version = 1;\n    // Set the mainnet RPL fixed supply token address\n    rplFixedSupplyContract = IERC20(_rocketTokenRPLFixedSupplyAddress);\n```\n\r\n#### Recommendation\r\n\r\nWe recommend removing the unnecessary double casts and copies of local variables.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/01/rocket-pool-atlas-v1.2/",
      "repo": "https://consensys.net//diligence/audits/2023/01/rocket-pool-atlas-v1.2/",
      "url": "https://consensys.net//diligence/audits/2023/01/rocket-pool-atlas-v1.2/"
    }
  },
  {
    "title": "Reentrancy in FortaStaking during ERC1155 mints",
    "severity": "medium",
    "body": "#### Description\r\nIn the Forta staking system, the staking shares (both \"active\" and \"inactive\") are represented as tokens implemented according to the `ERC1155` standard. The specific implementation that is being used utilizes a smart contract acceptance check `_doSafeTransferAcceptanceCheck()` upon mints to the recipient.\r\n\n**code/contracts/components/staking/FortaStaking.sol:L54**\n```solidity\ncontract FortaStaking is BaseComponentUpgradeable, ERC1155SupplyUpgradeable, SubjectTypeValidator, ISlashingExecutor, IStakeMigrator {\n```\nThe specific implementation for `ERC1155SupplyUpgradeable` contracts can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/token/ERC1155/extensions/ERC1155SupplyUpgradeable.sol), and the smart contract check can be found [here](https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/25aabd286e002a1526c345c8db259d57bdf0ad28/contracts/token/ERC1155/ERC1155Upgradeable.sol#L271-L291).\r\n\r\nThis opens up reentrancy into the system's flow. In fact, the reentrancy occurs on all mints that happen in the below functions, and it happens before a call to another Forta contract for allocation is made via either `_allocator.depositAllocation` or `_allocator.withdrawAllocation`:\r\n\n**code/contracts/components/staking/FortaStaking.sol:L273-L295**\n```solidity\nfunction deposit(\n    uint8 subjectType,\n    uint256 subject,\n    uint256 stakeValue\n) external onlyValidSubjectType(subjectType) notAgencyType(subjectType, SubjectStakeAgency.MANAGED) returns (uint256) {\n    if (address(subjectGateway) == address(0)) revert ZeroAddress(\"subjectGateway\");\n    if (!subjectGateway.isStakeActivatedFor(subjectType, subject)) revert StakeInactiveOrSubjectNotFound();\n    address staker = _msgSender();\n    uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n    bool reachedMax;\n    (stakeValue, reachedMax) = _getInboundStake(subjectType, subject, stakeValue);\n    if (reachedMax) {\n        emit MaxStakeReached(subjectType, subject);\n    }\n    uint256 sharesValue = stakeToActiveShares(activeSharesId, stakeValue);\n    SafeERC20.safeTransferFrom(stakedToken, staker, address(this), stakeValue);\n\n    _activeStake.mint(activeSharesId, stakeValue);\n    _mint(staker, activeSharesId, sharesValue, new bytes(0));\n    emit StakeDeposited(subjectType, subject, staker, stakeValue);\n    _allocator.depositAllocation(activeSharesId, subjectType, subject, staker, stakeValue, sharesValue);\n    return sharesValue;\n}\n```\n\n**code/contracts/components/staking/FortaStaking.sol:L303-L326**\n```solidity\nfunction migrate(\n    uint8 oldSubjectType,\n    uint256 oldSubject,\n    uint8 newSubjectType,\n    uint256 newSubject,\n    address staker\n) external onlyRole(SCANNER_2_NODE_RUNNER_MIGRATOR_ROLE) {\n    if (oldSubjectType != SCANNER_SUBJECT) revert InvalidSubjectType(oldSubjectType); \n    if (newSubjectType != NODE_RUNNER_SUBJECT) revert InvalidSubjectType(newSubjectType); \n    if (isFrozen(oldSubjectType, oldSubject)) revert FrozenSubject();\n\n    uint256 oldSharesId = FortaStakingUtils.subjectToActive(oldSubjectType, oldSubject);\n    uint256 oldShares = balanceOf(staker, oldSharesId);\n    uint256 stake = activeSharesToStake(oldSharesId, oldShares);\n    uint256 newSharesId = FortaStakingUtils.subjectToActive(newSubjectType, newSubject);\n    uint256 newShares = stakeToActiveShares(newSharesId, stake);\n\n    _activeStake.burn(oldSharesId, stake);\n    _activeStake.mint(newSharesId, stake);\n    _burn(staker, oldSharesId, oldShares);\n    _mint(staker, newSharesId, newShares, new bytes(0));\n    emit StakeDeposited(newSubjectType, newSubject, staker, stake);\n    _allocator.depositAllocation(newSharesId, newSubjectType, newSubject, staker, stake, newShares);\n}\n```\n\n**code/contracts/components/staking/FortaStaking.sol:L365-L387**\n```solidity\nfunction initiateWithdrawal(\n    uint8 subjectType,\n    uint256 subject,\n    uint256 sharesValue\n) external onlyValidSubjectType(subjectType) returns (uint64) {\n    address staker = _msgSender();\n    uint256 activeSharesId = FortaStakingUtils.subjectToActive(subjectType, subject);\n    if (balanceOf(staker, activeSharesId) == 0) revert NoActiveShares();\n    uint64 deadline = SafeCast.toUint64(block.timestamp) + _withdrawalDelay;\n\n    _lockingDelay[activeSharesId][staker].setDeadline(deadline);\n\n    uint256 activeShares = Math.min(sharesValue, balanceOf(staker, activeSharesId));\n    uint256 stakeValue = activeSharesToStake(activeSharesId, activeShares);\n    uint256 inactiveShares = stakeToInactiveShares(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n    SubjectStakeAgency agency = getSubjectTypeAgency(subjectType);\n    _activeStake.burn(activeSharesId, stakeValue);\n    _inactiveStake.mint(FortaStakingUtils.activeToInactive(activeSharesId), stakeValue);\n    _burn(staker, activeSharesId, activeShares);\n    _mint(staker, FortaStakingUtils.activeToInactive(activeSharesId), inactiveShares, new bytes(0));\n    if (agency == SubjectStakeAgency.DELEGATED || agency == SubjectStakeAgency.DELEGATOR) {\n        _allocator.withdrawAllocation(activeSharesId, subjectType, subject, staker, stakeValue, activeShares);\n    }\n```\nAlthough this doesn't seem to be an issue in the current Forta system of contracts since the allocator's logic doesn't seem to be manipulable, this could still be dangerous as it opens up an external execution flow.\r\n\r\n#### Recommendation\r\n\r\nConsider introducing a reentrancy check or emphasize this behavior in the documentation, so that both other projects using this system later and future upgrades along with maintenance work on the Forta staking system itself are implemented safely.",
    "dataSource": {
      "name": "/diligence/audits/2022/11/forta-delegated-staking/",
      "repo": "https://consensys.net//diligence/audits/2022/11/forta-delegated-staking/",
      "url": "https://consensys.net//diligence/audits/2022/11/forta-delegated-staking/"
    }
  },
  {
    "title": "Event spam in RewardsDistributor.claimRewards",
    "severity": "minor",
    "body": "#### Description\r\nThe `RewardsDistributor` contract allows users to claim their rewards through the `claimRewards()` function. It does check to see whether or not the user has already claimed the rewards for a specific epoch that they are claiming for, but it does not check to see if the user has any associated rewards at all. This could lead to event `ClaimedRewards` being spammed by malicious users, especially on low gas chains.\r\n\r\n#### Examples\r\n\n**code/contracts/components/staking/rewards/RewardsDistributor.sol:L224-L229**\n```solidity\nfor (uint256 i = 0; i < epochNumbers.length; i++) {\n    if (_claimedRewardsPerEpoch[shareId][epochNumbers[i]][_msgSender()]) revert AlreadyClaimed();\n    _claimedRewardsPerEpoch[shareId][epochNumbers[i]][_msgSender()] = true;\n    uint256 epochRewards = _availableReward(shareId, isDelegator, epochNumbers[i], _msgSender());\n    SafeERC20.safeTransfer(rewardsToken, _msgSender(), epochRewards);\n    emit ClaimedRewards(subjectType, subjectId, _msgSender(), epochNumbers[i], epochRewards);\n```\n#### Recommendation\r\nAdd a check for rewards amounts being greater than 0.",
    "dataSource": {
      "name": "/diligence/audits/2022/11/forta-delegated-staking/",
      "repo": "https://consensys.net//diligence/audits/2022/11/forta-delegated-staking/",
      "url": "https://consensys.net//diligence/audits/2022/11/forta-delegated-staking/"
    }
  },
  {
    "title": "Ethereum reimbursements sent to an incorrect address",
    "severity": "medium",
    "body": "1inch team has written a library called `UniERC20` that extends the traditional ERC20 standard to also support eth transfers seamlessly. In the case of the `uniTransferFrom` function call, the library checks that the `msg.value` of the transaction is bigger or equal to the amount passed in the function argument. If the `msg.value` is larger than the amount required, the difference, or extra funds, should be sent to the sender. In the actual implementation Instead of returning the funds to the sender, extra funds are actually sent to the destination. \r\n\r\n\n**solidity-utils/contracts/libraries/UniERC20.sol:L59-L65**\n```solidity\nif (msg.value > amount) {\n    // Return remainder if exist\n    unchecked {\n        (bool success, ) = to.call{value: msg.value - amount}(\"\");  // solhint-disable-line avoid-low-level-calls\n        if (!success) revert ETHSendFailed();\n    }\n}\n```\n\r\nGiven that this code is packed as a library and allows for easy reusability by the 1inch team and outside developers it is crucial that this logic is written well and well tested.\r\n\r\nWe recommend reconsidering reimbursing the sender when an incorrect amount is being sent because it introduces an easy-to-oversee reentrancy backdoor with `call()` that is mentioned in 11. Reverting was a default behavior in similar cases across the rest of the 1inch contracts. \r\n\r\nIf this functionality is required, a fix we could recommend is replacing the `to` with `from`. We can also suggest running a fuzzing campaign against this library.",
    "dataSource": {
      "name": "/diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/",
      "repo": "https://consensys.net//diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/",
      "url": "https://consensys.net//diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/"
    }
  },
  {
    "title": "Re-entrancy risk in UniERC20",
    "severity": "medium",
    "body": "UniERC20 is a general library for facilitating transfers of any ERC20 or native coin assets. It features gas-efficient code and could be easily integrated into large systems of contract, such as those that are used in this audit -- 1inch routers and limit order protocol.\r\n\r\nHowever, it also utilizes `.call(){value:X}` method of transferring chain native assets, such as ETH. This introduces a large risk in the form of re-entrancy attacks, so any system implementing this library would have to handle them. While 1inch's projects in the scope of this audit do not seem to have re-entrancy attack vectors, other projects that could be utilizing this library might. Since this is an especially efficient and convenient library, the likelihood that some other project using this suffers and then sufferring a re-entrancy attack is significant.\r\n\n**solidity-utils/contracts/libraries/UniERC20.sol:L45**\n```solidity\n(bool success, ) = to.call{value: amount}(\"\");  // solhint-disable-line avoid-low-level-calls\n```\n\n**solidity-utils/contracts/libraries/UniERC20.sol:L62**\n```solidity\n(bool success, ) = to.call{value: msg.value - amount}(\"\");  // solhint-disable-line avoid-low-level-calls\n```\n\r\nConsider instead implementing `transfer()` or `send()` methods for transferring chain native assets, such as ETH, instead of performing a `.call()`\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/",
      "repo": "https://consensys.net//diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/",
      "url": "https://consensys.net//diligence/audits/2022/08/1inch-exchange-aggregationrouter-v5/"
    }
  },
  {
    "title": "General Recommendations",
    "severity": null,
    "body": "#### Description\r\nAmong the many contracts, there are a few minor inaccuracies in the comments or the code and some parts could potentially be improved with industry standard practices.\r\n\r\n#### Examples\r\n\r\n**- 2 step changes for privileged contract addresses.**\r\n\r\nSome contracts in the system have setters for privileged addresses that control the contract logic, such as the keeper. Especially for those that are intended to be controlled by a private key as opposed to a contract, it would be best to do a two step change for those addresses. First, nominate the address, and second accept the nomination from that address ensuring that the access is indeed secured. In fact, one contract already uses this pattern:\r\n\n**code/contracts/Vault.sol:L337-L359**\n```solidity\n/// @notice Nominates new governance address.\n/// @dev  Governance will only be changed if the new governance accepts it. It will be pending till then.\n/// @param _governance The address of new governance.\nfunction setGovernance(address _governance) public {\n    onlyGovernance();\n    pendingGovernance = _governance;\n}\n\n/// @notice Emitted when governance is updated.\n/// @param oldGovernance The address of the current governance.\n/// @param newGovernance The address of new governance.\nevent UpdatedGovernance(\n    address indexed oldGovernance,\n    address indexed newGovernance\n);\n\n/// @notice The nomine of new governance address proposed by `setGovernance` function can accept the governance.\n/// @dev  This can only be called by address of pendingGovernance.\nfunction acceptGovernance() public {\n    require(msg.sender == pendingGovernance, \"INVALID_ADDRESS\");\n    emit UpdatedGovernance(governance, pendingGovernance);\n    governance = pendingGovernance;\n}\n```\nConsider adding the same pattern to these and others where you may see it as appropriate:\r\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L180-L184**\n```solidity\n/// @notice keeper setter\n/// @param _keeper new keeper address\nfunction setKeeper(address _keeper) public onlyAuthorized {\n    keeper = _keeper;\n}\n```\n\n**code/contracts/Vault.sol:L365-L372**\n```solidity\n/// @notice Sets new keeper address.\n/// @dev  This can only be called by governance.\n/// @param _keeper The address of new keeper.\nfunction setKeeper(address _keeper) public {\n    onlyGovernance();\n    keeper = _keeper;\n    emit UpdatedKeeper(_keeper);\n}\n```\n\r\n**- Emit events for critical changes.**\r\n\r\nSome contracts emit events during critical changes, such as `Vault.setPerformanceFee()` with `emit UpdatePerformanceFee`, whereas other contracts, like trade executors, do not have events for likewise crucial changes. Consider creating and implementing events for functions like:\r\n\n**code/contracts/Batcher/Batcher.sol:L362-L372**\n```solidity\n/// @inheritdoc IBatcher\nfunction setVaultLimit(uint256 maxAmount) external override {\n    onlyGovernance();\n    vaultInfo.maxAmount = maxAmount;\n}\n\n/// @notice Function to enable/disable deposit signature check\nfunction setDepositSignatureCheck(bool enabled) public {\n    onlyGovernance();\n    checkValidDepositSignature = enabled;\n}\n```\n\n**code/contracts/ConvexTradeExecutor.sol:L30-L39**\n```solidity\n/// @param _harvester address of harvester\nfunction setHandler(address _harvester) external onlyGovernance {\n    ConvexPositionHandler._configHandler(_harvester, vaultWantToken());\n}\n\n/// @notice Governance function to set max accepted slippage of swaps\n///@param _slippage Max accepted slippage during harvesting\nfunction setSlippage(uint256 _slippage) external onlyGovernance {\n    ConvexPositionHandler._setSlippage(_slippage);\n}\n```\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L449-L453**\n```solidity\n/// @notice Keeper function to set max accepted slippage of swaps\n/// @param _slippage Max accepted slippage during harvesting\nfunction _setSlippage(uint256 _slippage) internal {\n    maxSlippage = _slippage;\n}\n```\n\n**code/contracts/ConvexExecutor/Harvester.sol:L87-L96**\n```solidity\n/// @notice Keeper function to set position handler to harvest for\n/// @param _addr address of the position handler\nfunction setPositionHandler(address _addr)\n    external\n    override\n    validAddress(_addr)\n    onlyKeeper\n{\n    positionHandler = _addr;\n}\n```\n\n**code/contracts/LyraTradeExecutor.sol:L65-L75**\n```solidity\n/// @notice Socket registry setter, called by keeper\n/// @param _socketRegistry address of new socket registry\nfunction setSocketRegistry(address _socketRegistry) public onlyKeeper {\n    socketRegistry = _socketRegistry;\n}\n\n/// @notice L2 Position Handler setter, called by keeper\n/// @param _l2HandlerAddress address of new position handler on L2\nfunction setL2Handler(address _l2HandlerAddress) public onlyKeeper {\n    positionHandlerL2Address = _l2HandlerAddress;\n}\n```\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L74-L76**\n```solidity\nfunction setSlippage(uint256 _slippage) public onlyAuthorized {\n    slippage = _slippage;\n}\n```\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L174-L184**\n```solidity\n/// @notice socket registry setter\n/// @param _socketRegistry new address of socket registry\nfunction setSocketRegistry(address _socketRegistry) public onlyAuthorized {\n    socketRegistry = _socketRegistry;\n}\n\n/// @notice keeper setter\n/// @param _keeper new keeper address\nfunction setKeeper(address _keeper) public onlyAuthorized {\n    keeper = _keeper;\n}\n```\n\r\n**- Unnecessary variables with hardcoded values**\r\n\r\nThe `ConvexPositionHandler` has constants that are used throughout the contract as well as variables that are initialised within the `_configHandler()` function with exactly the same hardcoded values. Consider keeping and using only one of the two sets\r\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L72-L85**\n```solidity\n/// @notice address of LP Token (ETH/stETH pool)\nIERC20 public immutable lpToken =\n    IERC20(0x06325440D014e39736583c165C2963BA99fAf14E);\n\n/// @notice address of Convex reward pool\nIConvexRewards public immutable baseRewardPool =\n    IConvexRewards(0x0A760466E1B4621579a82a39CB56Dda2F4E70f03);\n/// @notice address of Convex booster\nIConvexBooster public immutable convexBooster =\n    IConvexBooster(0xF403C135812408BFbE8713b5A23a04b3D48AAE31);\n\n/// @notice address of ETH/stETH pool\nICurvePool public immutable ethStEthPool =\n    ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);\n```\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L92-L96**\n```solidity\n/// @param _wantToken address of want token\nfunction _configHandler(address _harvester, address _wantToken) internal {\n    address ETH_STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n    address LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E;\n    address CONVEX_BOOSTER = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n```\n\r\n**- 2 functions with almost the same name doing the same thing**\r\n\r\n`LyraPositionHandlerL2` and `UniswapV3Controller` (that `LyraPositionHandlerL2` inherits from) have two functions that do the same thing `setSlippage()` and `_setSlippage()` respectively. The former is public with a `onlyAuthorized` modifier whereas the latter is internal only. Consider implementing `LyraPositionHandlerL2.setSlippage()` such that it instead calls `_setSlippage()`\r\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L74-L76**\n```solidity\nfunction setSlippage(uint256 _slippage) public onlyAuthorized {\n    slippage = _slippage;\n}\n```\n\n**code/contracts/LyraL2/UniswapV3Controller.sol:L43-L45**\n```solidity\nfunction _setSlippage(uint256 _slippage) internal {\n    slippage = _slippage;\n}\n```\n\r\n**- Typos**\r\n\r\nThere are minor typos in a few function names as well as some inconsistent comments. Consider fixing to make things like code search by function name / comment description easier.\r\n\r\n- BaseTradeExecutor \"initate\" instead of \"init**I**ate\"\r\n\n**code/contracts/BaseTradeExecutor.sol:L63-L67**\n```solidity\nfunction initateWithdraw(bytes calldata _data) public override onlyKeeper {\n    require(!withdrawalStatus.inProcess, \"WITHDRW_IN_PROGRESS\");\n    withdrawalStatus.inProcess = true;\n    _initiateWithdraw(_data);\n}\n```\n\r\n- BaseTradeExecutor \"WITHDRW_IN_PROGRESS\" and \"WIHDRW_COMPLETED\" are inconsistently or incorrectly shortened as opposed to \"WITHDRAW_IN_PROGRESS\" and \"WITHDRAW_COMPLETED\"\r\n\n**code/contracts/BaseTradeExecutor.sol:L63-L73**\n```solidity\nfunction initateWithdraw(bytes calldata _data) public override onlyKeeper {\n    require(!withdrawalStatus.inProcess, \"WITHDRW_IN_PROGRESS\");\n    withdrawalStatus.inProcess = true;\n    _initiateWithdraw(_data);\n}\n\nfunction confirmWithdraw() public override onlyKeeper {\n    require(withdrawalStatus.inProcess, \"WIHDRW_COMPLETED\");\n    _confirmWithdraw();\n    withdrawalStatus.inProcess = false;\n}\n```\n\r\n- `LyraTradeExecutor.confirmWithdraw()` incorrect comment. It is the same as the one for `_confirmDeposit()` and says it confirms transfer **to** the L2 contract as opposed to **from**  the L2 contract.\r\n\n**code/contracts/LyraTradeExecutor.sol:L97-L102**\n```solidity\n/// @notice To confirm transfer of want tokens to L2\n/// @dev Handle anything related to deposit confirmation\nfunction _confirmWithdraw() internal override {\n    if (address(this).balance > 0)\n        IWETH9(wantTokenL1).deposit{value: address(this).balance}();\n}\n```\n\r\n- `SocketV1Controller.decodeSocketRegistryCalldata` comment suggests that this is \"not in use due to undertainity in bungee api response\", however this is called by `verifySocketCalldata()` in `sendTokens()` which in turn is called by `LyraPositionHandler._deposit()`\r\n\n**code/contracts/LyraExecutor/SocketV1Controller.sol:L37-L41**\n```solidity\n/// @notice Decode the socket request calldata\n/// @dev Currently not in use due to undertainity in bungee api response\n/// @param _data Bungee txn calldata\n/// @return userRequest parsed calldata\nfunction decodeSocketRegistryCalldata(bytes memory _data)\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "LyraPositionHandlerL2 inaccurate modifier onlyAuthorized may lead to funds loss if keeper is compromised",
    "severity": "medium",
    "body": "#### Description\r\nThe `LyraPositionHandlerL2` contract is operated either by the L2 keeper or  by the L1 `LyraPositionHandler` via the `L2CrossDomainMessenger`. This is implemented through the `onlyAuthorized` modifier:\r\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L187-L195**\n```solidity\nmodifier onlyAuthorized() {\n    require(\n        ((msg.sender == L2CrossDomainMessenger &&\n            OptimismL2Wrapper.messageSender() == positionHandlerL1) ||\n            msg.sender == keeper),\n        \"ONLY_AUTHORIZED\"\n    );\n    _;\n}\n```\n\r\nThis is set on:\r\n\r\n1. `withdraw()`\r\n2. `openPosition()`\r\n3. `closePosition()`\r\n4.  `setSlippage()`\r\n5. `deposit()`\r\n6. `sweep()`\r\n7. `setSocketRegistry()`\r\n8. `setKeeper()` \r\n\r\nFunctions 1-3 have a corresponding implementation on the L1 `LyraPositionHandler`, so they could indeed be called by it with the right parameters. However, 4-8 do not have an implemented way to call them from L1, and this modifier creates an unnecessarily expanded list of authorised entities that can call them. \r\n\r\nAdditionally, even if their implementation is provided, it needs to be done carefully because `msg.sender` in their case is going to end up being the `L2CrossDomainMessenger`. For example, the `sweep()` function sends any specified token to `msg.sender`, with the intention likely being that the recipient is under the team's or the governance's control -- yet, it will be `L2CrossDomainMessenger` and the tokens will likely be lost forever instead.\r\n\r\nOn the other hand, the `setKeeper()` function would need a way to be called by something other than the keeper because it is intended to change the keeper itself. In the event that the access to the L2 keeper is compromised, and the L1 `LyraPositionHandler` has no way to call `setKeeper()` on the `LyraPositionHandlerL2`, the whole contract and its funds will be compromised as well. So, there needs to be some way to at least call the `setKeeper()` by something other than the keeper to ensure security of the funds on L2. \r\n\r\n#### Examples\r\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L153-L184**\n```solidity\nfunction closePosition(bool toSettle) public override onlyAuthorized {\n    LyraController._closePosition(toSettle);\n    UniswapV3Controller._estimateAndSwap(\n        false,\n        LyraController.sUSD.balanceOf(address(this))\n    );\n}\n\n/*///////////////////////////////////////////////////////////////\n                        MAINTAINANCE FUNCTIONS\n//////////////////////////////////////////////////////////////*/\n\n/// @notice Sweep tokens\n/// @param _token Address of the token to sweepr\nfunction sweep(address _token) public override onlyAuthorized {\n    IERC20(_token).transfer(\n        msg.sender,\n        IERC20(_token).balanceOf(address(this))\n    );\n}\n\n/// @notice socket registry setter\n/// @param _socketRegistry new address of socket registry\nfunction setSocketRegistry(address _socketRegistry) public onlyAuthorized {\n    socketRegistry = _socketRegistry;\n}\n\n/// @notice keeper setter\n/// @param _keeper new keeper address\nfunction setKeeper(address _keeper) public onlyAuthorized {\n    keeper = _keeper;\n}\n```\n#### Recommendation\r\nCreate an additional modifier for functions intended to be called just by the keeper (`onlyKeeper`) such as functions 4-7, and create an additional modifier `onlyGovernance` for the `setKeeper()` function. As an example, the L1 `Vault` contract also has a `setKeeper()` function that has a `onlyGovernance()` modifier. Please note that this will likely require implementing a function for the system's governance that can call `LyraPositionHandlerL2.setKeeper()` via the `L2CrossDomainMessenger`.",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Harvester.rewardTokens doesn't account for LDO tokens",
    "severity": "medium",
    "body": "#### Description\r\nAs part of the vault's strategy, the reward tokens for participating in Curve's ETH-stETH pool and Convex staking are claimed and swapped for ETH. This is done by having the `ConvexPositionHandler` contract call the reward claims API from Convex via `baseRewardPool.getReward()`, which transfers the reward tokens to the handler's address. Then, the tokens are iterated through and sent to the harvester to be swapped from `ConvexPositionHandler` by getting their list from `harvester.rewardTokens()` and calling `harvester.harvest()`\r\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L274-L290**\n```solidity\n// get list of tokens to transfer to harvester\naddress[] memory rewardTokens = harvester.rewardTokens();\n//transfer them\nuint256 balance;\nfor (uint256 i = 0; i < rewardTokens.length; i++) {\n    balance = IERC20(rewardTokens[i]).balanceOf(address(this));\n\n    if (balance > 0) {\n        IERC20(rewardTokens[i]).safeTransfer(\n            address(harvester),\n            balance\n        );\n    }\n}\n\n// convert all rewards to WETH\nharvester.harvest();\n```\n\r\nHowever, `harvester.rewardTokens()` doesn't have the LDO token's address in its list, so they will not be transferred to the harvester to be swapped.\r\n\r\n\n**code/contracts/ConvexExecutor/Harvester.sol:L77-L82**\n```solidity\nfunction rewardTokens() external pure override returns (address[] memory) {\n    address[] memory rewards = new address[](2);\n    rewards[0] = address(crv);\n    rewards[1] = address(cvx);\n    return rewards;\n}\n```\n\r\nAs a result, `harvester.harvest()` will not be able to execute its `_swapLidoForWETH()` function since its `ldoBalance` will be 0. This results in missed rewards and therefore yield for the vault as part of its normal flow.\r\n\r\nThere is a possible mitigation in the current state of the contract that would require governance to call `sweep()` on the LDO balance from the `BaseTradeExecutor` contract (that `ConvexPositionHandler` inherits) and then transferring those LDO tokens to the harvester contract to perform the swap at a later rewards claim. This, however, requires transactions separate from the intended flow of the system as well as governance intervention.\r\n\r\n#### Recommendation\r\n\r\nAdd the LDO token address to the `rewardTokens()` function by adding the following line\r\n`rewards[2] = address(ldo); `\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Keeper design complexity",
    "severity": "medium",
    "body": "#### Description\r\nThe current design of the protocol relies on the keeper being operated correctly in a complex manner. Since the offchain code for the keeper wasn't in scope of this audit, the following is a commentary on the complexity of the keeper operations in the context of the contracts. Keeper logic such as the order of operations and function argument parameters with log querying are some examples where if the keeper doesn't execute them correctly, there may be inconsistencies and issues with accounting of vault shares and vault funds resulting in unexpected behaviour. While it may represent little risk or issues to the current Brahma-fi team as the vault is recently live, the keeper logic and exact steps should be well documented so that public keepers (if and when they are enabled) can execute the logic securely and future iterations of the vault code can account for any intricacies of the keeper logic.\r\n#### Examples\r\n\r\n**1. Order of operations: Convex rewards & new depositors profiting at the expense of old depositors' yielded reward tokens.**\r\nAs part of the vault's strategy, the depositors' ETH is provided to Curve and the LP tokens are staked in Convex, which yield rewards such as CRV, CVX, and LDO tokens. As new depositors provide their ETH, the vault shares minted for their deposits will be less compared to old deposits as they account for the increasing value of LP tokens staked in these pools. In other words, if the first depositor provides 1 ETH, then when a new depositor provides 1 ETH much later, the new depositor will get less shares back as the `totalVaultFunds()` will increase:\r\n\n**code/contracts/Vault.sol:L97-L99**\n```solidity\nshares = totalSupply() > 0\n    ? (totalSupply() * amountIn) / totalVaultFunds()\n    : amountIn;\n```\n\n**code/contracts/Vault.sol:L127-L130**\n```solidity\nfunction totalVaultFunds() public view returns (uint256) {\n    return\n        IERC20(wantToken).balanceOf(address(this)) + totalExecutorFunds();\n}\n```\n\n**code/contracts/ConvexTradeExecutor.sol:L21-L23**\n```solidity\nfunction totalFunds() public view override returns (uint256, uint256) {\n    return ConvexPositionHandler.positionInWantToken();\n}\n```\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L121-L137**\n```solidity\nfunction positionInWantToken()\n    public\n    view\n    override\n    returns (uint256, uint256)\n{\n    (\n        uint256 stakedLpBalanceInETH,\n        uint256 lpBalanceInETH,\n        uint256 ethBalance\n    ) = _getTotalBalancesInETH(true);\n\n    return (\n        stakedLpBalanceInETH + lpBalanceInETH + ethBalance,\n        block.number\n    );\n}\n```\n\r\nHowever, this does not account for the reward tokens yielded throughout that time. From the smart contract logic alone, there is no requirement to first execute the reward token harvest. It is up to the keeper to execute `ConvexTradeExecutor.claimRewards` in order to claim and swap their rewards into ETH, which only then will be included into the yield in the above `ConvexPositionHandler.positionInWantToken` function. If this is not done prior to processing new deposits and minting new shares, new depositors would unfairly benefit from the reward tokens' yield that was generated before they deposited but accounted for in the vault funds only after they deposited.\r\n\r\n**2. Order of operations: closing Lyra options before processing new deposits.**\r\n\r\nThe other part of the vault's strategy is utilising the yield from Convex to purchase options from Lyra on Optimism. While Lyra options are risky and can become worthless in the event of bad trades, only yield is used for them, therefore keeping user deposits' initial value safe. However, their value could also yield significant returns, increasing the overall funds of the vault. Just as with `ConvexTradeExecutor`, `LyraTradeExecutor` also has a `totalFunds()` function that feeds into the vault's `totalVaultFunds()` function. In Lyra's case, however, it is a manually set value by the keeper that is supposed to represent the value of Lyra L2 options:\r\n\n**code/contracts/LyraTradeExecutor.sol:L42-L53**\n```solidity\nfunction totalFunds()\n    public\n    view\n    override\n    returns (uint256 posValue, uint256 lastUpdatedBlock)\n{\n    return (\n        positionInWantToken.posValue +\n            IERC20(vaultWantToken()).balanceOf(address(this)),\n        positionInWantToken.lastUpdatedBlock\n    );\n}\n```\n\n**code/contracts/LyraTradeExecutor.sol:L61-L63**\n```solidity\nfunction setPosValue(uint256 _posValue) public onlyKeeper {\n    LyraPositionHandler._setPosValue(_posValue);\n}\n```\n\n**code/contracts/LyraExecutor/LyraPositionHandler.sol:L218-L221**\n```solidity\nfunction _setPosValue(uint256 _posValue) internal {\n    positionInWantToken.posValue = _posValue;\n    positionInWantToken.lastUpdatedBlock = block.number;\n}\n```\n\r\nSolely from the smart contract logic, there is a possibility that a user deposits when Lyra options are valued high, meaning the total vault funds are high as well, thus decreasing the amount of shares the user would have received if it weren't for the Lyra options' value. Consequently, if after the deposit the Lyra options become worthless, decreasing the total vault funds, the user's newly minted shares will now represent less than what they have deposited.\r\n\r\nWhile this is not currently mitigated by smart contract logic, it may be worked around by the keeper first settling and closing all Lyra options and transferring all their yielded value in ETH, if any, to the Convex trade executor. Only then the keeper would process new deposits and mint new shares. This order of operations is critical to maintain the vault's intended safe strategy of maintaining the user's deposited value, and is dependent entirely on the keeper offchain logic.\r\n\r\n**3.  Order of operations: additional trade executors and their specific management**\r\nSimilarly to the above examples, as more trade executors and position handlers are added to the vault, the complexity for the keeper will go up significantly, requiring it to maintain all correct orders of operations **not just** to keep the shares and funds accounting intact, but simply for the trade executors to function normally. For example, in the case of Lyra, the keepers need to manually call `confirmDeposit` and `confirmWithdraw` to update their `depositStatus` and `withdrawalStatus` respectively to continue normal operations or otherwise new deposits and withdrawals wouldn't be processed. On the other hand, the Convex executor does it automatically.\r\nDue to the system design, there may be no single standard way to handle a trade executor. New executors may also require specific calls to be done manually, increasing overall complexity keeper logic to support the system.\r\n\r\n**4. Keeper calls &  arguments: `depositFunds`/`batchDeposit` and `initiateWithdrawal`/`batchWithdraw` `userAddresses[]` array + gas overhead**\r\nWith the current gated approach and batching for deposits and withdrawals to and from the vault, users aren't able to directly mint and redeem their vault shares. Instead, they interact with the `Batcher` contract that then communicates with the `Vault` contract with the help of the keeper. However, while each user's deposit and withdrawal amounts are registered in the contract state variables such as `depositLedger[user]` and `withdrawLedger[user]`, and there is an event emitted with the user address and their action, to process them the keeper is required to keep track of all the user addresses in the batch they need to process. In particular, the keeper needs to provide `address[] memory users` for both `batchDeposit()` and `batchWithdraw()` functions that communicate with the vault. There is no stored list of users within the contract that could provide or verify the right users, so it is entirely up to the keeper's offchain logic to query the logs and retrieve the addresses required. \r\nTherefore, depending on the size of the `address[] memory users` array, the keepers may need to consider the transaction gas limit, possibly requiring splitting the array up and doing several transactions to process all of them.\r\nIn addition, in the event of withdrawals, the keepers need to calculate how much of the `wantToken` (WETH in our case) will be required to process the withdrawals, and call `withdrawFromExecutor()` with that amount to provide enough assets to cover withdrawals from the vault.\r\n\r\n**5. Timing: 50 block radius for updates on trade executors that need to have their values updated via a call**\r\nSome trade executors, like the Convex one, can retrieve their funds value at any time from Layer 1, thereby always being up to date with the current block. Others, like the Lyra trade executor, require the keeper to update their position value by initiating a call, which also updates their `positionInWantToken.lastUpdatedBlock` state variable. However, this variable is also called during during the `vault.totalVaultFunds()`call during deposits and withdrawals via `totalExecutorFunds()`, which eventually calls `areFundsUpdated(blockUpdated)`. This is a check to ensure that the current transaction's `block.number <= _blockUpdated + BLOCK_LIMIT`, where `BLOCK_LIMIT`=50 blocks, i.e. roughly 12-15 min. \r\nAs a result, keepers need to make sure that all executors that require a call for this have their position values updated before and rather close to processing and deposits or withdrawals, or `areFundsUpdated()` will revert those calls.\r\n\r\n\r\n#### Recommendation\r\nDocument the exact order of operations, steps, necessary logs and parameters that keepers need to keep track of in order for the vault strategy to succeed.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Approving MAX_UINT amount of ERC20 tokens",
    "severity": "minor",
    "body": "#### Description\r\nApproving the maximum value of uint256 is a known practice to save gas. However, this pattern was proven to increase the impact of an attack many times in the past, in case the approved contract gets hacked.\r\n#### Examples\r\n\n**code/contracts/BaseTradeExecutor.sol:L19**\n```solidity\nIERC20(vaultWantToken()).approve(vault, MAX_INT);\n```\n\r\n\n**code/contracts/Batcher/Batcher.sol:L48**\n```solidity\nIERC20(vaultInfo.tokenAddress).approve(vaultAddress, type(uint256).max);\n```\n\r\n\n**code/contracts/ConvexExecutor/ConvexPositionHandler.sol:L106-L112**\n```solidity\nIERC20(LP_TOKEN).safeApprove(ETH_STETH_POOL, type(uint256).max);\n\n// Approve max LP tokens to convex booster\nIERC20(LP_TOKEN).safeApprove(\n    address(CONVEX_BOOSTER),\n    type(uint256).max\n);\n```\n\r\n\n**code/contracts/ConvexExecutor/Harvester.sol:L65-L69**\n```solidity\ncrv.safeApprove(address(crveth), type(uint256).max);\n// max approve CVX to CVX/ETH pool on curve\ncvx.safeApprove(address(cvxeth), type(uint256).max);\n// max approve LDO to uniswap swap router\nldo.safeApprove(address(uniswapRouter), type(uint256).max);\n```\n\r\n\n**code/contracts/LyraL2/LyraPositionHandlerL2.sol:L63-L71**\n```solidity\nIERC20(wantTokenL2).safeApprove(\n    address(UniswapV3Controller.uniswapRouter),\n    type(uint256).max\n);\n// approve max susd balance to uniV3 router\nLyraController.sUSD.safeApprove(\n    address(UniswapV3Controller.uniswapRouter),\n    type(uint256).max\n);\n```\n\r\n\r\n#### Recommendation\r\nConsider approving the exact amount that’s needed to be transferred, or alternatively, add an external function that allows the revocation of approvals.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Batcher.depositFunds may allow for more deposits than vaultInfo.maxAmount",
    "severity": "minor",
    "body": "#### Description\r\nAs part of a gradual rollout strategy, the Brahma-fi system of contracts has a limit of how much can be deposited into the protocol.  This is implemented through the `Batcher` contract that allows users to deposit into it and keep the amount they have deposited in the `depositLedger[recipient]` state variable. In order to cap how much is deposited, the user's input `amountIn` is evaluated within the following statement:\r\n\r\n\n**code/contracts/Batcher/Batcher.sol:L109-L116**\n```solidity\nrequire(\n    IERC20(vaultInfo.vaultAddress).totalSupply() +\n        pendingDeposit -\n        pendingWithdrawal +\n        amountIn <=\n        vaultInfo.maxAmount,\n    \"MAX_LIMIT_EXCEEDED\"\n);\n```\n\r\nHowever, while `pendingDeposit`, `amountIn`, and `vaultInfo.maxAmount` are denominated in the vault asset token (WETH in our case), `IERC20(vaultInfo.vaultAddress).totalSupply()` and `pendingWithdrawal` represent vault shares tokens, creating potential mismatches in this evaluation. \r\n\r\nAs the yield brings in more and more funds to the vault, the amount of share minted for each token deposited in decreases, so `totalSupply()` becomes less than the total deposited amount (not just vault funds) as the strategy succeeds over time. For example, at first `X` deposited tokens would mint `X` shares. After some time, this would create additional funds in the vault through yield, and another `X` deposit of tokens would mint **less** than `X` shares, say `X-Y`, where `Y` is some number greater than 0 representing the difference in the number of shares minted. So, while there were `2*X` deposited tokens, `totalSupply()=(2*X-Y)` shares would have been minted in total. However, at the time of the next deposit, a user's `amountIn` will be added with `totalSupply()=(2*X-Y)` number of shares instead of a greater `2*X` number of deposited tokens. So, this will undershoot the actual amount of tokens deposited after this user's deposit, thus potentially evaluating it less than `maxAmount`, and letting more user deposits get inside the vault than what was intended. \r\n\r\n#### Recommendation\r\n\r\nConsider either documenting this potential discrepancy or keeping track of all deposits in a state variable and using that inside the `require` statement..\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Batcher doesn't work properly with arbitrary tokens",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe `Batcher` and the `Vault` contracts initially operate with ETH and WETH. But the contracts are supposed to be compatible with any other ERC-20 tokens.\r\n\r\nFor example, in the `Batcher.deposit` function, there is an option to transfer ETH instead of the token, which should only be happening if the token is WETH. Also, the token is named `WETH`, but if the intention is to use the Batcher contract with arbitrary tokens token, it should be named differently.\r\n\r\n\n**code/contracts/Batcher/Batcher.sol:L89-L100**\n```solidity\nif (ethSent > 0) {\n    amountIn = ethSent;\n    WETH.deposit{value: ethSent}();\n}\n/// If no wei sent, use amountIn and transfer WETH from txn sender\nelse {\n    IERC20(vaultInfo.tokenAddress).safeTransferFrom(\n        msg.sender,\n        address(this),\n        amountIn\n    );\n}\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/05/brahma-fi/",
      "repo": "https://consensys.net//diligence/audits/2022/05/brahma-fi/",
      "url": "https://consensys.net//diligence/audits/2022/05/brahma-fi/"
    }
  },
  {
    "title": "Consider adding zero address checks",
    "severity": null,
    "body": "The Tribe DAO codebase inherits from the [solmate]() library which is designed for maximum gas efficiency, often at the cost of user safety. Tribe DAO makes use of solmate's ERC20 implementation in particular which forgoes zero address checks in it's transfer functions. Consider adding these checks in logic that makes use of ERC20 `transfer` and `transferFrom` to avoid losses that occur due to user error.",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Improve code readability",
    "severity": null,
    "body": "#### Examples\r\nSome parts are inconsistent with the rest of the codebase despite meaning to do exactly the same thing. In particular, the calculation of cycle boundaries in `xERC4626` doesn't have brackets around the division operation.\r\n\r\n\n**code-erc4626/src/xERC4626.sol:L40-L40**\n```solidity\nrewardsCycleEnd = block.timestamp.safeCastTo32() / rewardsCycleLength * rewardsCycleLength;\n```\n\r\n\n**code-erc4626/src/xERC4626.sol:L90**\n```solidity\nuint32 end = (timestamp + rewardsCycleLength) / rewardsCycleLength * rewardsCycleLength;\n```\n\r\nAs opposed to these examples:\r\n\n**code-flywheel-v2/src/token/ERC20Gauges.sol:L89-L94**\n```solidity\nfunction _getGaugeCycleEnd() internal view returns (uint32) {\n    uint32 nowPlusOneCycle = block.timestamp.safeCastTo32() + gaugeCycleLength;\n    unchecked {\n        return (nowPlusOneCycle / gaugeCycleLength) * gaugeCycleLength; // cannot divide by zero and always <= nowPlusOneCycle so no overflow\n    }\n}\n```\n\n**code-flywheel-v2/src/rewards/FlywheelGaugeRewards.sol:L90**\n```solidity\ngaugeCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n```\n\n**code-flywheel-v2/src/rewards/FlywheelGaugeRewards.sol:L101-L103**\n```solidity\nfunction queueRewardsForCycle() external requiresAuth returns (uint256 totalQueuedForCycle) {\n    // next cycle is always the next even divisor of the cycle length above current block timestamp.\n    uint32 currentCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n```\n\n**code-flywheel-v2/src/rewards/FlywheelGaugeRewards.sol:L133-L135**\n```solidity\nfunction queueRewardsForCyclePaginated(uint256 numRewards) external requiresAuth {\n    // next cycle is always the next even divisor of the cycle length above current block timestamp.\n    uint32 currentCycle = (block.timestamp.safeCastTo32() / gaugeCycleLength) * gaugeCycleLength;\n```\n\r\nIn `ERC20MultiVotes.sol`, there are four different functions with two of each group bearing the same name. Luckily, this isn't a big issue thanks to how function selectors work however, the developers are encouraged to use different names to avoid confusion and improve readability. Consider Renaming the function in lines 211 to `_delegateAndUndelegate` or something more fitting and renaming the function in lines 207 to 209 to `delegateAll/undelegateAndDelegateAll`.\r\n\r\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L211**\n```solidity\nfunction _delegate(address delegator, address newDelegatee) internal virtual {\n```\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L229-L233**\n```solidity\nfunction _delegate(\n    address delegator,\n    address delegatee,\n    uint256 amount\n) internal virtual {\n```\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L189-L191**\n```solidity\nfunction delegate(address delegatee, uint256 amount) public virtual {\n    _delegate(msg.sender, delegatee, amount);\n}\n```\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L207-L209**\n```solidity\nfunction delegate(address newDelegatee) external virtual {\n    _delegate(msg.sender, newDelegatee);\n}\n```",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Reactivated gauges can't queue up rewards",
    "severity": "major",
    "body": "#### Description\r\nActive gauges as set in `ERC20Gauges.addGauge()` function by authorised users get their rewards queued up in the `FlywheelGaugeRewards._queueRewards()` function. As part of it, their associated struct `QueuedRewards` updates its `storedCycle` value to the cycle in which they get queued up:\r\n\r\n\n**code-flywheel-v2/src/rewards/FlywheelGaugeRewards.sol:L202-L206**\n```solidity\ngaugeQueuedRewards[gauge] = QueuedRewards({\n    priorCycleRewards: queuedRewards.priorCycleRewards + completedRewards,\n    cycleRewards: uint112(nextRewards),\n    storedCycle: currentCycle\n});\n```\n\r\nHowever, these gauges may be deactivated in `ERC20Gauges.removeGauge()`, and they will now be ignored in either `FlywheelGaugeRewards.queueRewardsForCycle() `or `FlywheelGaugeRewards.queueRewardsForCyclePaginated()` because both use `gaugeToken.gauges()` to get the set of gauges for which to queue up rewards for the cycle, and that only gives active gauges. Therefore, any updates `FlywheelGaugeRewards` makes to its state will not be done to deactivated gauges' `QueuedRewards` structs. In particular, the `gaugeCycle` contract state variable will keep advancing throughout its cycles, while `QueuedRewards.storedCycle` will retain its previously set value, which is the cycle where it was queued and not 0.\r\n\r\nOnce reactivated later with at least 1 full cycle being done without it, it will produce issues. It will now be returned by `gaugeToken.gauges()` to be processed in either `FlywheelGaugeRewards.queueRewardsForCycle()`or `FlywheelGaugeRewards.queueRewardsForCyclePaginated()`, but, once the reactivated gauge is passed to `_queueRewards()`, it will fail an assert: \r\n\n**code-flywheel-v2/src/rewards/FlywheelGaugeRewards.sol:L196**\n```solidity\nassert(queuedRewards.storedCycle == 0 || queuedRewards.storedCycle >= lastCycle);\n```\nThis is because it already has a set value from the cycle it was processed in previously (i.e. `storedCycle>0`), and, since that cycle is at least 1 full cycle behind the state contract, it will also not pass the second condition `queuedRewards.storedCycle >= lastCycle`.\r\n\r\nThe result is that this gauge is locked out of queuing up for rewards because `queuedRewards.storedCycle` is only synchronised with the contract's cycle later in `_queueRewards()` which will now always fail for this gauge.\r\n\r\n\r\n#### Recommendation\r\nAccount for the reactivated gauges that previously went through the rewards queue process, such as introducing a separate flow for newly activated gauges. However, any changes such as removing the above mentioned `assert()` should be carefully validated for other downstream logic that may use the `QueuedRewards.storedCycle` value. Therefore, it is recommended to review the state transitions as opposed to only passing this specific check.",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Lack of input validation in `delegateBySig`",
    "severity": "minor",
    "body": "#### Description\r\nERC20MultiVotes.sol makes use of `ecrecover()` in `delegateBySig` to return the address of the message signer. `ecrecover()` typically returns address(0x0) to indicate an error; however, there's no zero address check in the function logic. This might not be exploitable though, as `delegate(0x0, arbitraryAddress)` might always return zero votes (in freeVotes). Additionally, `ecrecover()` can be forced to return a random address by messing with the parameters. Although this is extremely rare and will likely resolve to zero free votes most times, this might return a random address and delegate someone else's votes.\r\n#### Examples\r\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L364-L387**\n```solidity\nfunction delegateBySig(\n    address delegatee,\n    uint256 nonce,\n    uint256 expiry,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n) public {\n    require(block.timestamp <= expiry, \"ERC20MultiVotes: signature expired\");\n    address signer = ecrecover(\n        keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR(),\n                keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry))\n            )\n        ),\n        v,\n        r,\n        s\n    );\n    require(nonce == nonces[signer]++, \"ERC20MultiVotes: invalid nonce\");\n    _delegate(signer, delegatee);\n}\n```\n<!--\r\nCode URLs get formatted nicely, i.e. Vulnerable.sol#L27-L33\r\n-->\r\n\r\n#### Recommendation\r\nIntroduce a zero address check i.e `require signer!=address(0)` and check if the recovered signer is an expected address. Refer to [ERC20's permit](https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol#L154) for inspiration.\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Decreasing maxGauges does not account for users' previous gauge list size.",
    "severity": "minor",
    "body": "#### Description\r\n`ERC20Gauges` contract has a `maxGauges` state variable meant to represent the maximum amount of gauges a user can allocate to. As per the natspec, it is meant to protect against gas DOS attacks upon token transfer to allow complicated transactions to fit in a block. There is also a function `setMaxGauges` for authorised users to decrease or increase this state variable.\r\n\n**code-flywheel-v2/src/token/ERC20Gauges.sol:L499-L504**\n```solidity\nfunction setMaxGauges(uint256 newMax) external requiresAuth {\n    uint256 oldMax = maxGauges;\n    maxGauges = newMax;\n\n    emit MaxGaugesUpdate(oldMax, newMax);\n}\n```\n\r\nHowever, if it is decreased and there are users that have already reached the previous maximum that was larger, there may be unexpected behavior. All of these users' gauges will remain active and manageable, such as have user gauge weights incremented or decremented. So it could be possible that for such a user address `user_address`, `numUserGauges(user_address) > maxGauges`. While in the current contract logic this does not cause issues, `maxGauges` is a public variable that may be used by other systems. If unaccounted for, this discrepancy between the contract's `maxGauges` and the users' actual number of gauges given by `numUserGauges()` could, for example, cause gauges to be skipped or fail loops bounded by `maxGauges` in other systems' logic that try and go through all user gauges.\r\n\r\n#### Recommendation\r\nEither document the potential discrepancy between the user gauges size and the `maxGauges` state variable, or limit `maxGauges` to be only called within the contract thereby forcing other contracts to retrieve user gauge list size through `numUserGauges()`.\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Decrementing a gauge by 0 that is not in the user gauge list will fail an assert.",
    "severity": "minor",
    "body": "#### Description\r\n`ERC20Gauges._decrementGaugeWeight` has an edge case scenario where a user can attempt to decrement a `gauge` that is not in the user gauge list by 0 `weight`, which would trigger a failure in an assert. \r\n\n**code-flywheel-v2/src/token/ERC20Gauges.sol:L333-L345**\n```solidity\nfunction _decrementGaugeWeight(\n    address user,\n    address gauge,\n    uint112 weight,\n    uint32 cycle\n) internal {\n    uint112 oldWeight = getUserGaugeWeight[user][gauge];\n\n    getUserGaugeWeight[user][gauge] = oldWeight - weight;\n    if (oldWeight == weight) {\n        // If removing all weight, remove gauge from user list.\n        assert(_userGauges[user].remove(gauge));\n    }\n```\n\r\nAs `_decrementGaugeWeight`, `decrementGauge`, or `decrementGauges` don't explicitly check that a `gauge` belongs to the user, the contract logic continues with its operations in `_decrementGaugeWeight` for any gauges passed to it. In general this is fine because if a user tries to decrement non-zero `weight` from a `gauge` they have no allocation to, thus getting `getUserGaugeWeight[user][gauge]=0`,  there would be a revert due to a negative value being passed to `getUserGaugeWeight[user][gauge]`\r\n\n**code-flywheel-v2/src/token/ERC20Gauges.sol:L339-L341**\n```solidity\nuint112 oldWeight = getUserGaugeWeight[user][gauge];\n\ngetUserGaugeWeight[user][gauge] = oldWeight - weight;\n```\nHowever, passing a `weight=0` parameter with a `gauge` that doesn’t belong to the user, would successfully process that line. This would then be followed by an evaluation `if (oldWeight == weight)`, which would also succeed since both are 0, to finally reach an assert that will verify a remove of that `gauge` from the user gauge list. However, it will fail since it was never there in the first place.\r\n\n**code-flywheel-v2/src/token/ERC20Gauges.sol:L344**\n```solidity\nassert(_userGauges[user].remove(gauge));\n```\nAlthough an edge case with no effect on contract state's health, it may happen with front end bugs or incorrect user transactions, and it is best not to have asserts fail.\r\n#### Recommendation\r\n\r\nReplace `assert()` with a `require()` or verify that the gauge belongs to the user prior to performing any operations.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "Undelegating 0 votes from an address who is not a delegate of a user will fail an assert.",
    "severity": "minor",
    "body": "#### Description\r\nSimilar scenario with 7.\r\n`ERC20MultiVotes._undelegate` has an edge case scenario where a user can attempt to undelegate from a `delegatee` that is not in the user delegates list by 0 `amount`, which would trigger a failure in an assert. \r\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L251-L260**\n```solidity\nfunction _undelegate(\n    address delegator,\n    address delegatee,\n    uint256 amount\n) internal virtual {\n    uint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n\n    if (newDelegates == 0) {\n        assert(_delegates[delegator].remove(delegatee)); // Should never fail.\n    }\n```\n\r\nAs `_undelegate`, or `undelegate` don't explicitly check that a `delegatee` belongs to the user, the contract logic continues with its operations in `_undelegate` for the `delegatee` passed to it. In general this is fine because if a user tries to undelegate non-zero `amount` from a `delegatee` they have no votes delegated to, thus getting `_delegatesVotesCount[delegator][delegatee]=0`,  there would be a revert due to a negative value being passed to `uint256 newDelegates`\r\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L256**\n```solidity\nuint256 newDelegates = _delegatesVotesCount[delegator][delegatee] - amount;\n```\nHowever, passing a `amount=0` parameter with a `delegatee` that doesn’t belong to the user, would successfully process that line. This would then be followed by an evaluation `if (newDelegates == 0)`, which would succeed, to finally reach an assert that will verify a remove of that `delegatee` from the user delegates list. However, it will fail since it was never there in the first place.\r\n\n**code-flywheel-v2/src/token/ERC20MultiVotes.sol:L259**\n```solidity\nassert(_delegates[delegator].remove(delegatee)); // Should never fail.\n```\nAlthough an edge case with no effect on contract state's health, it may happen with front end bugs or incorrect user transactions, and it is best not to have asserts fail, as per the dev comment in that line \"// Should never fail\".\r\n#### Recommendation\r\n\r\nReplace `assert()` with a `require()` or verify that the delegatee belongs to the user prior to performing any operations.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "repo": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/",
      "url": "https://consensys.net//diligence/audits/2022/04/tribe-dao-flywheel-v2-xtribe-xerc4626/"
    }
  },
  {
    "title": "The `Hypervisor.deposit` function does not check the `msg.sender`",
    "severity": "critical",
    "body": "#### Description\r\n`Hypervisor.deposit` pulls pre-approved ERC20 tokens from the `from` address to the contract. Later it mints shares to the `to` address. Attackers can determine both the `from` and `to` addresses as they wish, and thus steal shares (that can be redeemed to tokens immediately) from users that pre-approved the contract to spend ERC20 tokens on their behalf.\r\n\r\n#### Recommendation\r\nAs described in 10, we recommend restricting access to this function only for `UniProxy`. Moreover, the `UniProxy` contract should validate that `from == msg.sender`.",
    "dataSource": {
      "name": "/diligence/audits/2022/02/gamma/",
      "repo": "https://consensys.net//diligence/audits/2022/02/gamma/",
      "url": "https://consensys.net//diligence/audits/2022/02/gamma/"
    }
  },
  {
    "title": "`UniProxy` - `SafeERC20` is declared but safe functions are not used",
    "severity": "major",
    "body": "#### Description\r\nThe `UniProxy` contract declares the usage of the `SafeERC20` library for functions of the `IERC20` type. However, unsafe functions are used instead of safe ones.\r\n\r\n#### Examples\r\n* Usage of `approve` instead of `safeApprove`\r\n* Usage of `transferFrom` instead of `safeTransferFrom`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/02/gamma/",
      "repo": "https://consensys.net//diligence/audits/2022/02/gamma/",
      "url": "https://consensys.net//diligence/audits/2022/02/gamma/"
    }
  },
  {
    "title": "Initialization flaws",
    "severity": "minor",
    "body": "#### Description\r\n\r\nFor non-upgradeable contracts, the Solidity compiler takes care of chaining the constructor calls of an inheritance hierarchy in the right order; for upgradeable contracts, taking care of initialization is a manual task – and with extensive use of inheritance, it is tedious and error-prone.\r\nThe convention in [OpenZeppelin Contracts Upgradeable]( https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable) is to have a `__C_init_unchained` function that contains the actual initialization logic for contract `C` and a `__C_init` function that calls the `*_init_unchained` function for every super-contract – direct and indirect – in the inheritance hierarchy (including `C`) in the C3-linearized order from most basic to most derived. This pattern imitates what the compiler does for constructors.\r\n\r\nAll `*_init` functions in the contracts (`__ERC20WrapperGluwacoin_init`, `__ERC20Reservable_init`, `__ERC20ETHless_init`, and `__ERC20Wrapper_init`) are missing some `_init_unchained` calls, and sometimes the existing calls are not in the correct order.\r\n\r\n#### Examples\r\n\r\nThe `__ERC20WrapperGluwacoin_init` function is implemented as follows:\r\n\r\n\n**code/contracts/ERC20WrapperGluwacoin.sol:L36-L48**\n```solidity\nfunction __ERC20WrapperGluwacoin_init(\n    string memory name,\n    string memory symbol,\n    IERC20 token\n) internal initializer {\n    __Context_init_unchained();\n    __ERC20_init_unchained(name, symbol);\n    __ERC20ETHless_init_unchained();\n    __ERC20Reservable_init_unchained();\n    __AccessControlEnumerable_init_unchained();\n    __ERC20Wrapper_init_unchained(token);\n    __ERC20WrapperGluwacoin_init_unchained();\n}\n```\n\r\nAnd the C3 linearization is:\r\n\r\n```\r\nERC20WrapperGluwacoin\r\n  ↖ ERC20Reservable\r\n  ↖ ERC20ETHless\r\n  ↖ ERC20Wrapper\r\n  ↖ ERC20Upgradeable\r\n  ↖ IERC20MetadataUpgradeable\r\n  ↖ IERC20Upgradeable\r\n  ↖ AccessControlEnumerableUpgradeable\r\n  ↖ AccessControlUpgradeable\r\n  ↖ ERC165Upgradeable\r\n  ↖ IERC165Upgradeable\r\n  ↖ IAccessControlEnumerableUpgradeable\r\n  ↖ IAccessControlUpgradeable\r\n  ↖ ContextUpgradeable\r\n  ↖ Initializable\r\n```\r\n\r\nThe calls `__ERC165_init_unchained();` and `__AccessControl_init_unchained();` are missing, and `__ERC20Wrapper_init_unchained(token);` should move between `__ERC20_init_unchained(name, symbol);` and `__ERC20ETHless_init_unchained();`.\r\n\r\n#### Recommendation\r\n\r\nReview all `*_init` functions, add the missing `*_init_unchained` calls, and fix the order of these calls.",
    "dataSource": {
      "name": "/diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "repo": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "url": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/"
    }
  },
  {
    "title": "Flaw in `_beforeTokenTransfer` call chain and missing tests",
    "severity": "minor",
    "body": "#### Description\r\n\r\nIn OpenZeppelin's ERC-20 implementation, the virtual `_beforeTokenTransfer` function provides a hook that is called before tokens are transferred, minted, or burned. In the Gluwacoin codebase, it is used to check whether the _unreserved_ balance (as opposed to the regular balance, which is checked by the ERC-20 implementation) of the sender is sufficient to allow this transfer or burning.\r\n \r\nIn `ERC20WrapperGluwacoin`, `ERC20Reservable`, and `ERC20Wrapper`, the `_beforeTokenTransfer` function is implemented in the following way:\r\n\r\n\n**code/contracts/ERC20WrapperGluwacoin.sol:L54-L61**\n```solidity\nfunction _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n) internal override(ERC20Upgradeable, ERC20Wrapper, ERC20Reservable) {\n    ERC20Wrapper._beforeTokenTransfer(from, to, amount);\n    ERC20Reservable._beforeTokenTransfer(from, to, amount);\n}\n```\n\r\n\n**code/contracts/abstracts/ERC20Reservable.sol:L156-L162**\n```solidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override (ERC20Upgradeable) {\n    if (from != address(0)) {\n        require(_unreservedBalance(from) >= amount, \"ERC20Reservable: transfer amount exceeds unreserved balance\");\n    }\n\n    super._beforeTokenTransfer(from, to, amount);\n}\n```\n\r\n\n**code/contracts/abstracts/ERC20Wrapper.sol:L176-L178**\n```solidity\nfunction _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override (ERC20Upgradeable) {\n    super._beforeTokenTransfer(from, to, amount);\n}\n```\n\r\nFinally, the C3-linearization of the contracts is:\r\n```\r\nERC20WrapperGluwacoin\r\n  ↖ ERC20Reservable\r\n  ↖ ERC20ETHless\r\n  ↖ ERC20Wrapper\r\n  ↖ ERC20Upgradeable\r\n  ↖ IERC20MetadataUpgradeable\r\n  ↖ IERC20Upgradeable\r\n  ↖ AccessControlEnumerableUpgradeable\r\n  ↖ AccessControlUpgradeable\r\n  ↖ ERC165Upgradeable\r\n  ↖ IERC165Upgradeable\r\n  ↖ IAccessControlEnumerableUpgradeable\r\n  ↖ IAccessControlUpgradeable\r\n  ↖ ContextUpgradeable\r\n  ↖ Initializable\r\n```\r\n\r\nThis means `ERC20Wrapper._beforeTokenTransfer` is ultimately called twice – once directly in `ERC20WrapperGluwacoin._beforeTokenTransfer` and then a second time because the `super._beforeTokenTransfer` call in `ERC20Reservable._beforeTokenTransfer` resolves to `ERC20Wrapper._beforeTokenTransfer`. (`ERC20ETHless` doesn't override `_beforeTokenTransfer`.) \r\n\r\nMoreover, while reviewing the correctness and coverage of the tests is not in scope for this engagement, we happened to notice that there are no tests that check whether the unreserved balance is sufficient for transferring or burning tokens.\r\n\r\n#### Recommendation\r\n\r\n`ERC20WrapperGluwacoin._beforeTokenTransfer` should just call `super._beforeTokenTransfer`. Moreover, the `_beforeTokenTransfer` implementation can be removed from `ERC20Wrapper`.\r\n\r\nWe would like to stress the importance of careful and comprehensive testing in general and of this functionality in particular, as it is crucial for the system's integrity. We also encourage investigating whether there are more such omissions and an evaluation of the test quality and coverage in general.",
    "dataSource": {
      "name": "/diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "repo": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "url": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/"
    }
  },
  {
    "title": "Hard-coded decimals",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe Gluwacoin wrapper token should have the same number of decimals as the wrapped ERC-20. Currently, the number of decimals is hard-coded to 6. This limits flexibility or requires source code changes and recompilation if a token with a different number of decimals is to be wrapped.\r\n\r\n\n**code/contracts/ERC20WrapperGluwacoin.sol:L32-L34**\n```solidity\nfunction decimals() public pure override returns (uint8) {\n    return 6;\n}\n```\n\r\n#### Recommendation\r\n\r\nWe recommend supplying the number of decimals as an initialization parameter and storing it in a state variable. That increases gas consumption of the `decimals` function, but we doubt this view function will be frequently called from a contract, and even if it was, we think the benefits far outweigh the costs.\\\r\nMoreover, we believe the decimals logic (i.e., function `decimals` and the new state variable) should be implemented in the `ERC20Wrapper` contract – which holds the basic ERC-20 functionality of the wrapper token – and not in `ERC20WrapperGluwacoin`, which is the base contract of the entire system.",
    "dataSource": {
      "name": "/diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "repo": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/",
      "url": "https://consensys.net//diligence/audits/2021/10/gluwacoin-erc-20-wrapper/"
    }
  },
  {
    "title": "Update Natspec",
    "severity": null,
    "body": "\r\n#### Examples\r\n\r\n* `token` is not in natspec\r\n\r\n\n**code/contracts/pcv/utils/ERC20Splitter.sol:L6-L28**\n```solidity\n/// @notice a contract to split token held to multiple locations\ncontract ERC20Splitter is PCVSplitter {\n\n    /// @notice token to split\n    IERC20 public token;\n\n    /**\n        @notice constructor for ERC20Splitter\n        @param _core the Core address to reference\n        @param _pcvDeposits the locations to send tokens\n        @param _ratios the relative ratios of how much tokens to send each location, in basis points\n    */\n    constructor(\n        address _core,\n        IERC20 _token,\n        address[] memory _pcvDeposits,\n        uint256[] memory _ratios\n    ) \n        CoreRef(_core)\n        PCVSplitter(_pcvDeposits, _ratios)\n    {\n        token = _token;\n    }\n```\n",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "TribeReserveStabilizer - different minting procedures",
    "severity": null,
    "body": "#### Description\r\n\r\nThe TRIBE token doesn't have a burn functionality. TRIBE that is supposed to be taken out of circulation is sent to the `TribeReserveStabilizer` contract, and when that contract has to mint new TRIBE in exchange for FEI, it will first use up the currently held TRIBE balance before actually minting new tokens.\r\n\r\n\n**code/contracts/stabilizer/TribeReserveStabilizer.sol:L117-L133**\n```solidity\n// Transfer held TRIBE first, then mint to cover remainder\nfunction _transfer(address to, uint256 amount) internal override {\n    _depleteBuffer(amount);\n    uint256 _tribeBalance = balance();\n    uint256 mintAmount = amount;\n    if(_tribeBalance != 0) {\n        uint256 transferAmount = Math.min(_tribeBalance, amount);\n\n        _withdrawERC20(address(token), to, transferAmount);\n\n        mintAmount = mintAmount - transferAmount;\n        assert(mintAmount + transferAmount == amount);\n    }\n    if (mintAmount != 0) {\n        _mint(to, mintAmount);\n    }\n}\n```\n\r\nThe contract also has a `mint` function that allows the Governor to mint new TRIBE. Unlike the `exchangeFei` function described above, this function does not first utilize TRIBE held in the contract but directly instructs the token contract to mint the entire amount.\r\n\r\n\n**code/contracts/stabilizer/TribeReserveStabilizer.sol:L102-L107**\n```solidity\n/// @notice mints TRIBE to the target address\n/// @param to the address to send TRIBE to\n/// @param amount the amount of TRIBE to send\nfunction mint(address to, uint256 amount) external override onlyGovernor {\n    _mint(to, amount);\n}\n```\n\n**code/contracts/stabilizer/TribeReserveStabilizer.sol:L135-L138**\n```solidity\nfunction _mint(address to, uint256 amount) internal {\n    ITribe _tribe = ITribe(address(token));\n    _tribe.mint(to, amount);\n}\n```\n\r\n#### Recommendation\r\n\r\nIt would make sense and be more consistent with `exchangeFei` if the `mint` function first used TRIBE held in the contract before actually minting new tokens.",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "StableSwapOperatorV1 - `resistantFei` value is not correct in the `resistantBalanceAndFei` function",
    "severity": "major",
    "body": "#### Description\r\n\r\nThe `resistantBalanceAndFei` function of a `PCVDeposit` contract is supposed to return the amount of funds that the contract controls; it is then used to evaluate the total value of PCV (collateral in the protocol). Additionally, this function returns the number of FEI tokens that are protocol-controlled. These FEI tokens are \"temporarily minted\"; they are not backed up by the collateral and shouldn't be used in calculations that determine the collateralization of the protocol.\r\n\r\nIdeally, the amount of these FEI tokens should be the same during the deposit, withdrawal, and the `resistantBalanceAndFei` function call. In the `StableSwapOperatorV1 ` contract, all these values are totally different:\r\n\r\n* during the deposit, the amount of required FEI tokens is calculated. It's done in a way so the values of FEI and 3pool tokens in the metapool should be equal after the deposit. So if there is the initial imbalance of FEI and 3pool tokens, the deposit value of these tokens will be different: \r\n\n   **code/contracts/pcv/curve/StableSwapOperatorV1.sol:L156-L171**\n   ```solidity\n   // get the amount of tokens in the pool\n   (uint256 _3crvAmount, uint256 _feiAmount) = (\n       IStableSwap2(pool).balances(_3crvIndex),\n       IStableSwap2(pool).balances(_feiIndex)\n   );\n   // ... and the expected amount of 3crv in it after deposit\n   uint256 _3crvAmountAfter = _3crvAmount + _3crvBalanceAfter;\n   \n   // get the usd value of 3crv in the pool\n   uint256 _3crvUsdValue = _3crvAmountAfter * IStableSwap3(_3pool).get_virtual_price() / 1e18;\n   \n   // compute the number of FEI to deposit\n   uint256 _feiToDeposit = 0;\n   if (_3crvUsdValue > _feiAmount) {\n       _feiToDeposit = _3crvUsdValue - _feiAmount;\n   }\n   ```\n* during the withdrawal, the FEI and 3pool tokens are withdrawn in the same proportion as they are present in the metapool: \r\n\n   **code/contracts/pcv/curve/StableSwapOperatorV1.sol:L255-L258**\n   ```solidity\n   uint256[2] memory _minAmounts; // [0, 0]\n   IERC20(pool).approve(pool, _lpToWithdraw);\n   uint256 _3crvBalanceBefore = IERC20(_3crv).balanceOf(address(this));\n   IStableSwap2(pool).remove_liquidity(_lpToWithdraw, _minAmounts);\n   ```\n* in the `resistantBalanceAndFei` function, the value of protocol-controlled FEI tokens and the value of 3pool tokens deposited are considered equal: \r\n\n   **code/contracts/pcv/curve/StableSwapOperatorV1.sol:L348-L349**\n   ```solidity\n   resistantBalance = _lpPriceUSD / 2;\n   resistantFei = resistantBalance;\n   ```\n\r\nSome of these values may be equal under some circumstances, but that is not enforced. After one of the steps (deposit or withdrawal), the total PCV value and collateralization may be changed significantly.\r\n\r\n#### Recommendation\r\n\r\nMake sure that deposit, withdrawal, and the `resistantBalanceAndFei` are consistent and won't instantly change the PCV value significantly. ",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "StableSwapOperatorV1 - the `_minLpOut` value is not accurate",
    "severity": "medium",
    "body": "#### Description\r\n\r\nWhen depositing, the expected minimum amount of the output LP tokens is calculated:\r\n\r\n\n**code/contracts/pcv/curve/StableSwapOperatorV1.sol:L194-L200**\n```solidity\n// slippage check on metapool deposit\nuint256 _balanceDeposited = IERC20(pool).balanceOf(address(this)) - _balanceBefore;\n{\n    uint256 _metapoolVirtualPrice = IStableSwap2(pool).get_virtual_price();\n    uint256 _minLpOut = (_feiToDeposit + _3crvBalanceAfter) * 1e18 / _metapoolVirtualPrice * (Constants.BASIS_POINTS_GRANULARITY - depositMaxSlippageBasisPoints) / Constants.BASIS_POINTS_GRANULARITY;\n    require(_balanceDeposited >= _minLpOut, \"StableSwapOperatorV1: metapool deposit slippage too high\");\n}\n```\n\r\nThe problem is that the `get_virtual_price` function returns a valid price only if the tokens in the pool are expected to have a price equal to $1 which is not the case. Also, the balances of deposited FEI and 3pool lp tokens are just added to each other while they have a different price: `_feiToDeposit + _3crvBalanceAfter`.\r\n\r\nThe price of the 3pool lp tokens is currently very close to 1$ so this difference is not that visible at the moment, but this can slowly change over time.\r\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "BalancerLBPSwapper - init() can be front-run to potentially steal tokens",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe deployment process for `BalancerLBPSwapper` appears to be the following:\r\n\r\n1. deploy `BalancerLBPSwapper`.\r\n2. run `ILiquidityBootstrappingPoolFactory.create()` proving the newly deployed swapper address as the owner of the pool.\r\n3. initialize `BalancerLBPSwapper.init()` with the address of the newly created pool.\r\n\r\nThis process may be split across multiple transactions as in the `v2Phase1.js` deployment scenario.\r\n\r\nBetween step (1) and (3) there is a window of opportunity for someone to maliciously initialize contract. This should be easily detectable because calling `init()` twice should revert the second transaction. If this is not caught in the deployment script this may have more severe security implications. Otherwise, this window can be used to grief the deployment initializing it before the original initializer does forcing them to redeploy the contract or to steal any `tokenSpent`/`tokenReceived` that are owned by the contract at this time.\r\n\r\nNote: It is assumed that the contract will not own a lot of tokens right after deployment rendering the scenario of stealing tokens more unlikely. However, that highly depends on the deployment script for the contract system. \r\n\r\n#### Examples\r\n\r\n\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L107-L117**\n```solidity\nfunction init(IWeightedPool _pool) external {\n    require(address(pool) == address(0), \"BalancerLBPSwapper: initialized\");\n\n    pool = _pool;\n    IVault _vault = _pool.getVault();\n\n    vault = _vault;\n\n    // Check ownership\n    require(_pool.getOwner() == address(this), \"BalancerLBPSwapper: contract not pool owner\");\n\n```\n\r\n\n**code/contracts/pcv/balancer/BalancerLBPSwapper.sol:L159-L160**\n```solidity\nIERC20(tokenSpent).approve(address(_vault), type(uint256).max);\nIERC20(tokenReceived).approve(address(_vault), type(uint256).max);\n```\n\r\n#### Recommendation\r\n\r\nprotect `BalancerLBPSwapper.init()` and only allow a trusted entity (e.g. the initial deployer) to call this method.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "The `BalancerLBPSwapper` may not have enough `Tribe` tokens",
    "severity": "minor",
    "body": "#### Description\r\n\r\nWhenever the `swap` function is called, it should re-initialize the Balancer pool that requires adding liquidity: 99% Fei and 1% Tribe. So the Tribe should initially be in the contract. \r\n\r\n\n**code_new/contracts/pcv/balancer/BalancerLBPSwapper.sol:L313-L325**\n```solidity\nfunction _getTokensIn(uint256 spentTokenBalance) internal view returns(uint256[] memory amountsIn) {\n    amountsIn = new uint256[](2);\n\n    uint256 receivedTokenBalance = readOracle().mul(spentTokenBalance).mul(ONE_PERCENT).div(NINETY_NINE_PERCENT).asUint256();\n\n    if (address(assets[0]) == tokenSpent) {\n        amountsIn[0] = spentTokenBalance;\n        amountsIn[1] = receivedTokenBalance;\n    } else {\n        amountsIn[0] = receivedTokenBalance;\n        amountsIn[1] = spentTokenBalance;\n    }\n}\n```\n\r\nAdditionally, when the `swap` is called, and there is not enough FEI to re-initiate the Balancer auction, all the Tribe gets withdrawn. So the next time the `swap` is called, there is no Tribe in the contract again.\r\n\r\n\n**code_new/contracts/pcv/balancer/BalancerLBPSwapper.sol:L248-L249**\n```solidity\n// 5. Send remaining tokenReceived to target\nIERC20(tokenReceived).transfer(tokenReceivingAddress, IERC20(tokenReceived).balanceOf(address(this)));\n```\n\r\n#### Recommendation\r\n\r\nCreate an automated mechanism that mints/transfers Tribe when it is needed in the swapper contract.",
    "dataSource": {
      "name": "/diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "repo": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/",
      "url": "https://consensys.net//diligence/audits/2021/09/fei-protocol-v2-phase-1/"
    }
  },
  {
    "title": "Presence of testnet code ",
    "severity": "medium",
    "body": "#### Description\r\nBased on the discussions with pStake team and in-line comments, there are a few instances of code and commented code in the code base under audit that are not finalized for mainnet deployment.\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/PSTAKE.sol:L25-L37**\n```solidity\nfunction initialize(address pauserAddress) public virtual initializer {\n\t__ERC20_init(\"pSTAKE Token\", \"PSTAKE\");\n\t__AccessControl_init();\n\t__Pausable_init();\n\t_setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\n\t_setupRole(PAUSER_ROLE, pauserAddress);\n\t// PSTAKE IS A SIMPLE ERC20 TOKEN HENCE 18 DECIMAL PLACES\n\t_setupDecimals(18);\n\t// pre-allocate some tokens to an admin address which will air drop PSTAKE tokens\n\t// to each of holder contracts. This is only for testnet purpose. in Mainnet, we\n\t// will use a vesting contract to allocate tokens to admin in a certain schedule\n\t_mint(_msgSender(), 5000000000000000000000000);\n}\n```\n\r\nThe initialize function currently mints all the tokens to msg.sender, however the goal for mainnet is to use a vesting contract which is not present in the current code.\r\n\r\n#### Recommendation\r\n\r\nIt is recommended to fully test the **final** code before deployment to the mainnet. \r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/08/pstake-finance/",
      "repo": "https://consensys.net//diligence/audits/2021/08/pstake-finance/",
      "url": "https://consensys.net//diligence/audits/2021/08/pstake-finance/"
    }
  },
  {
    "title": "FulfillInterpreter - Wrong order of actions in fallback handling",
    "severity": "minor",
    "body": "#### Description\r\n\r\nWhen a transaction with a `callTo` that is not `address(0)` is fulfilled, the funds to be withdrawn on the user's behalf are first transferred to the `FulfillInterpreter` instance that is associated with this `TransactionManager` instance. After that, `execute` is called on that interpreter instance, which, in turn, tries to make a call to `callTo`. If that call reverts or isn't made in the first place because `callTo` is not a contract address, the funds are transferred directly to the `receivingAddress` in the transaction (which becomes `fallbackAddress` in `execute`); otherwise, it's the called contract's task to transfer the previously approved funds from the interpreter.\r\n\r\n\n**code2/packages/contracts/contracts/interpreters/FulfillInterpreter.sol:L68-L90**\n```solidity\nbool isNative = LibAsset.isNativeAsset(assetId);\nif (!isNative) {\n  LibAsset.increaseERC20Allowance(assetId, callTo, amount);\n}\n\n// Check if the callTo is a contract\nbool success;\nbytes memory returnData;\nif (Address.isContract(callTo)) {\n  // Try to execute the callData\n  // the low level call will return `false` if its execution reverts\n  (success, returnData) = callTo.call{value: isNative ? amount : 0}(callData);\n}\n\n// Handle failure cases\nif (!success) {\n  // If it fails, transfer to fallback\n  LibAsset.transferAsset(assetId, fallbackAddress, amount);\n  // Decrease allowance\n  if (!isNative) {\n    LibAsset.decreaseERC20Allowance(assetId, callTo, amount);\n  }\n}\n```\n \r\nFor the fallback scenario, i.e., the call isn't executed or fails, the funds are first transferred to `fallbackAddress`, and the previously increased allowance is decreased after that. If the token supports it, the recipient of the direct transfer could try to exploit that the approval hasn't been revoked yet, so the logically correct order is to decrease the allowance first and transfer the funds later.\r\nHowever, it should be noted that the `FulfillInterpreter` should, at any point in time, only hold the funds that are supposed to be transferred as part of the current transaction; if there are any excess funds, these are leftovers from a previous failure to withdraw everything that could have been withdrawn, so these can be considered up for grabs. Hence, this is only a minor issue.\r\n\r\n#### Recommendation\r\n\r\nWe recommend reversing the order of actions for the fallback case: Decrease the allowance first, and transfer later. Moreover, it would be better to increase the allowance only in case a call will actually be made, i.e., if `Address.isContract(callTo)` is `true`.\r\n\r\n#### Remark\r\n\r\nThis issue was already present in the original version of the code but was missed initially and only found during the re-audit.",
    "dataSource": {
      "name": "/diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "repo": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "url": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/"
    }
  },
  {
    "title": "FulfillInterpreter - Missing check whether `callTo` address contains code",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe receiver-side `prepare` checks whether the `callTo` address is either zero or a contract:\r\n\n**code/packages/contracts/contracts/TransactionManager.sol:L466-L470**\n```solidity\n// Check that the callTo is a contract\n// NOTE: This cannot happen on the sending chain (different chain \n// contexts), so a user could mistakenly create a transfer that must be\n// cancelled if this is incorrect\nrequire(invariantData.callTo == address(0) || Address.isContract(invariantData.callTo), \"#P:031\");\n```\nHowever, as a contract may `selfdestruct` and the check is not repeated later, there is no guarantee that `callTo` still contains code when the call to this address (assuming it is non-zero) is actually executed in `FulfillInterpreter.execute`:\r\n\n**code/packages/contracts/contracts/interpreters/FulfillInterpreter.sol:L71-L82**\n```solidity\n// Try to execute the callData\n// the low level call will return `false` if its execution reverts\n(bool success, bytes memory returnData) = callTo.call{value: isEther ? amount : 0}(callData);\n\nif (!success) {\n  // If it fails, transfer to fallback\n  Asset.transferAsset(assetId, fallbackAddress, amount);\n  // Decrease allowance\n  if (!isEther) {\n    Asset.decreaseERC20Allowance(assetId, callTo, amount);\n  }\n}\n```\nAs a result, if the contract at `callTo` self-destructs between `prepare` and `fulfill` (both on the receiving chain), `success` will be `true`, and the funds will probably be lost to the user.\r\n\r\nA user could currently try to avoid this by checking that the contract still exists before calling `fulfill` on the receiving chain, but even then, they might get front-run by `selfdestruct`, and the situation is even worse with a relayer, so this provides no reliable protection.\r\n\r\n#### Recommendation\r\n\r\nRepeat the `Address.isContract` check on `callTo` before making the external call in `FulfillInterpreter.execute` and send the funds to the `fallbackAddress` if the result is `false`.\r\n\r\nIt is, perhaps, debatable whether the check in `prepare` should be kept or removed. In principle, if the contract gets deployed between `prepare` and `fulfill`, that is still soon enough. However, if the `callTo` address doesn't have code at the time of `prepare`, this seems more likely to be a mistake than a \"late deployment\". So unless there is a demonstrated use case for \"late deployments\", failing in `prepare` (even though it's receiver-side) might still be the better choice.\r\n\r\n#### Remark\r\n\r\nIt should be noted that an unsuccessful call, i.e., a revert, is the only behavior that is recognized by `FulfillInterpreter.execute` as failure. While it is prevalent to indicate failure by reverting, this doesn't _have to_ be the case; a well-known example is an ERC20 token that indicates a failing transfer by returning `false`.\\\r\nA user who wants to utilize this feature has to make sure that the called contract behaves accordingly; if that is not the case, an intermediary contract may be employed, which, for example, reverts for return value `false`.",
    "dataSource": {
      "name": "/diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "repo": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "url": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/"
    }
  },
  {
    "title": "Router - handling of native assetID (`0x000..00`, e.g. `ETH`) not implemented",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`Contract.ts` does not implement the native Asset (`0x000...000`; `ETH`). Transaction value is hardcoded to zero. `approveTokensIfNeeded` will likely fail as it will attempt to contract call `0x0` and there is inconsistent use of default values (`0` vs BigInt `const.Zero`).\r\n\r\nAdditionally, `handleSenderPrepare` does not manage approvals for `ERC20` transfers.\r\n\r\n#### Examples\r\n\r\n* harcoded zero amount\r\n\r\n\n**code/packages/router/src/contract.ts:L137-L147**\n```solidity\nreturn ResultAsync.fromPromise(\n  this.txService.sendTx(\n    {\n      to: this.config.chainConfig[chainId].transactionManagerAddress,\n      data: encodedData,\n      value: constants.Zero,\n      chainId,\n      from: this.signerAddress,\n    },\n    requestContext,\n  ),\n```\n\r\n\n**code/packages/router/src/contract.ts:L206-L215**\n```solidity\nthis.txService.sendTx(\n  {\n    chainId,\n    data: fulfillData,\n    to: nxtpContractAddress,\n    value: 0,\n    from: this.signerAddress,\n  },\n  requestContext,\n),\n```\n\r\n* `approveTokensIfNeeded` will fail when using native assets\r\n\r\n\n**code/packages/sdk/src/transactionManager.ts:L329-L333**\n```solidity\n).andThen((signerAddress) => {\n  const erc20 = new Contract(\n    assetId,\n    ERC20.abi,\n    this.signer.provider ? this.signer : this.signer.connect(config.provider),\n```\n\r\n#### Recommendation\r\n\r\nRemove complexity by requiring ERC20 compliant wrapped native assets (e.g.`WETH` instead of native `ETH`).\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "repo": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/",
      "url": "https://consensys.net//diligence/audits/2021/07/connext-nxtp-noncustodial-xchain-transfer-protocol/"
    }
  },
  {
    "title": "EthCompoundPCVDeposit - should provide means to recover `ETH` ",
    "severity": "medium",
    "body": "#### Description\r\n\r\n`EthCompoundPCVDeposit` accepts `ETH` via `receive()`. Anyone can call  `EthCompoundPCVDeposit.deposit()` to mint `CToken` for the contracts `ETH` balance.  \r\n\r\nThe `CToken` to be used is configured on `EthCompoundPCVDeposit` deployment. It is not checked, whether the provided `CToken` address is actually a valid `CToken`.\r\n\r\nIf the configured `CToken` ceases to work correctly (e.g.  `CToken.mint|redeem*` disabled or the configured `CToken` address is invalid), `ETH` held by the contract may be locked up.\r\n\r\n\r\n#### Recommendation\r\n\r\nSimilar to `EthLidoPCVDeposit` add a method `witdrawETH`, access-restricted to `onlyPCVController`, that allows recovering `ETH` from the `EthCompoundPCVDeposit` contract in case the `CToken` contract throws. (Consider moving this functionality to `PCVDeposit` where `withdrawERC20` is implemented to avoid having to implement this over and over again)\r\n\r\nIn `CompoundPCVDepositBase` consider verifying, that the `CToken` constructor argument is actually a valid `CToken` by checking `require(ctoken.isCToken(), \"not a valid CToken\")`.",
    "dataSource": {
      "name": "/diligence/audits/2021/07/fei-tribechief/",
      "repo": "https://consensys.net//diligence/audits/2021/07/fei-tribechief/",
      "url": "https://consensys.net//diligence/audits/2021/07/fei-tribechief/"
    }
  },
  {
    "title": "TribalChief - duplicate import SafeERC20",
    "severity": "minor",
    "body": "#### Description\r\n\r\nDuplicate import for SafeERC20. \r\n\r\n#### Examples\r\n\r\n\n**code/contracts/staking/TribalChief.sol:L7-L8**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n```\n\r\n#### Recommendation\r\n\r\nRemove duplicate import line.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/07/fei-tribechief/",
      "repo": "https://consensys.net//diligence/audits/2021/07/fei-tribechief/",
      "url": "https://consensys.net//diligence/audits/2021/07/fei-tribechief/"
    }
  },
  {
    "title": "Clearly communicate admin capabilities",
    "severity": null,
    "body": "#### Description\r\n\r\nWith the exception of the internally-deployed `IdleCDOTranche` contracts, all of the contracts reviewed are intended to be used via delegatecall proxy. This allows the contract `owner` to upgrade to an arbitrary implementation at any time, potentially even front-running user calls to a contract with a change to the semantics of particular methods.\r\n\r\nAdditionally, the `IdleCDO` contract includes a function `transferTokens()` that allows the contract `owner` to withdraw any and all tokens held by the contract to the `governanceRecoveryFund` address.\r\n\r\n\n**code/contracts/GuardedLaunchUpgradable.sol:L54-L59**\n```solidity\n/// @notice Emergency method, tokens gets transferred to the governanceRecoveryFund address\n/// @param _token address of the token to transfer\n/// @param _value amount to transfer\nfunction transferToken(address _token, uint256 _value) external onlyOwner nonReentrant {\n  IERC20Upgradeable(_token).safeTransfer(governanceRecoveryFund, _value);\n}\n```\n\r\nFurther more, functionalities that can halt the system such as `emergencyShutdown` and Pausable contracts should be mentioned in a visible disclaimer. \r\n\r\n#### Recommendation\r\n\r\nClearly communicate to users the trust model of the system, and use timelocked multisig contracts for controlling admin privileges.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/06/idle-finance/",
      "repo": "https://consensys.net//diligence/audits/2021/06/idle-finance/",
      "url": "https://consensys.net//diligence/audits/2021/06/idle-finance/"
    }
  },
  {
    "title": "`IdleCDO._deposit()` allows re-entrancy from hookable tokens.",
    "severity": "medium",
    "body": "#### Description\r\nThe function `IdleCDO._deposit()` updates the system's internal accounting and mints shares to the caller, then transfers the deposited funds from the user. Some token standards, such as ERC777, allow a callback to the source of the funds before the balances are updated in `transferFrom()`. This callback could be used to re-enter the protocol while already holding the minted tranche tokens and at a point where the system accounting reflects a receipt of funds that has not yet occurred.\r\n\r\nWhile an attacker could not interact with `IdleCDO.withdraw()` within this callback because of the `_checkSameTx()` restriction, they would be able to interact with the rest of the protocol.\r\n\r\n\n**code/contracts/IdleCDO.sol:L230-L245**\n```solidity\nfunction _deposit(uint256 _amount, address _tranche) internal returns (uint256 _minted) {\n  // check that we are not depositing more than the contract available limit\n  _guarded(_amount);\n  // set _lastCallerBlock hash\n  _updateCallerBlock();\n  // check if strategyPrice decreased\n  _checkDefault();\n  // interest accrued since last depositXX/withdrawXX/harvest is splitted between AA and BB\n  // according to trancheAPRSplitRatio. NAVs of AA and BB are updated and tranche\n  // prices adjusted accordingly\n  _updateAccounting();\n  // mint tranche tokens according to the current tranche price\n  _minted = _mintShares(_amount, msg.sender, _tranche);\n  // get underlyings from sender\n  IERC20Detailed(token).safeTransferFrom(msg.sender, address(this), _amount);\n}\n```\n\r\n#### Recommendation\r\n\r\nMove the `transferFrom()` action in `_deposit()` to immediately after `_updateCallerBlock()`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/06/idle-finance/",
      "repo": "https://consensys.net//diligence/audits/2021/06/idle-finance/",
      "url": "https://consensys.net//diligence/audits/2021/06/idle-finance/"
    }
  },
  {
    "title": "`IdleCDO.harvest()` allows price manipulation in certain circumstances",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe function `IdleCDO.harvest()` uses Uniswap to liquidate rewards earned by the contract's strategy, then updates the relevant positions and internal accounting. This function can only be called by the contract `owner` or the designated `rebalancer` address, and it accepts an array which indicates the minimum buy amounts for the liquidation of each reward token.\r\n\r\nThe purpose of permissioning this method and specifying minimum buy amounts is to prevent a sandwiching attack from manipulating the reserves of the Uniswap pools and forcing the `IdleCDO` contract to incur loss due to price slippage.\r\n\r\nHowever, this does not effectively prevent price manipulation in all cases. Because the contract sells it's entire balance of redeemed rewards for the specified minimum buy amount, this approach does not enforce a minimum *price* for the executed trades. If the balance of `IdleCDO` or the amount of claimable rewards increases between the submission of the `harvest()` transaction and its execution, it may be possible to perform a profitable sandwiching attack while still satisfying the required minimum buy amounts.\r\n\r\nThe viability of this exploit depends on how effectively an attacker can increase the amount of rewards tokens to be sold without incurring an offsetting loss. The strategy contracts used by `IdleCDO` are expected to vary widely in their implementations, and this manipulation could potentially be done either through direct interaction with the protocol or as part of a flashbots bundle containing a large position adjustment from an honest user.\r\n\r\n\n**code/contracts/IdleCDO.sol:L564-L565**\n```solidity\nfunction harvest(bool _skipRedeem, bool _skipIncentivesUpdate, bool[] calldata _skipReward, uint256[] calldata _minAmount) external {\n  require(msg.sender == rebalancer || msg.sender == owner(), \"IDLE:!AUTH\");\n```\n\r\n\n**code/contracts/IdleCDO.sol:L590-L599**\n```solidity\n// approve the uniswap router to spend our reward\nIERC20Detailed(rewardToken).safeIncreaseAllowance(address(_uniRouter), _currentBalance);\n// do the uniswap trade\n_uniRouter.swapExactTokensForTokensSupportingFeeOnTransferTokens(\n  _currentBalance,\n  _minAmount[i],\n  _path,\n  address(this),\n  block.timestamp + 1\n);\n```\n\r\n#### Recommendation\r\n\r\nUpdate `IdleCDO.harvest()` to enforce a minimum price rather than a minimum buy amount. One method of doing so would be taking an additional array parameter indicating the amount of each token to sell in exchange for the respective buy amount.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/06/idle-finance/",
      "repo": "https://consensys.net//diligence/audits/2021/06/idle-finance/",
      "url": "https://consensys.net//diligence/audits/2021/06/idle-finance/"
    }
  },
  {
    "title": "Simplify the `harvest` method in each SinglePlus",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe `BadgerSBTCCrvPlus` single plus contract implements a custom `harvest` method.\r\n\r\n\n**code/BTC-Plus/contracts/single/eth/BadgerSBTCCrv%2B.sol:L52-L56**\n```solidity\n/**\n * @dev Harvest additional yield from the investment.\n * Only governance or strategist can call this function.\n */\nfunction harvest(address[] calldata _tokens, uint256[] calldata _cumulativeAmounts, uint256 _index, uint256 _cycle,\n```\n\r\nThis method can only be called by the strategist because of the `onlyStrategist` modifier.\r\n\r\nThis method has a few steps which take one asset and transform it into another asset a few times.\r\n\r\nIt first claims the Badger tokens:\r\n\r\n\n**code/BTC-Plus/contracts/single/eth/BadgerSBTCCrv%2B.sol:L58-L59**\n```solidity\n// 1. Harvest from Badger Tree\nIBadgerTree(BADGER_TREE).claim(_tokens, _cumulativeAmounts, _index, _cycle, _merkleProof, _amountsToClaim);\n```\n\r\nThen it transforms the Badger tokens into WBTC using Uniswap.\r\n\r\n\n**code/BTC-Plus/contracts/single/eth/BadgerSBTCCrv%2B.sol:L61-L72**\n```solidity\n// 2. Sushi: Badger --> WBTC\nuint256 _badger = IERC20Upgradeable(BADGER).balanceOf(address(this));\nif (_badger > 0) {\n    IERC20Upgradeable(BADGER).safeApprove(SUSHISWAP, 0);\n    IERC20Upgradeable(BADGER).safeApprove(SUSHISWAP, _badger);\n\n    address[] memory _path = new address[](2);\n    _path[0] = BADGER;\n    _path[1] = WBTC;\n\n    IUniswapRouter(SUSHISWAP).swapExactTokensForTokens(_badger, uint256(0), _path, address(this), block.timestamp.add(1800));\n}\n```\n\r\nThis step can be simplified in two ways.\r\n\r\nFirst, the `safeApprove` method isn't useful because its usage is not recommended anymore.\r\n\r\nThe OpenZeppelin version 4 implementation states the method is deprecated and its usage is discouraged.\r\n\r\n\n**contracts/token/ERC20/utils/SafeERC20Upgradeable.sol:L29-L30**\n```solidity\n* @dev Deprecated. This function has issues similar to the ones found in\n* {IERC20-approve}, and its usage is discouraged.\n```\n\r\n```solidity\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n```\r\n\r\nThus, the `SafeERC20Upgradeable.sol` is not needed anymore and the import can be removed.\r\n\r\nAnother step is swapping the tokens on Uniswap.\r\n\r\n\n**code/BTC-Plus/contracts/single/eth/BadgerSBTCCrv%2B.sol:L71**\n```solidity\nIUniswapRouter(SUSHISWAP).swapExactTokensForTokens(_badger, uint256(0), _path, address(this), block.timestamp.add(1800));\n```\n\r\nIn this case, the last argument `block.timestamp.add(1800)` is the deadline. This is useful when the transaction is sent to the network and a deadline is needed to expire the transaction. However, the execution is right now and there's no need for a future expiration date.\r\n\r\nRemoving the safe math addition will have the same end effect, the tokens will be swapped and the call is not at risk to expire.\r\n\r\n#### Recommendation\r\n\r\nRemove `safeApprove` and favor using `approve`. This also removes the need of having `SafeERC20Upgradeable.sol` included.\r\n\r\nDo not use safe math when sending the expiration date. Use `block.timestamp` for the same effect and a reduced gas cost.\r\n\r\nApply the same principles for other Single Plus Tokens.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/nuts-finance-btcplus/",
      "repo": "https://consensys.net//diligence/audits/2021/05/nuts-finance-btcplus/",
      "url": "https://consensys.net//diligence/audits/2021/05/nuts-finance-btcplus/"
    }
  },
  {
    "title": "zAuction - hardcoded ropsten token address",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe auction contract hardcodes the [WETH ERC20](https://ropsten.etherscan.io/address/0xc778417e063141139fce010982780140aa0cd5ab) token address. this address will not be functional when deploying to mainnet.\r\n\r\n#### Examples\r\n\r\n\n**zAuction/contracts/zAuction.sol:L15-L16**\n```solidity\n    IERC20 weth = IERC20(address(0xc778417E063141139Fce010982780140Aa0cD5Ab)); // rinkeby weth\r\n\r\n```\n\r\n#### Recommendation\r\n\r\nConsider taking the used `WETH` token address as a constructor argument. Avoid code changes to facilitate testing! Perform input validation on arguments rejecting `address(0x0)` to facilitate the detection of potential misconfiguration in the deployment pipeline. \r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zauction/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zauction/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zauction/"
    }
  },
  {
    "title": "zBanc - Potential gas optimizations",
    "severity": null,
    "body": "#### Description\r\n`DynamicLiquidTokenConverter.reduceWeight`\r\n\r\n1. Calling `reserveBalance` to fetch the reserve balance for a given reserveToken might be redundant, as the value has already been fetched, and resides in the `reserve` local variable.\r\n2. Function visibility can be changed to `external` instead of `public`.\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L130-L150**\n```solidity\n    function reduceWeight(IERC20Token _reserveToken)\r\n        public\r\n        validReserve(_reserveToken)\r\n        ownerOnly\r\n    {\r\n        _protected();\r\n        uint256 currentMarketCap = getMarketCap(_reserveToken);\r\n        require(currentMarketCap > (lastWeightAdjustmentMarketCap.add(marketCapThreshold)), \"ERR_MARKET_CAP_BELOW_THRESHOLD\");\r\n\r\n        Reserve storage reserve = reserves[_reserveToken];\r\n        uint256 newWeight = uint256(reserve.weight).sub(stepWeight);\r\n        uint32 oldWeight = reserve.weight;\r\n        require(newWeight >= minimumWeight, \"ERR_INVALID_RESERVE_WEIGHT\");\r\n\r\n        uint256 percentage = uint256(PPM_RESOLUTION).sub(newWeight.mul(PPM_RESOLUTION).div(reserve.weight));\r\n\r\n        uint32 weight = uint32(newWeight);\r\n        reserve.weight = weight;\r\n        reserveRatio = weight;\r\n\r\n        uint256 balance = reserveBalance(_reserveToken).mul(percentage).div(PPM_RESOLUTION);\r\n```\n\r\n* `ConverterUpgrader.upgradeOld` - Redundant casting of `_converter`.\r\n\r\n\n**zBanc/solidity/contracts/converter/ConverterUpgrader.sol:L96-L99**\n```solidity\nfunction upgradeOld(DynamicLiquidTokenConverter _converter, bytes32 _version) public {\r\n    _version;\r\n    DynamicLiquidTokenConverter converter = DynamicLiquidTokenConverter(_converter);\r\n    address prevOwner = converter.owner();\r\n```",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zbanc/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/"
    }
  },
  {
    "title": "zBanc - DynamicLiquidTokenConverter ineffective reentrancy protection",
    "severity": "major",
    "body": "#### Description\r\n\r\n`reduceWeight` calls `_protected()` in an attempt to protect from reentrant calls but this check is insufficient as it will only check for the `locked` statevar but never set it. A potential for direct reentrancy might be present when an erc-777 token is used as reserve.\r\n\r\nIt is assumed that the developer actually wanted to use the `protected` modifier that sets the lock before continuing with the method.\r\n\r\n#### Examples\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L123-L128**\n```solidity\nfunction reduceWeight(IERC20Token _reserveToken)\r\n    public\r\n    validReserve(_reserveToken)\r\n    ownerOnly\r\n{\r\n    _protected();\r\n```\n\r\n```solidity\r\ncontract ReentrancyGuard {\r\n    // true while protected code is being executed, false otherwise\r\n    bool private locked = false;\r\n\r\n    /**\r\n      * @dev ensures instantiation only by sub-contracts\r\n    */\r\n    constructor() internal {}\r\n\r\n    // protects a function against reentrancy attacks\r\n    modifier protected() {\r\n        _protected();\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    // error message binary size optimization\r\n    function _protected() internal view {\r\n        require(!locked, \"ERR_REENTRANCY\");\r\n    }\r\n}\r\n```\r\n\r\n#### Recommendation\r\n\r\nTo mitigate potential attack vectors from reentrant calls remove the call to `_protected()` and decorate the function with `protected` instead. This will properly set the lock before executing the function body rejecting reentrant calls.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zbanc/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/"
    }
  },
  {
    "title": "zBanc - DynamicLiquidTokenConverter `isActive` should only be returned if converter is fully configured and converter parameters should only be updateable while converter is inactive",
    "severity": "medium",
    "body": "#### Description\r\n\r\nBy default, a converter is `active` once the anchor ownership was transferred. This is true for converters that do not require to be properly set up with additional parameters before they can be used.\r\n\r\n\n**zBanc/solidity/contracts/converter/ConverterBase.sol:L272-L279**\n```solidity\n/**\r\n  * @dev returns true if the converter is active, false otherwise\r\n  *\r\n  * @return true if the converter is active, false otherwise\r\n*/\r\nfunction isActive() public view virtual override returns (bool) {\r\n    return anchor.owner() == address(this);\r\n}\r\n```\n\r\nFor a simple converter, this might be sufficient. If a converter requires additional setup steps (e.g. setting certain internal variables, an oracle, limits, etc.) it should return `inactive` until the setup completes. This is to avoid that users are interacting with (or even pot. frontrunning) a partially configured converter as this may have unexpected outcomes.\r\n\r\nFor example, the `LiquidityPoolV2Converter` overrides the `isActive` method to require additional variables be set (`oracle`) to actually be in `active` state. \r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2Converter.sol:L79-L85**\n```solidity\n  * @dev returns true if the converter is active, false otherwise\r\n  *\r\n  * @return true if the converter is active, false otherwise\r\n*/\r\nfunction isActive() public view override returns (bool) {\r\n    return super.isActive() && address(priceOracle) != address(0);\r\n}\r\n```\n\r\nAdditionally, settings can only be updated while the contract is `inactive` which will be the case during an upgrade. This ensures that the `owner` cannot adjust settings at will for an active contract.\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquidity-pool-v2/LiquidityPoolV2Converter.sol:L97-L109**\n```solidity\nfunction activate(\r\n    IERC20Token _primaryReserveToken,\r\n    IChainlinkPriceOracle _primaryReserveOracle,\r\n    IChainlinkPriceOracle _secondaryReserveOracle)\r\n    public\r\n    inactive\r\n    ownerOnly\r\n    validReserve(_primaryReserveToken)\r\n    notThis(address(_primaryReserveOracle))\r\n    notThis(address(_secondaryReserveOracle))\r\n    validAddress(address(_primaryReserveOracle))\r\n    validAddress(address(_secondaryReserveOracle))\r\n{\r\n```\n\r\nThe `DynamicLiquidTokenConverter` is following a different approach. It inherits the default `isActive` which sets the contract active right after anchor ownership is transferred. This kind of breaks the upgrade process for `DynamicLiquidTokenConverter` as settings cannot be updated while the contract is active (as anchor ownership might be transferred before updating values). To unbreak this behavior a new authentication modifier was added, that allows updates for the upgrade contradict **while the contract is active**. Now this is a behavior that should be avoided as settings should be predictable while a contract is active. Instead it would make more sense initially set all the custom settings of the converter to zero (uninitialized) and require them to be set and only the return the contract as active. The behavior basically mirrors the upgrade process of `LiquidityPoolV2Converter`.\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L44-L50**\n```solidity\n\r\n    modifier ifActiveOnlyUpgrader(){\r\n      if(isActive()){\r\n        require(owner == addressOf(CONVERTER_UPGRADER), \"ERR_ACTIVE_NOTUPGRADER\");\r\n      }\r\n      _;\r\n    }\r\n```\n\r\nPre initialized variables should be avoided. The marketcap threshold can only be set by the calling entity as it may be very different depending on the type of reserve (eth, token).\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L17-L20**\n```solidity\nuint32 public minimumWeight = 30000;\r\nuint32 public stepWeight = 10000;\r\nuint256 public marketCapThreshold = 10000 ether;\r\nuint256 public lastWeightAdjustmentMarketCap = 0;\r\n```\n\r\nHere's one of the setter functions that can be called while the contract is active (only by the upgrader contract but changing the ACL commonly followed with other converters).\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L67-L74**\n```solidity\nfunction setMarketCapThreshold(uint256 _marketCapThreshold)\r\n    public\r\n    ownerOnly\r\n    ifActiveOnlyUpgrader\r\n{\r\n    marketCapThreshold = _marketCapThreshold;\r\n    emit MarketCapThresholdUpdated(_marketCapThreshold);\r\n}\r\n```\n\r\n#### Recommendation\r\n\r\nAlign the upgrade process as much as possible to how `LiquidityPoolV2Converter` performs it. Comply with the bancor API.\r\n \r\n* override `isActive` and require the contracts main variables to be set.\r\n* do not pre initialize the contracts settings to \"some\" values. Require them to be set by the caller (and perform input validation)\r\n* mirror the upgrade process of `LiquidityPoolV2Converter` and instead of `activate` call the setter functions that set the variables. After setting the last var and anchor ownership been transferred, the contract should return active.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zbanc/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/"
    }
  },
  {
    "title": "zBanc - DynamicLiquidTokenConverter frontrunner can grief owner when calling reduceWeight",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe owner of the converter is allowed to reduce the converters weights once the marketcap surpasses a configured threshhold. The thresshold is configured on first deployment. The marketcap at the beginning of the call is calculated as `reserveBalance / reserve.weight` and stored as `lastWeightAdjustmentMarketCap` after reducing the weight.\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L130-L138**\n```solidity\n    function reduceWeight(IERC20Token _reserveToken)\r\n        public\r\n        validReserve(_reserveToken)\r\n        ownerOnly\r\n    {\r\n        _protected();\r\n        uint256 currentMarketCap = getMarketCap(_reserveToken);\r\n        require(currentMarketCap > (lastWeightAdjustmentMarketCap.add(marketCapThreshold)), \"ERR_MARKET_CAP_BELOW_THRESHOLD\");\r\n\r\n```\n\r\nThe reserveBalance can be manipulated by buying (adding reserve token) or selling liquidity tokens (removing reserve token). The success of a call to `reduceWeight` is highly dependant on the marketcap. A malicious actor may, therefore, attempt to grief calls made by the owner by sandwiching them with `buy` and sell `calls` in an attempt to (a) raise the barrier for the next valid payout marketcap or (b) temporarily lower the marketcap if they are a major token holder in an attempt to fail the `reduceWeights` call. \r\n\r\nIn both cases the griefer may incur some losses due to conversion errors, bancor fees if they are set, and gas spent. It is, therefore, unlikely that a third party may spend funds on these kinds of activities. However, the owner as a potential major liquid token holder may use this to their own benefit by artificially lowering the marketcap to the absolute minimum (old+threshold) by selling liquidity and buying it back right after reducing weights. \r\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zbanc/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/"
    }
  },
  {
    "title": "zBanc - DynamicLiquidTokenConverter consider using PPM_RESOLUTION instead of hardcoding integer literals",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`getMarketCap` calculates the reserve's market capitalization as `reserveBalance  * 1e6 /  weight` where `1e6` should be expressed as the constant `PPM_RESOLUTION`.\r\n\r\n#### Examples\r\n\r\n\n**zBanc/solidity/contracts/converter/types/liquid-token/DynamicLiquidTokenConverter.sol:L157-L164**\n```solidity\nfunction getMarketCap(IERC20Token _reserveToken)\r\n    public\r\n    view\r\n    returns(uint256)\r\n{\r\n    Reserve storage reserve = reserves[_reserveToken];\r\n    return reserveBalance(_reserveToken).mul(1e6).div(reserve.weight);\r\n}\r\n```\n\r\n#### Recommendation\r\n\r\nAvoid hardcoding integer literals directly into source code when there is a better expression available. In this case `1e6` is used because weights are denoted in percent to base `PPM_RESOLUTION` (`=100%`).",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zbanc/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zbanc/"
    }
  },
  {
    "title": "zDAO Token - reject calls that have no effect - zero value transfers",
    "severity": null,
    "body": "#### Description\r\n\r\nConsider returning or bailing early for calls that have no effect on the system, like if the total amount transferred is zero (empty recipients, zero amount). Consider rejecting transfers to the contract address to avoid tokens getting stuck.\r\n\r\n\n**zDAO-Token/contracts/ZeroDAOToken.sol:L68-L78**\n```solidity\nfunction transferBulk(address[] calldata recipients, uint256 amount)\n  external\n  returns (bool)\n{\n  address sender = _msgSender();\n\n  uint256 total = amount * recipients.length;\n  require(\n    _balances[sender] >= total,\n    \"ERC20: transfer amount exceeds balance\"\n  );\n```",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zdao-token/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/"
    }
  },
  {
    "title": "zDAO Token - check contract state before wasting gas on calculations",
    "severity": null,
    "body": "#### Description\r\n\r\nConsider checking if a contract is paused as the first thing in the function to avoid unnecessarily wasting gas on calculations for a call that will always fail (if the contract is paused).\r\n\r\n\n**zDAO-Token/contracts/ZeroDAOToken.sol:L80-L81**\n```solidity\nrequire(!paused(), \"ERC20Pausable: token transfer while paused\");\n\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zdao-token/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/"
    }
  },
  {
    "title": "zDAO Token - Specification violation - Snapshots are never taken",
    "severity": "major",
    "body": "#### Description\r\n\r\nAccording to the [zDAO Token specification](https://github.com/zer0-os/zDAO-Token/blob/a053e1d7314ed62bccfc70a5110ef2dd5546deec/docs/zdaotoken.md#balance-snapshotting) the DAO token should implement a snapshot functionality to allow it being used for DAO governance votings.\r\n\r\n> Any transfer, mint, or burn operation should result in a snapshot of the token balances of involved users being taken.\r\n\r\nWhile the corresponding functionality is implemented and appears to update balances for snapshots, `_snapshot()` is never called, therefore, the snapshot is never taken. e.g. attempting to call `balanceOfAt` always results in an error as no snapshot is available.\r\n\r\n\n**zDAO-Token/contracts/ZeroDAOToken.sol:L12-L17**\n```solidity\ncontract ZeroDAOToken is\n  OwnableUpgradeable,\n  ERC20Upgradeable,\n  ERC20PausableUpgradeable,\n  ERC20SnapshotUpgradeable\n{\n```\n\r\n\n**zDAO-Token/contracts/ZeroDAOToken.sol:L83-L83**\n```solidity\n_updateAccountSnapshot(sender);\n```\n\r\nNote that this is an explicit requirement as per specification but unit tests do not seem to attempt calls to `balanceOfAt` at all.\r\n\r\n#### Recommendation\r\n\r\nActually, take a snapshot by calling `_snapshot()` once per block when executing the first transaction in a new block. Follow the openzeppeling documentation for [ERC20Snapshot](https://docs.openzeppelin.com/contracts/3.x/api/token/erc20#ERC20Snapshot).\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/05/zer0-zdao-token/",
      "repo": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/",
      "url": "https://consensys.net//diligence/audits/2021/05/zer0-zdao-token/"
    }
  },
  {
    "title": "Where possible, a specific contract type should be used rather than `address`",
    "severity": null,
    "body": "#### Description\r\n\r\nConsider using the best type available in the function arguments and even declaration instead of accepting `address` and later casting it to the correct type.\r\n\r\n#### Examples\r\n\r\nThis is only one of many examples. The method accepts `address` type arguments while this could already be declared as `RocketStorageInterface _rocketStorageAddress`. \r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/minipool/RocketMinipool.sol:L71-L77**\n```solidity\nconstructor(address _rocketStorageAddress, address _nodeAddress, MinipoolDeposit _depositType) {\n    // Check parameters\n    require(_rocketStorageAddress != address(0x0), \"Invalid storage address\");\n    require(_nodeAddress != address(0x0), \"Invalid node address\");\n    require(_depositType != MinipoolDeposit.None, \"Invalid deposit type\");\n    // Initialise RocketStorage\n    rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n```\n\r\n`_tokenAddress` can be declared as `IERC20` in arguments and events.\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketVault.sol:L82-L82**\n```solidity\nIERC20 tokenContract = IERC20(_tokenAddress);\n```\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketVault.sol:L26-L27**\n```solidity\nevent TokenDeposited(bytes32 indexed by, address indexed tokenAddress, uint256 amount, uint256 time);\nevent TokenWithdrawn(bytes32 indexed by, address indexed tokenAddress, uint256 amount, uint256 time);\n```\n\r\n`RocketStorageInterface` can be declared in the argument list.\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketBase.sol:L76-L80**\n```solidity\n/// @dev Set the main Rocket Storage address\nconstructor(address _rocketStorageAddress) {\n    // Update the contract address\n    rocketStorage = RocketStorageInterface(_rocketStorageAddress);\n}\n```\n\r\n`RocketMinipool` cast to address while it is used as `RocketMinipool` contract by the caller creating the contract.\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/minipool/RocketMinipoolFactory.sol:L20-L25**\n```solidity\nfunction createMinipool(address _nodeAddress, MinipoolDeposit _depositType) override external onlyLatestContract(\"rocketMinipoolFactory\", address(this)) onlyLatestContract(\"rocketMinipoolManager\", msg.sender) returns (address) {\n    // Create RocketMinipool contract\n    address contractAddress = address(new RocketMinipool(address(rocketStorage), _nodeAddress, _depositType));\n    // Return\n    return contractAddress;\n}\n```\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/node/RocketNodeDeposit.sol:L65-L66**\n```solidity\naddress minipoolAddress = rocketMinipoolManager.createMinipool(msg.sender, depositType);\nRocketMinipoolInterface minipool = RocketMinipoolInterface(minipoolAddress);\n```\n\r\nPass the `minipool` contract type instead of `address` to the subcall:\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/minipool/RocketMinipoolStatus.sol:L64-L64**\n```solidity\nsetMinipoolWithdrawable(_minipoolAddress, _stakingStartBalance, _stakingEndBalance);\n```",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "RocketVault - Follow checks-effects-interactions for token withdrawal",
    "severity": null,
    "body": "#### Description\r\n\r\n`withdrawToken` breaks checks-effects-interactions by calling `token.transfer` before updating the internal accounting.\r\n\r\nThis may only be problematic when calling out callback tokens (e.g., ERC-777) tokens or when withdrawing from an unsafe `_tokenAddress` (which should never happen).\r\n\r\nIt is recommended to update the internal account first (analog to `withdrawEth`) and then call out to the potentially untrusted token or token callback receiver.\r\n\r\n#### Examples\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketVault.sol:L101-L116**\n```solidity\nfunction withdrawToken(address _withdrawalAddress, address _tokenAddress, uint256 _amount) override external onlyLatestNetworkContract returns (bool) {\n    // Get contract key\n    bytes32 contractKey = keccak256(abi.encodePacked(getContractName(msg.sender), _tokenAddress));\n    // Get the token ERC20 instance\n    IERC20 tokenContract = IERC20(_tokenAddress);\n    // Verify this contract has that amount of tokens at a minimum\n    require(tokenContract.balanceOf(address(this)) >= _amount, \"Insufficient contract token balance\");\n    // Withdraw to the desired address\n    require(tokenContract.transfer(_withdrawalAddress, _amount), \"Rocket Vault token withdrawal unsuccessful\");\n    // Update balances\n    tokenBalances[contractKey] = tokenBalances[contractKey].sub(_amount);\n    // Emit token withdrawn event\n    emit TokenWithdrawn(contractKey, _tokenAddress, _amount, block.timestamp);\n    // Done\n    return true;\n}\n```\n\r\n\r\n`RocketNodeStaking`: \r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/node/RocketNodeStaking.sol:L172-L175**\n```solidity\nrocketVault.withdrawToken(msg.sender, getContractAddress(\"rocketTokenRPL\"), _amount);\n// Update RPL stake amounts\ndecreaseTotalRPLStake(_amount);\ndecreaseNodeRPLStake(msg.sender, _amount);\n```\n",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "RocketVault - Consider using SafeERC for third party ERC20 interactions or whitelist allowed tokens",
    "severity": null,
    "body": "#### Description\r\n\r\nSafeERC20 provides a wrapper around ERC20 standard function calls that handles common deviations from ERC20, like missing return values. For example, the vault implementation relies on the `transfer*` functions to return `true` or fail. Well-known but broken ERC20 tokens (USDT, BNB, OMG, ...) might therefore not be safely used with the system. \r\n\r\nAnyone can deposit any token right now. This shouldn't be a problem as long as the system isn't using them. If the vault is not meant to be used with unauthorized tokens, it should be considered to implement a token whitelist.\r\n\r\nIt should be noted that forcefully sent ETH or tokens cannot be reclaimed via the contract.\r\n\r\n#### Examples\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketVault.sol:L90-L91**\n```solidity\nrequire(tokenContract.transferFrom(msg.sender, address(this), _amount), \"Token transfer was not successful\");\n// Update contract balance\n```\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/RocketVault.sol:L108-L110**\n```solidity\n// Withdraw to the desired address\nrequire(tokenContract.transfer(_withdrawalAddress, _amount), \"Rocket Vault token withdrawal unsuccessful\");\n// Update balances\n```\n",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "Casting to the contracts own contract type and address can be avoided by calling `this.<function>`",
    "severity": null,
    "body": "#### Recommendation\r\n\r\nInstead of casting to `IERC20(self)` to force an external call to a contract function from its own address (`msg.sender`) this could be changed to call `this.transfer()` as the `this` keyword forces an external call. Ideally, with a short explanation of why the call needs to come from the contract address (this is already the case with the current code revision)\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/token/RocketTokenRPL.sol:L202-L205**\n```solidity\n// Initialise itself and send from it's own balance (cant just do a transfer as it's a user calling this so they are msg.sender)\nIERC20 rplInflationContract = IERC20(address(this));\n// Transfer from the contracts RPL balance to the user\nrequire(rplInflationContract.transfer(msg.sender, _amount), \"Token transfer from RPL inflation contract was not successful\");\n```\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/token/RocketTokenRPL.sol:L169-L176**\n```solidity\n// Initialise itself and allow from it's own balance (cant just do an allow as it could be any user calling this so they are msg.sender)\nIERC20 rplInflationContract = IERC20(address(this));\n// This is to prevent an allowance reentry style attack\nuint256 vaultAllowance = 0;\n// Get the current allowance for Rocket Vault\nvaultAllowance = rplFixedSupplyContract.allowance(rocketVaultAddress, address(this));\n// Now allow Rocket Vault to move those tokens, we also need to account of any other allowances for this token from other contracts in the same block\nrequire(rplInflationContract.approve(rocketVaultAddress, vaultAllowance.add(newTokens)), \"Allowance for Rocket Vault could not be approved\");\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "Avoid shadowing inherited names",
    "severity": null,
    "body": "#### Recommendation\r\n\r\n`allowance` shadows inherited name `IERC20.allowance()`. Consider renaming the local var `allowance` to not overlap with any inherited name.\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/token/RocketTokenRPL.sol:L197-L199**\n```solidity\nuint256 allowance = rplFixedSupplyContract.allowance(msg.sender, address(this));\n// Enough to cover it?\nrequire(allowance >= _amount, \"Not enough allowance given for transfer of tokens\");\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "RocketTokenRPL - inaccurate inflation rate and potential for manipulation lowering the real APY",
    "severity": "major",
    "body": "#### Description\r\n\r\nRocketTokenRPL allows users to swap their fixed-rate tokens to the inflationary RocketTokenRPL ERC20 token via a `swapToken` function. The DAO defines the inflation rate of this token and is initially set to be 5% APY. This APY is configured as a daily inflation rate (APD) with the corresponding `1 day in blocks` inflation interval in the `rocketDAOProtocolSettingsInflation` contract. The DAO members control the inflation settings.\r\n\r\nAnyone can call `inflationMintTokens` to inflate the token, which mints tokens to the contracts RocketVault. Tokens are minted for discreet intervals since the last time `inflationMintTokens` was called (recorded as `inflationCalcBlock`). The inflation is then calculated for the passed intervals without taking the current not yet completed interval. However, the `inflationCalcBlock` is set to the current `block.number`, effectively skipping some \"time\"/blocks of the APY calculation.\r\n\r\nThe more often `inflationMintTokens` is called, the higher the APY likelihood dropping below the configured 5%. In the worst case, one could manipulate the APY down to 2.45% (assuming that the APD for a 5% APY was configured) by calling `inflationMintTokens` close to the end of every second interval. This would essentially restart the APY interval at `block.number`, skipping blocks of the current interval that have not been accounted for.\r\n\r\nThe following diagram illustrates the skipped blocks due to the incorrect recording of `inflationCalcBlock` as `block.number`. The example assumes that we are in interval 4 but have not completed it. `3` APD intervals have passed, and this is what the inflation rate is based on. However, the `inflationCalcBlock` is updated to the current `block.number`, skipping some time/blocks that are now unaccounted in the APY restarting the 4th interval at `block.number`.\r\n\r\n![rocketpool_inflation](https://user-images.githubusercontent.com/2865694/113396900-85913780-939c-11eb-9b62-7c88df057b7b.png)\r\n\r\n* Note: updating the inflation rate will directly affect past inflation intervals that have not been minted! this might be undesirable, and it could be considered to force an inflation mint if the APY changes\r\n* Note: if the interval is small enough and there is a history of unaccounted intervals to be minted, and the Ethereum network is congested, gas fees may be high and block limits hit, the calculations in the for loop might be susceptible to DoS the inflation mechanism because of gas constraints.\r\n* Note: The inflation seems only to be triggered regularly on `RocketRewardsPool.claim` (or at any point by external actors). If the price establishes based on the total supply of tokens, then this may give attackers an opportunity to front-run other users trading large amounts of RPL that may previously have calculated their prices based on the un-inflated supply.\r\n* Note: that the discrete interval-based inflation (e.g., once a day) might create dynamics that put pressure on users to trade their RPL in windows instead of consecutively\r\n\r\n#### Examples\r\n\r\n* the inflation intervals passed is the number of completed intervals. The current interval that is started is not included.\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/token/RocketTokenRPL.sol:L108-L119**\n```solidity\nfunction getInlfationIntervalsPassed() override public view returns(uint256) {\n    // The block that inflation was last calculated at\n    uint256 inflationLastCalculatedBlock = getInflationCalcBlock();\n    // Get the daily inflation in blocks\n    uint256 inflationInterval = getInflationIntervalBlocks();\n    // Calculate now if inflation has begun\n    if(inflationLastCalculatedBlock > 0) {\n        return (block.number).sub(inflationLastCalculatedBlock).div(inflationInterval);\n    }else{\n        return 0;\n    }\n}\n```\n\r\n* the inflation calculation calculates the to-be-minted tokens for the inflation rate at `newTokens = supply * rateAPD^intervals - supply`\r\n\r\n\n**rocketpool-2.5-Tokenomics-updates/contracts/contract/token/RocketTokenRPL.sol:L126-L148**\n```solidity\nfunction inflationCalculate() override public view returns (uint256) {\n    // The inflation amount\n    uint256 inflationTokenAmount = 0;\n    // Optimisation\n    uint256 inflationRate = getInflationIntervalRate();\n    // Compute the number of inflation intervals elapsed since the last time we minted infation tokens\n    uint256 intervalsSinceLastMint = getInlfationIntervalsPassed();\n    // Only update  if last interval has passed and inflation rate is > 0\n    if(intervalsSinceLastMint > 0 && inflationRate > 0) {\n        // Our inflation rate\n        uint256 rate = inflationRate; \n        // Compute inflation for total inflation intervals elapsed\n        for (uint256 i = 1; i < intervalsSinceLastMint; i++) {\n            rate = rate.mul(inflationRate).div(10 ** 18);\n        }\n        // Get the total supply now \n        uint256 totalSupplyCurrent = totalSupply();\n        // Return inflation amount\n        inflationTokenAmount = totalSupplyCurrent.mul(rate).div(10 ** 18).sub(totalSupplyCurrent);\n    }\n    // Done\n    return inflationTokenAmount;\n}\n```\n\r\n#### Recommendation\r\n\r\nProperly track `inflationCalcBlock` as the end of the previous interval, as this is up to where the inflation was calculated, instead of the block at which the method was invoked.\r\n\r\nEnsure APY/APD and interval configuration match up. Ensure the interval is not too small (potential gas DoS blocking inflation mint and `RocketRewardsPool.claim`). ",
    "dataSource": {
      "name": "/diligence/audits/2021/04/rocketpool/",
      "repo": "https://consensys.net//diligence/audits/2021/04/rocketpool/",
      "url": "https://consensys.net//diligence/audits/2021/04/rocketpool/"
    }
  },
  {
    "title": "Winning pods can be frontrun with large deposits",
    "severity": "critical",
    "body": "#### Description\r\n\r\n`Pod.depositTo()` grants users shares of the pod pool in exchange for `tokenAmount` of `token`. \r\n\r\n\n**code/pods-v3-contracts/contracts/Pod.sol:L266-L288**\n```solidity\nfunction depositTo(address to, uint256 tokenAmount)\n    external\n    override\n    returns (uint256)\n{\n    require(tokenAmount > 0, \"Pod:invalid-amount\");\n\n    // Allocate Shares from Deposit To Amount\n    uint256 shares = _deposit(to, tokenAmount);\n\n    // Transfer Token Transfer Message Sender\n    IERC20Upgradeable(token).transferFrom(\n        msg.sender,\n        address(this),\n        tokenAmount\n    );\n\n    // Emit Deposited\n    emit Deposited(to, tokenAmount, shares);\n\n    // Return Shares Minted\n    return shares;\n}\n```\n\r\nThe winner of a prize pool is typically determined by an off-chain random number generator, which requires a request to first be made on-chain. The result of this RNG request can be seen in the mempool and frontrun. In this case, an attacker could identify a winning `Pod` contract and make a large deposit, diluting existing user shares and claiming the entire prize.\r\n\r\n#### Recommendation\r\n\r\nThe modifier `pauseDepositsDuringAwarding` is included in the `Pod` contract but is unused.\r\n\r\n\n**code/pods-v3-contracts/contracts/Pod.sol:L142-L148**\n```solidity\nmodifier pauseDepositsDuringAwarding() {\n    require(\n        !IPrizeStrategyMinimal(_prizePool.prizeStrategy()).isRngRequested(),\n        \"Cannot deposit while prize is being awarded\"\n    );\n    _;\n}\n```\n\r\nAdd this modifier to the `depositTo()` function along with corresponding test cases.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/pooltogether-pods/",
      "repo": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/",
      "url": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/"
    }
  },
  {
    "title": "`TokenDrop`: Unprotected `initialize()` function ",
    "severity": "critical",
    "body": "#### Description\r\n\r\nThe `TokenDrop.initialize()` function is unprotected and can be called multiple times.\r\n\r\n\n**code/pods-v3-contracts/contracts/TokenDrop.sol:L81-L87**\n```solidity\nfunction initialize(address _measure, address _asset) external {\n    measure = IERC20Upgradeable(_measure);\n    asset = IERC20Upgradeable(_asset);\n\n    // Set Factory Deployer\n    factory = msg.sender;\n}\n```\n\r\nAmong other attacks, this would allow an attacker to re-initialize any `TokenDrop` with the same `asset` and a malicious `measure` token. By manipulating the balance of a user in this malicious `measure` token, the entire `asset` token balance of the `TokenDrop` contract could be drained.\r\n\r\n#### Recommendation\r\n\r\nAdd the `initializer` modifier to the `initialize()` function and include an explicit test that *every* initialization function in the system can be called once and only once.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/pooltogether-pods/",
      "repo": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/",
      "url": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/"
    }
  },
  {
    "title": "Pod: Re-entrancy during deposit or withdrawal can lead to stealing funds",
    "severity": "critical",
    "body": "#### Description\r\n \r\nDuring the deposit, the token transfer is made after the Pod shares are minted:\r\n\r\n\n**code/pods-v3-contracts/contracts/Pod.sol:L274-L281**\n```solidity\nuint256 shares = _deposit(to, tokenAmount);\n\n// Transfer Token Transfer Message Sender\nIERC20Upgradeable(token).transferFrom(\n    msg.sender,\n    address(this),\n    tokenAmount\n);\n```\n\r\nThat means that if the `token` allows re-entrancy, the attacker can deposit one more time inside the token transfer. If that happens, the second call will mint more tokens than it is supposed to, because the first token transfer will still not be finished.\r\nBy doing so with big amounts, it's possible to drain the pod.\r\n\r\n#### Recommendation\r\n\r\nAdd re-entrancy guard to the external functions.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/pooltogether-pods/",
      "repo": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/",
      "url": "https://consensys.net//diligence/audits/2021/03/pooltogether-pods/"
    }
  },
  {
    "title": "Document potential edge cases for hook receiver contracts",
    "severity": null,
    "body": "#### Description\r\nThe functions `withdrawTokenAndCall()` and `withdrawTokenAndCallOnBehalf()` make a call to a hook contract designated by the owner of the withdrawing stealth address.\r\n\r\n\n**contracts/contracts/Umbra.sol:L289-L291**\n```solidity\nif (address(_hook) != address(0)) {\n  _hook.tokensWithdrawn(_withdrawalAmount, _stealthAddr, _acceptor, _tokenAddr, _sponsor, _sponsorFee, _data);\n}\n```\n\r\nThere are very few constraints on the parameters to these calls in the `Umbra` contract itself. Anyone can force a call to a hook contract by transferring a small amount of tokens to an address that they control and withdrawing these tokens, passing the target address as the hook receiver. Developers of these `UmbraHookReceiver` contracts should be sure to validate both the caller of the `tokensWithdrawn()` function and the function parameters. There are a number of possible edge cases that should be handled when relevant. These include, but are not limited to, the following:\r\n\r\n* The `_amount` may not have been transferred to the hook receiver itself.\r\n* All four addresses passed to `tokensWithdrawn()` could be the same. Most of these address parameters could also be any arbitrary address. This includes the token contract address, the address of the hook receiver, or the address of the `Umbra` contract itself.\r\n*  The token received may be valueless.\r\n* The token received may be malicious. The only requirements are that the token contract address contains code and accepts calls to the ERC20 methods `transfer()` and `transferFrom()`.\r\n\r\nWhile it is difficult to determine a feasible exploit without knowledge of what hook receiver contracts may do in the future, a slightly contrived example follows.\r\n\r\nSuppose a user builds a hook receiver contract that accepts an arbitrary token, `TOK`, and immediately provides liquidity to the `ETH-TOK` Uniswap pair when `tokensWithdrawn()` is called by the `Umbra` contract. An attacker could create a malicious token that can not be transferred out of its own Uniswap Pair contract and force a call to the hook receiver contract from `Umbra`. The hook receiver would be able to provide liquidity to the pool but would be unable to remove it, losing any ETH that was provided.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/umbra-smart-contracts/",
      "repo": "https://consensys.net//diligence/audits/2021/03/umbra-smart-contracts/",
      "url": "https://consensys.net//diligence/audits/2021/03/umbra-smart-contracts/"
    }
  },
  {
    "title": "Document token behavior restrictions",
    "severity": null,
    "body": "As with any protocol that interacts with arbitrary ERC20 tokens, it is important to clearly document which tokens are supported. Often this is best done by providing a specification for the behavior of the expected ERC20 tokens and only relaxing this specification after careful review of a particular class of tokens and their interactions with the protocol.\r\n\r\nIn the absence of this, the following is a necessarily incomplete list of some known deviations from \"normal\" ERC20 behavior that should be explicitly noted as *NOT* supported by the Umbra Protocol:\r\n\r\n* Deflationary or fee-on-transfer tokens: These are tokens in which the balance of the recipient of a transfer may not be increased by the amount of the transfer. There may also be some alternative mechanism by which balances are unexpectedly decreased. While these tokens can be successfully sent via the `sendToken()` function, the internal accounting of the `Umbra` contract will be out of sync with the balance as recorded in the token contract, resulting in loss of funds.\r\n* Inflationary tokens: The opposite of deflationary tokens. The `Umbra` contract provides no mechanism for claiming positive balance adjustments.\r\n* Rebasing tokens: A combination of the above cases, these are tokens in which an account’s balance increases or decreases along with expansions or contractions in supply. The contract provides no mechanism to update its internal accounting in response to these unexpected balance adjustments, and funds may be lost as a result.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/umbra-smart-contracts/",
      "repo": "https://consensys.net//diligence/audits/2021/03/umbra-smart-contracts/",
      "url": "https://consensys.net//diligence/audits/2021/03/umbra-smart-contracts/"
    }
  },
  {
    "title": "Code quality & Styling ",
    "severity": null,
    "body": "#### Description\r\nHere are some examples that the code style does not follow the best practices:\r\n\r\n#### Examples\r\n- Public/external function names should not be prefixed with `_`\r\n\n**code/contracts/core/TaskExecutor.sol:L56**\n```solidity\nfunction _executeActionsFromFL(Task memory _currTask, bytes32 _flAmount) public payable {\n```\n\r\n- Function parameters are being overriden\r\n\n**code/contracts/exchangeV3/DFSExchange.sol:L24-L37**\n```solidity\nfunction sell(ExchangeData memory exData, address payable _user) public payable   {\n\n    exData.dfsFeeDivider = SERVICE_FEE;\n    exData.user = _user;\n\n    // Perform the exchange\n    (address wrapper, uint destAmount) = _sell(exData);\n\n    // send back any leftover ether or tokens\n    sendLeftover(exData.srcAddr, exData.destAddr, _user);\n\n    // log the event\n    logger.Log(address(this), msg.sender, \"ExchangeSell\", abi.encode(wrapper, exData.srcAddr, exData.destAddr, exData.srcAmount, destAmount));\n}\n```\n\r\n- `MAX_SERVICE_FEE` should be `MIN_SERVICE_FEE`\r\n\n**code/contracts/utils/Discount.sol:L28-L33**\n```solidity\nfunction setServiceFee(address _user, uint256 _fee) public {\n    require(msg.sender == owner, \"Only owner\");\n    require(_fee >= MAX_SERVICE_FEE || _fee == 0, \"Wrong fee value\");\n\n    serviceFees[_user] = CustomServiceFee({active: true, amount: _fee});\n}\n```\n\r\n- Functions with a `get` prefix should not modify state\r\n\n**code/contracts/exchangeV3/DFSExchangeCore.sol:L182-L206**\n```solidity\nfunction getFee(\n    uint256 _amount,\n    address _user,\n    address _token,\n    uint256 _dfsFeeDivider\n) internal returns (uint256 feeAmount) {\n    if (_dfsFeeDivider != 0 && Discount(DISCOUNT_ADDRESS).isCustomFeeSet(_user)) {\n        _dfsFeeDivider = Discount(DISCOUNT_ADDRESS).getCustomServiceFee(_user);\n    }\n\n    if (_dfsFeeDivider == 0) {\n        feeAmount = 0;\n    } else {\n        feeAmount = _amount / _dfsFeeDivider;\n\n        // fee can't go over 10% of the whole amount\n        if (feeAmount > (_amount / 10)) {\n            feeAmount = _amount / 10;\n        }\n\n        address walletAddr = feeRecipient.getFeeAddr();\n\n        _token.withdrawTokens(walletAddr, feeAmount);\n    }\n}\n```\n\r\n- Protocol fee value should be validated against `msg.value` and not against contract's balance\r\n\n**code/contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol:L25-L31**\n```solidity\nfunction takeOrder(\n    ExchangeData memory _exData,\n    ExchangeActionType _type\n) override public payable returns (bool success, uint256) {\n    // check that contract have enough balance for exchange and protocol fee\n    require(_exData.srcAddr.getBalance(address(this)) >= _exData.srcAmount, ERR_SRC_AMOUNT);\n    require(TokenUtils.ETH_ADDR.getBalance(address(this)) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE);\n```\n\r\n- Remove deprecation warning (originated in OpenZeppelin's implementation) in comment, as the issue has been solved\r\n\n**code/contracts/utils/SafeERC20.sol:L33-L44**\n```solidity\n/**\n * @dev Deprecated. This function has issues similar to the ones found in\n * {ERC20-approve}, and its usage is discouraged.\n */\nfunction safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n}\n```\n\r\n- Typo `RECIPIE_FEE` instead of `RECIPE_FEE`\r\n\n**code/contracts/actions/exchange/DfsSell.sol:L15**\n```solidity\nuint internal constant RECIPIE_FEE = 400;\n```\n\r\n- Code duplication : `sendLeftOver` is identical both in `UniswapWrapperV3` and in `KyberWrapperV3`, and thus can be shared in a base class.\r\n\n**code/contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol:L127-L133**\n```solidity\nfunction sendLeftOver(address _srcAddr) internal {\n    msg.sender.transfer(address(this).balance);\n\n    if (_srcAddr != KYBER_ETH_ADDRESS) {\n        IERC20(_srcAddr).safeTransfer(msg.sender, IERC20(_srcAddr).balanceOf(address(this)));\n    }\n}\n```\n\r\n- Code duplication : `sliceUint` function is identical both in `DFSExchangeHelper` and in `DFSPrices`\r\n\r\n- `DFSPricesV3.getBestPrice`, `DFSPricesV3.getExpectedRate` should be view functions\r\n\r\n- Fix the code comments from `User borrows tokens to` to `User borrows tokens from`\r\n\n**code/contracts/actions/aave/AaveBorrow.sol:L63-L77**\n```solidity\n/// @notice User borrows tokens to the Aave protocol\n/// @param _market Address provider for specific market\n/// @param _tokenAddr The address of the token to be borrowed\n/// @param _amount Amount of tokens to be borrowed\n/// @param _rateMode Send 1 for stable rate and 2 for variable\n/// @param _to The address we are sending the borrowed tokens to\n/// @param _onBehalf From what user we are borrow the tokens, defaults to proxy\nfunction _borrow(\n    address _market,\n    address _tokenAddr,\n    uint256 _amount,\n    uint256 _rateMode,\n    address _to,\n    address _onBehalf\n) internal returns (uint256) {\n```\n\n**code/contracts/actions/compound/CompBorrow.sol:L51-L59**\n```solidity\n/// @notice User borrows tokens to the Compound protocol\n/// @param _cTokenAddr Address of the cToken we are borrowing\n/// @param _amount Amount of tokens to be borrowed\n/// @param _to The address we are sending the borrowed tokens to\nfunction _borrow(\n    address _cTokenAddr,\n    uint256 _amount,\n    address _to\n) internal returns (uint256) {\n```\n\r\n- `IExchangeV3.sell`, `IExchangeV3.buy` should not be payable\r\n\r\n- `TaskExecutor._executeAction` should not forward contract's balance within the `IDSProxy.execute` call, as the funds are being sent to the same contract.\r\n\n**code/contracts/core/TaskExecutor.sol:L90-L105**\n```solidity\nfunction _executeAction(\n    Task memory _currTask,\n    uint256 _index,\n    bytes32[] memory _returnValues\n) internal returns (bytes32 response) {\n    response = IDSProxy(address(this)).execute{value: address(this).balance}(\n        registry.getAddr(_currTask.actionIds[_index]),\n        abi.encodeWithSignature(\n            \"executeAction(bytes[],bytes[],uint8[],bytes32[])\",\n            _currTask.callData[_index],\n            _currTask.subData[_index],\n            _currTask.paramMapping[_index],\n            _returnValues\n        )\n    );\n}\n```\n\r\n- Unsafe arithmetic operations \r\n\n**code/contracts/actions/compound/CompClaim.sol:L73**\n```solidity\nuint256 compClaimed = compBalanceAfter - compBalanceBefore;\n```\n\n**code/contracts/actions/compound/CompWithdraw.sol:L84**\n```solidity\n_amount = tokenBalanceAfter - tokenBalanceBefore;\n```\n\n**code/contracts/actions/uniswap/UniSupply.sol:L82-L83**\n```solidity\n_uniData.tokenA.withdrawTokens(_uniData.to, (_uniData.amountADesired - amountA));\n_uniData.tokenB.withdrawTokens(_uniData.to, (_uniData.amountBDesired - amountB));\n```\n\n**code/contracts/actions/flashloan/FLAaveV2.sol:L125-L133**\n```solidity\nIDSProxy(proxy).execute{value: address(this).balance}(\n    taskExecutor,\n    abi.encodeWithSelector(CALLBACK_SELECTOR, currTask, bytes32(_amounts[0] + _fees[0]))\n);\n\n// return FL\nfor (uint256 i = 0; i < _assets.length; i++) {\n    _assets[i].approveToken(address(AAVE_LENDING_POOL), _amounts[i] + _fees[i]);\n}\n```\n\n**code/contracts/exchangeV3/DFSExchangeCore.sol:L45**\n```solidity\nexData.srcAmount -= getFee(\n```\n\n**code/contracts/exchangeV3/offchainWrappersV3/ZeroxWrapper.sol:L48**\n```solidity\ntokensSwaped = _exData.destAddr.getBalance(address(this)) - tokensBefore;\n```\n\r\n\r\n\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/defi-saver/",
      "repo": "https://consensys.net//diligence/audits/2021/03/defi-saver/",
      "url": "https://consensys.net//diligence/audits/2021/03/defi-saver/"
    }
  },
  {
    "title": "Gas optimization",
    "severity": null,
    "body": "#### Description\r\n\r\nUse `address(this)` instead of external call for registry when possible.\r\n\r\n#### Examples\r\n\n**code/contracts/actions/flashloan/FLAaveV2.sol:L82-L102**\n```solidity\nfunction _flAaveV2(FLAaveV2Data memory _flData, bytes memory _params) internal returns (uint) {\n\n    ILendingPoolV2(AAVE_LENDING_POOL).flashLoan(\n        payable(registry.getAddr(FL_AAVE_V2_ID)),\n        _flData.tokens,\n        _flData.amounts,\n        _flData.modes,\n        _flData.onBehalfOf,\n        _params,\n        AAVE_REFERRAL_CODE\n    );\n\n    logger.Log(\n        address(this),\n        msg.sender,\n        \"FLAaveV2\",\n        abi.encode(_flData.tokens, _flData.amounts, _flData.modes, _flData.onBehalfOf)\n    );\n\n    return _flData.amounts[0];\n}\n```\n\r\n\n**code/contracts/actions/flashloan/dydx/FLDyDx.sol:L76-L107**\n```solidity\nfunction _flDyDx(\n    uint256 _amount,\n    address _token,\n    bytes memory _data\n) internal returns (uint256) {\n\n    address payable receiver = payable(registry.getAddr(FL_DYDX_ID));\n\n    ISoloMargin solo = ISoloMargin(SOLO_MARGIN_ADDRESS);\n\n    // Get marketId from token address\n    uint256 marketId = _getMarketIdFromTokenAddress(SOLO_MARGIN_ADDRESS, _token);\n\n    uint256 repayAmount = _getRepaymentAmountInternal(_amount);\n\n    IERC20(_token).safeApprove(SOLO_MARGIN_ADDRESS, repayAmount);\n\n    Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\n\n    operations[0] = _getWithdrawAction(marketId, _amount, receiver);\n    operations[1] = _getCallAction(_data, receiver);\n    operations[2] = _getDepositAction(marketId, repayAmount, address(this));\n\n    Account.Info[] memory accountInfos = new Account.Info[](1);\n    accountInfos[0] = _getAccountInfo();\n\n    solo.operate(accountInfos, operations);\n\n    logger.Log(address(this), msg.sender, \"FLDyDx\", abi.encode(_amount, _token));\n\n    return _amount;\n}\n```\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/defi-saver/",
      "repo": "https://consensys.net//diligence/audits/2021/03/defi-saver/",
      "url": "https://consensys.net//diligence/audits/2021/03/defi-saver/"
    }
  },
  {
    "title": "Tokens with more than 18 decimal points will cause issues",
    "severity": "major",
    "body": "#### Description\r\nIt is assumed that the maximum number of decimals for each token is 18. However uncommon, but it is possible to have tokens with more than 18 decimals, as an Example [YAMv2](https://etherscan.io/token/0xaba8cac6866b83ae4eec97dd07ed254282f6ad8a) has 24 decimals. This can result in broken code flow and unpredictable outcomes (e.g. an underflow will result with really high rates).\r\n\r\n#### Examples\r\n\r\n- `contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol`\r\n\r\n```solidity\r\n    function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory) public override view returns (uint rate) {\r\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\r\n            .getExpectedRate(IERC20(_srcAddr), IERC20(_destAddr), _srcAmount);\r\n\r\n        // multiply with decimal difference in src token\r\n        rate = rate * (10**(18 - getDecimals(_srcAddr))); \r\n        // divide with decimal difference in dest token\r\n        rate = rate / (10**(18 - getDecimals(_destAddr))); \r\n    }\r\n```\r\n\r\n- `code/contracts/views/AaveView.sol` :  also used in `getLoanData()`\r\n\r\n\r\n#### Recommendation\r\n\r\nMake sure the code won't fail in case the token's decimals is more than 18. ",
    "dataSource": {
      "name": "/diligence/audits/2021/03/defi-saver/",
      "repo": "https://consensys.net//diligence/audits/2021/03/defi-saver/",
      "url": "https://consensys.net//diligence/audits/2021/03/defi-saver/"
    }
  },
  {
    "title": "Reversed order of parameters in `allowance` function call",
    "severity": "medium",
    "body": "#### Description\r\nWhen trying to pull the maximum amount of tokens from an approver to the allowed spender, the parameters that are used for the `allowance` function call are not in the same order that is used later in the call to `safeTransferFrom`.\r\n#### Examples\r\n\n**code/contracts/utils/TokenUtils.sol:L26-L44**\n```solidity\nfunction pullTokens(\n    address _token,\n    address _from,\n    uint256 _amount\n) internal returns (uint256) {\n    // handle max uint amount\n    if (_amount == type(uint256).max) {\n        uint256 allowance = IERC20(_token).allowance(address(this), _from);\n        uint256 balance = getBalance(_token, _from);\n\n        _amount = (balance > allowance) ? allowance : balance;\n    }\n\n    if (_from != address(0) && _from != address(this) && _token != ETH_ADDR && _amount != 0) {\n        IERC20(_token).safeTransferFrom(_from, address(this), _amount);\n    }\n\n    return _amount;\n}\n```\n#### Recommendation\r\nReverse the order of parameters in `allowance` function call to fit the order that is in the `safeTransferFrom` function call.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/defi-saver/",
      "repo": "https://consensys.net//diligence/audits/2021/03/defi-saver/",
      "url": "https://consensys.net//diligence/audits/2021/03/defi-saver/"
    }
  },
  {
    "title": "Kyber getRates code is unclear ",
    "severity": "minor",
    "body": "#### Description\r\nIn `contracts/exchangeV3/wrappersV3/KyberWrapperV3.sol` the function names don't reflect their true functionalities, and the code uses some undocumented assumptions. \r\n\r\n#### Examples\r\n\r\n- `getSellRate` can be converted into one function to get the rates, which then for buy or sell can swap input and output tokens\r\n- `getBuyRate` uses a 3% slippage that is not documented.\r\n\r\n```solidity\r\n   function getSellRate(address _srcAddr, address _destAddr, uint _srcAmount, bytes memory) public override view returns (uint rate) {\r\n        (rate, ) = KyberNetworkProxyInterface(KYBER_INTERFACE)\r\n            .getExpectedRate(IERC20(_srcAddr), IERC20(_destAddr), _srcAmount);\r\n\r\n        // multiply with decimal difference in src token\r\n        rate = rate * (10**(18 - getDecimals(_srcAddr))); \r\n        // divide with decimal difference in dest token\r\n        rate = rate / (10**(18 - getDecimals(_destAddr))); \r\n    }\r\n\r\n    /// @notice Return a rate for which we can buy an amount of tokens\r\n    /// @param _srcAddr From token\r\n    /// @param _destAddr To token\r\n    /// @param _destAmount To amount\r\n    /// @return rate Rate\r\n    function getBuyRate(address _srcAddr, address _destAddr, uint _destAmount, bytes memory _additionalData) public override view returns (uint rate) {\r\n        uint256 srcRate = getSellRate(_destAddr, _srcAddr, _destAmount, _additionalData);\r\n        uint256 srcAmount = wmul(srcRate, _destAmount);\r\n\r\n        rate = getSellRate(_srcAddr, _destAddr, srcAmount, _additionalData);\r\n\r\n        // increase rate by 3% too account for inaccuracy between sell/buy conversion\r\n        rate = rate + (rate / 30); \r\n    }\r\n```\r\n\r\n\r\n#### Recommendation\r\nRefactoring the code to separate getting rate functionality with `getSellRate` and `getBuyRate`. Explicitly document any assumptions in the code ( slippage, etc)",
    "dataSource": {
      "name": "/diligence/audits/2021/03/defi-saver/",
      "repo": "https://consensys.net//diligence/audits/2021/03/defi-saver/",
      "url": "https://consensys.net//diligence/audits/2021/03/defi-saver/"
    }
  },
  {
    "title": "Proper usage of the `transfer` and the `transferFrom` functions",
    "severity": "medium",
    "body": "#### Description\r\n\r\nMany ERC-20 transfers in the code are just called without checking the return values:\r\n\r\n\n**code_new/contracts/PolicyBook.sol:L269-L270**\n```solidity\ndaiToken.transferFrom(_msgSender(), reinsurancePoolAddress, _reinsurancePrice);\ndaiToken.transferFrom(_msgSender(), address(this), _price);    \n```\n\r\n\n**code_new/contracts/PolicyBook.sol:L556-L559**\n```solidity\nfunction _unlockTokens(uint256 _amountToUnlock) internal {\n  this.transfer(_msgSender(), _amountToUnlock);\n  delete withdrawalsInfo[_msgSender()];\n}\n```\n\r\n\n**code_new/contracts/LiquidityMining.sol:L278**\n```solidity\nbmiToken.transfer(msg.sender, _userReward);\n```\n\r\nEven though the tokens in these calls are not arbitrary (DAI, BMI, DAIx, stkBMIToken) and probably always return `True` or call `revert`, it's still better to comply with the ERC-20 standard and make sure that the transfer went well.\r\n\r\n#### Recommendation\r\n\r\nThe best solution would be better to always use the safe version of the transfers from `openzeppelin/contracts/token/ERC20/SafeERC20.sol`.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/bridge-mutual/",
      "repo": "https://consensys.net//diligence/audits/2021/03/bridge-mutual/",
      "url": "https://consensys.net//diligence/audits/2021/03/bridge-mutual/"
    }
  },
  {
    "title": "The withdrawal queue is only updated when the liquidity is added",
    "severity": "medium",
    "body": "#### Description\r\n\r\nSometimes when the amount of liquidity is not much higher than the number of tokens locked for the collateral, it's impossible to withdraw liquidity.  For a user that wants to withdraw liquidity, a withdrawal request is created. If the request can't be executed, it's added to the withdrawal queue, and the user needs to wait until there's enough collateral for withdrawal. There are potentially 2 ways to achieve that: either someone adds more liquidity or some existing policies expire.\r\n\r\nCurrently, the queue can only be cleared when the internal `_updateWithdrawalQueue ` function is called. And it is only called in one place while adding liquidity:\r\n\r\n\n **code/contracts/PolicyBook.sol:L276-L290**\n ```solidity\n function _addLiquidityFor(address _liquidityHolderAddr, uint256 _liquidityAmount, bool _isLM) internal {\n   daiToken.transferFrom(_liquidityHolderAddr, address(this), _liquidityAmount);    \n   \n   uint256 _amountToMint = _liquidityAmount.mul(PERCENTAGE_100).div(getDAIToDAIxRatio());\n   totalLiquidity = totalLiquidity.add(_liquidityAmount);\n   _mintERC20(_liquidityHolderAddr, _amountToMint);\n \n   if (_isLM) {\n     liquidityFromLM[_liquidityHolderAddr] = liquidityFromLM[_liquidityHolderAddr].add(_liquidityAmount);\n   }\n \n   _updateWithdrawalQueue();\n \n   emit AddLiquidity(_liquidityHolderAddr, _liquidityAmount, totalLiquidity);\n }\n ```\n\r\n#### Recommendation\r\n\r\nIt would be better if the queue could be processed when some policies expire without adding new liquidity. For example, there may be an external function that allows users to process the queue.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/bridge-mutual/",
      "repo": "https://consensys.net//diligence/audits/2021/03/bridge-mutual/",
      "url": "https://consensys.net//diligence/audits/2021/03/bridge-mutual/"
    }
  },
  {
    "title": "`iETH.exchangeRateStored` may not be accurate when invoked from external contracts",
    "severity": "major",
    "body": "#### Description\r\n\r\n`iETH.exchangeRateStored` returns the exchange rate of the contract as a function of the current cash of the contract. In the case of `iETH`, current cash is calculated as the contract's ETH balance minus `msg.value`:\r\n\r\n\n**code/contracts/iETH.sol:L54-L59**\n```solidity\n/**\n * @dev Gets balance of this contract in terms of the underlying\n */\nfunction _getCurrentCash() internal view override returns (uint256) {\n    return address(this).balance.sub(msg.value);\n}\n```\n\r\n`msg.value` is subtracted because the majority of `iETH` methods are payable, and `msg.value` is implicitly added to a contract's balance before execution begins. If `msg.value` were not subtracted, the value sent with a call could be used to inflate the contract's exchange rate artificially.\r\n\r\nAs part of execution, `iETH` makes calls to the `Controller`, which performs important checks using (among other things) the stored exchange rate. When `exchangeRateStored` is invoked from the `Controller`, the call context has a `msg.value` of 0. However, the `msg.value` sent by the initial `iETH` execution is still included in the contract's balance. This means that the `Controller` receives an exchange rate inflated by the initial call's `msg.value`.\r\n\r\n#### Examples\r\n\r\nThis problem occurs in multiple locations in the `Controller`:\r\n\r\n* `beforeMint` uses the exchange rate to ensure the supply capacity of the market is not reached. In this case, inflation would prevent the entire supply capacity of the market from being utilized:\r\n\r\n\n**code/contracts/Controller.sol:L670-L678**\n```solidity\n// Check the iToken's supply capacity, -1 means no limit\nuint256 _totalSupplyUnderlying =\n    IERC20Upgradeable(_iToken).totalSupply().rmul(\n        IiToken(_iToken).exchangeRateStored()\n    );\nrequire(\n    _totalSupplyUnderlying.add(_mintAmount) <= _market.supplyCapacity,\n    \"Token supply capacity reached\"\n);\n```\n\r\n* `beforeLiquidateBorrow` uses the exchange rate via `calcAccountEquity` to calculate the value of the borrower's collateral. In this case, inflation would increase the account's equity, which could prevent the liquidator from liquidating:\r\n\r\n\n**code/contracts/Controller.sol:L917-L919**\n```solidity\n(, uint256 _shortfall, , ) = calcAccountEquity(_borrower);\n\nrequire(_shortfall > 0, \"Account does not have shortfall\");\n```\n\r\n#### Recommendation\r\n\r\n* Rather than having the `Controller` query the `iETH.exchangeRateStored`, the exchange rate could be passed-in to `Controller` methods as a parameter.\r\n\r\n* Ensure no other components in the system rely on `iETH.exchangeRateStored` after being called from `iETH`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/03/dforce-lending-protocol-review/",
      "repo": "https://consensys.net//diligence/audits/2021/03/dforce-lending-protocol-review/",
      "url": "https://consensys.net//diligence/audits/2021/03/dforce-lending-protocol-review/"
    }
  },
  {
    "title": "`permit` functions use deployment-time instead of execution-time chain ID",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe contracts `Base`, `MSD`, and `MSDS` each have an [EIP-2612](https://eips.ethereum.org/EIPS/eip-2612)-style `permit` function that supports approvals with [EIP-712](https://eips.ethereum.org/EIPS/eip-712) signatures. We focus this discussion on the `Base` contract, but the same applies to `MSD` and `MSDS`.\\\r\nWhen the contract is initialized, the chain ID is queried (with the `CHAINID` opcode) and becomes part of the `DOMAIN_SEPARATOR` — a hash of several values which (presumably) don't change over the lifetime of the contract and that can therefore be computed only once, when the contract is deployed.\r\n\r\n\n**code/contracts/TokenBase/Base.sol:L23-L56**\n```solidity\nfunction _initialize(\n    string memory _name,\n    string memory _symbol,\n    uint8 _decimals,\n    IControllerInterface _controller,\n    IInterestRateModelInterface _interestRateModel\n) internal virtual {\n    controller = _controller;\n    interestRateModel = _interestRateModel;\n    accrualBlockNumber = block.number;\n    borrowIndex = BASE;\n    flashloanFeeRatio = 0.0008e18;\n    protocolFeeRatio = 0.25e18;\n    __Ownable_init();\n    __ERC20_init(_name, _symbol, _decimals);\n    __ReentrancyGuard_init();\n\n    uint256 chainId;\n\n    assembly {\n        chainId := chainid()\n    }\n    DOMAIN_SEPARATOR = keccak256(\n        abi.encode(\n            keccak256(\n                \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n            ),\n            keccak256(bytes(_name)),\n            keccak256(bytes(\"1\")),\n            chainId,\n            address(this)\n        )\n    );\n}\n```\n\r\nThe `DOMAIN_SEPARATOR` is supposed to prevent replay attacks by providing context for the signature; it is hashed into the digest to be signed.\r\n\r\n\n**code/contracts/TokenBase/Base.sol:L589-L610**\n```solidity\nbytes32 _digest =\n    keccak256(\n        abi.encodePacked(\n            \"\\x19\\x01\",\n            DOMAIN_SEPARATOR,\n            keccak256(\n                abi.encode(\n                    PERMIT_TYPEHASH,\n                    _owner,\n                    _spender,\n                    _value,\n                    _currentNonce,\n                    _deadline\n                )\n            )\n        )\n    );\naddress _recoveredAddress = ecrecover(_digest, _v, _r, _s);\nrequire(\n    _recoveredAddress != address(0) && _recoveredAddress == _owner,\n    \"permit: INVALID_SIGNATURE!\"\n);\n```\n\r\nThe chain ID is not necessarily constant, though. In the event of a chain split, only one of the resulting chains gets to keep the original chain ID and the other will have to use a new one. With the current pattern, a signature will be valid on both chains; if the `DOMAIN_SEPARATOR` is recomputed for every verification, a signature will only be valid on the chain that keeps the original ID — which is probably the intended behavior.\r\n\r\n#### Remark\r\n\r\nThe reason why the not necessarily constant chain ID is part of the supposedly constant `DOMAIN_SEPARATOR` is that [EIP-712](https://eips.ethereum.org/EIPS/eip-712) predates the [introduction of the `CHAINID` opcode](https://eips.ethereum.org/EIPS/eip-1344). Originally, it was not possible to query the chain ID via opcode, so it had to be supplied to the constructor of a contract by the deployment script.\r\n\r\n#### Recommendation\r\n\r\nAn obvious fix is to compute the `DOMAIN_SEPARATOR` dynamically in `permit`. However, since a chain split is a relatively unlikely event, it makes sense to compute the `DOMAIN_SEPARATOR` at deployment/initialization time and then check in `permit` whether the current chain ID equals the one that went into the `DOMAIN_SEPARATOR`. If that is true, we proceed as before. If the chain ID has changed, we could (1) just revert, or (2) recompute the `DOMAIN_SEPARATOR` with the new chain ID. Solution (1) is probably the easiest and most straightforward to implement, but it should be noted that it makes the permit functionality of this contract completely unusable on the new chain.",
    "dataSource": {
      "name": "/diligence/audits/2021/03/dforce-lending-protocol-review/",
      "repo": "https://consensys.net//diligence/audits/2021/03/dforce-lending-protocol-review/",
      "url": "https://consensys.net//diligence/audits/2021/03/dforce-lending-protocol-review/"
    }
  },
  {
    "title": "Incorrect token decimal conversions can lead to loss of funds",
    "severity": "major",
    "body": "#### Description\r\nThe `_convert()` function in `DAOfiV1Pair` is used to accommodate tokens with varying `decimals()` values. There are three cases in which it implicitly returns 0 for any `amount`, the most notable of which is when `token.decimals() == resolution`.\r\n\r\nAs a result of this, `getQuoteOut()` reverts any time either `baseToken` or `quoteToken` have `decimals == INTERNAL_DECIMALS` (currently hardcoded to 8).\r\n\r\n`getBaseOut()` also reverts in most cases when either `baseToken` or `quoteToken` have `decimals() == INTERNAL_DECIMALS`. The exception is when `getBaseOut()` is called while `supply` is 0, as is the case in `deposit()`. This causes `getBaseOut()` to succeed, returning an incorrect value.\r\n\r\nThe result of this is that no swaps can be performed in one of these pools, and the `deposit()` function will return an incorrect `amountBaseOut` of `baseToken` to the depositor, the balance of which can then be withdrawn by the `pairOwner`.\r\n\r\n\n**code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L108-L130**\n```solidity\nfunction _convert(address token, uint256 amount, uint8 resolution, bool to) private view returns (uint256 converted) {\n    uint8 decimals = IERC20(token).decimals();\n    uint256 diff = 0;\n    uint256 factor = 0;\n    converted = 0;\n    if (decimals > resolution) {\n        diff = uint256(decimals.sub(resolution));\n        factor = 10 ** diff;\n        if (to && amount >= factor) {\n            converted = amount.div(factor);\n        } else if (!to) {\n            converted = amount.mul(factor);\n        }\n    } else if (decimals < resolution) {\n        diff = uint256(resolution.sub(decimals));\n        factor = 10 ** diff;\n        if (to) {\n            converted = amount.mul(factor);\n        } else if (!to && amount >= factor) {\n            converted = amount.div(factor);\n        }\n    }\n}\n```\n\r\n#### Recommendation\r\n\r\nThe `_convert()` function should return `amount` when `token.decimals() == resolution`. Additionally, implicit return values should be avoided whenever possible, especially in functions that implement complex mathematical operations.\r\n\r\n`BancorFormula.power(baseN, baseD, _, _)` does not support `baseN < baseD`, and checks should be added to ensure that any call to the `BancorFormula` conforms to the expected input ranges.",
    "dataSource": {
      "name": "/diligence/audits/2021/02/daofi/",
      "repo": "https://consensys.net//diligence/audits/2021/02/daofi/",
      "url": "https://consensys.net//diligence/audits/2021/02/daofi/"
    }
  },
  {
    "title": "`DAOfiV1Pair.deposit()` accepts deposits of zero, blocking the pool",
    "severity": "medium",
    "body": "#### Description\r\n`DAOfiV1Pair.deposit()` is used to deposit liquidity into the pool. Only a single deposit can be made, so no liquidity can ever be added to a pool where `deposited == true`. The `deposit()` function does not check for a nonzero deposit amount in either token, so a malicious user that does not hold any of the `baseToken` or `quoteToken` can lock the pool by calling `deposit()` without first transferring any funds to the pool.\r\n\r\n\n**code/daofi-v1-core/contracts/DAOfiV1Pair.sol:L223-L239**\n```solidity\nfunction deposit(address to) external override lock returns (uint256 amountBaseOut) {\n    require(msg.sender == router, 'DAOfiV1: FORBIDDEN_DEPOSIT');\n    require(deposited == false, 'DAOfiV1: DOUBLE_DEPOSIT');\n    reserveBase = IERC20(baseToken).balanceOf(address(this));\n    reserveQuote = IERC20(quoteToken).balanceOf(address(this));\n    // this function is locked and the contract can not reset reserves\n    deposited = true;\n    if (reserveQuote > 0) {\n        // set initial supply from reserveQuote\n        supply = amountBaseOut = getBaseOut(reserveQuote);\n        if (amountBaseOut > 0) {\n            _safeTransfer(baseToken, to, amountBaseOut);\n            reserveBase = reserveBase.sub(amountBaseOut);\n        }\n    }\n    emit Deposit(msg.sender, reserveBase, reserveQuote, amountBaseOut, to);\n}\n```\n\r\n#### Recommendation\r\n\r\nRequire a minimum deposit amount in both `baseToken` and `quoteToken`, and do not rely on any assumptions about the distribution of `baseToken` as part of the security model.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/02/daofi/",
      "repo": "https://consensys.net//diligence/audits/2021/02/daofi/",
      "url": "https://consensys.net//diligence/audits/2021/02/daofi/"
    }
  },
  {
    "title": "`DAOfiV1Router01.removeLiquidityETH()` does not support tokens with no return value",
    "severity": "minor",
    "body": "#### Description\r\nWhile the rest of the system uses the `safeTransfer*` pattern, allowing tokens that do not return a boolean value on `transfer()` or `transferFrom()`, `DAOfiV1Router01.removeLiquidityETH()` throws and consumes all remaining gas if the base token does not return `true`.\r\n\r\nNote that the deposit in this case can still be withdrawn without unwrapping the Eth using `removeLiquidity()`.\r\n\r\n\n**code/daofi-v1-periphery/contracts/DAOfiV1Router01.sol:L157-L167**\n```solidity\nfunction removeLiquidityETH(\n    LiquidityParams calldata lp,\n    uint deadline\n) external override ensure(deadline) returns (uint amountToken, uint amountETH) {\n    IDAOfiV1Pair pair = IDAOfiV1Pair(DAOfiV1Library.pairFor(factory, lp.tokenBase, WETH, lp.slopeNumerator, lp.n, lp.fee));\n    require(msg.sender == pair.pairOwner(), 'DAOfiV1Router: FORBIDDEN');\n    (amountToken, amountETH) = pair.withdraw(address(this));\n    assert(IERC20(lp.tokenBase).transfer(lp.to, amountToken));\n    IWETH10(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(lp.to, amountETH);\n}\n```\n\r\n#### Recommendation\r\nBe consistent with the use of `safeTransfer*`, and do not use `assert()` in cases where the condition can be false.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2021/02/daofi/",
      "repo": "https://consensys.net//diligence/audits/2021/02/daofi/",
      "url": "https://consensys.net//diligence/audits/2021/02/daofi/"
    }
  },
  {
    "title": "Handle transfer tokens where `from == to`",
    "severity": "minor",
    "body": "#### Description\r\nIn TokenFaucet, when calling `beforeTokenTransfer` it should also be optimized when `to == from`. This is to prevent any possible issues with internal accounting and token drip calculations.\r\n\r\n`/pool-contracts/contracts/token-faucet/TokenFaucet.sol`\r\n\r\n```solidity\r\n...\r\n if (token == address(measure) && from != address(0)) {  //add && from != to\r\n      drip();\r\n...\r\n```\r\n#### Recommendation\r\nAs ERC20 standard, `from == to` can be allowed but check in `beforeTokenTransfer` that if `to == from`, then do not call `_captureNewTokensForUser(from);` again. ",
    "dataSource": {
      "name": "/diligence/audits/2021/02/pooltogether/",
      "repo": "https://consensys.net//diligence/audits/2021/02/pooltogether/",
      "url": "https://consensys.net//diligence/audits/2021/02/pooltogether/"
    }
  },
  {
    "title": "Unnecessary use of upgradability ",
    "severity": null,
    "body": "#### Description\r\nLibraries such as `SafeMath` and `SafeCast` should not be upgradable as they should be used as pure functions.\r\n\r\nUpgradable libraries used in TokenFaucet contract:\r\n\r\n- SafeMathUpgradeable\r\n- SafeCastUpgradeable\r\n- IERC20Upgradeable\r\n\r\n#### Recommendation\r\nRemove the upgradability functionality from any part of the system that is unnecessary, as they add complexity and centralization power to the admins. ",
    "dataSource": {
      "name": "/diligence/audits/2021/02/pooltogether/",
      "repo": "https://consensys.net//diligence/audits/2021/02/pooltogether/",
      "url": "https://consensys.net//diligence/audits/2021/02/pooltogether/"
    }
  },
  {
    "title": "Share status codes between `ERC20KYC` and `IexecERC20CoreKYC`",
    "severity": null,
    "body": "Both `ERC20KYC` and the PoCo system's `IexecERC20CoreKYC` utilize the same status codes for `ERC20KYC.detectTransferRestriction`, with a status code of 0 indicating no restriction. To prevent future changes to these status codes from raising conflicts between the two definitions, it would be beneficial to define them in a single independent library or contract, perhaps as a solidity `enum`.\r\n\r\n\n**code/eRLC/contracts/ERC20KYC.sol:L28-L30**\n```solidity\nuint8 internal constant _RESTRICTION_OK               = uint8(0);\nuint8 internal constant _RESTRICTION_MISSING_KYC_FROM = uint8(0x01);\nuint8 internal constant _RESTRICTION_MISSING_KYC_TO   = uint8(0x02);\n```\n\r\n\n**code/PoCo/contracts/modules/delegates/IexecERC20CoreKYC.sol:L36-L40**\n```solidity\nuint8 restrictionCode = m_baseToken.detectTransferRestriction(from, to, amount);\nif (restrictionCode != uint8(0))\n{\n\trevert(m_baseToken.messageForTransferRestriction(restrictionCode));\n}\n```\n",
    "dataSource": {
      "name": "/diligence/audits/2021/01/erlc-iexec/",
      "repo": "https://consensys.net//diligence/audits/2021/01/erlc-iexec/",
      "url": "https://consensys.net//diligence/audits/2021/01/erlc-iexec/"
    }
  },
  {
    "title": "GovernanceMothership - Follow checks-effects-interactions",
    "severity": null,
    "body": "#### Description\r\n\r\n`Mothership.unstake()` breaks checks-effects-interactions by transferring the requested amount of token out first before validating that the `msg.sender` actually holds the token (with `burn()`). If the `1INCH` token implements callbacks (e.g. `erc777`) this might be more problematic (e.g. allows to flash-lend 1inch token). However, the token is controlled by 1inch and therefore unlikely to pose such a risk.\r\n\r\n\n**code/contracts/inch/GovernanceMothership.sol:L36-L42**\n```solidity\nfunction unstake(uint256 amount) external {\n    require(amount > 0, \"Empty unstake is not allowed\");\n\n    inchToken.transfer(msg.sender, amount);\n    _burn(msg.sender, amount);\n    _notifyFor(msg.sender, balanceOf(msg.sender));\n}\n```\n\r\n#### Recommendation\r\n\r\n`burn()` and `notify()` first, then transfer the token to the user. Consider locking staked token for a minimum amount of `1+` blocks. Consider adding a reentrancy guard. `1INCH` token should not be allowed to have callbacks.\r\n\r\nNote that the return value of the transfers is unchecked. As this token is controlled by 1inch and a standard oz `ERC20` we did not consider this as a risk. If you plan on allowing other - potentially spec inconsistent external - tokens as stake consider checking the return values.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/"
    }
  },
  {
    "title": "[Out of Scope] ReferralFeeReceiver - anyone can steal all the funds that belong to ReferralFeeReceiver",
    "severity": "critical",
    "body": "#### Description\r\n\r\n**Note**: *This issue was raised in components that were being affected by the scope reduction as outlined in the section \"Scope\" and are, therefore, only shallowly validated. Nevertheless, we find it important to communicate such potential findings and ask the client to further investigate.*\r\n\r\nThe `ReferralFeeReceiver` receives pool shares when users `swap()` tokens in the pool. A `ReferralFeeReceiver` may be used with multiple pools and, therefore, be a lucrative target as it is holding pool shares.\r\n\r\nAny token or `ETH` that belongs to the `ReferralFeeReceiver` is at risk and can be drained by any user by providing a custom `mooniswap` pool contract that references existing token holdings.\r\n\r\nIt should be noted that none of the functions in `ReferralFeeReceiver` verify that the user-provided `mooniswap` pool address was actually deployed by the linked `MooniswapFactory`. The factory provides certain security guarantees about mooniswap pool contracts (e.g. valid mooniswap contract, token deduplication, tokenA!=tokenB, enforced token sorting, ...), however, since the `ReferralFeeReceiver` does not verify the user-provided `mooniswap` address they are left unchecked.\r\n\r\n##### Additional Notes\r\n\r\n* `freezeEpoch` - (callable by anyone) performs a `pool.withdraw()` with the `minAmounts` check being disabled. This may allow someone to call this function at a time where the contract actually gets a bad deal. \r\n* `trade` - (callable by anyone) can intentionally be used to perform bad trades (front-runnable)\r\n* `trade` - (callable by anyone) appears to implement inconsistent behavior when sending out `availableBalance`. `ETH` is sent to `tx.origin` (the caller) while tokens are sent to the user-provided `mooniswap` address.\r\n\n**code/contracts/ReferralFeeReceiver.sol:L91-L95**\n```solidity\nif (path[0].isETH()) {\n    tx.origin.transfer(availableBalance);  // solhint-disable-line avoid-tx-origin\n} else {\n    path[0].safeTransfer(address(mooniswap), availableBalance);\n}\n```\n\r\n* multiple methods - since `mooniswap` is a user-provided address there are a lot of opportunities to reenter the contract. Consider adding reentrancy guards as another security layer (e.g. `claimCurrentEpoch` and others).\r\n* multiple methods - do not validate the amount of tokens that are returned, causing an evm assertion due to out of bounds index access.\r\n\r\n\n**code/contracts/ReferralFeeReceiver.sol:L57-L59**\n```solidity\nIERC20[] memory tokens = mooniswap.getTokens();\nuint256 token0Balance = tokens[0].uniBalanceOf(address(this));\nuint256 token1Balance = tokens[1].uniBalanceOf(address(this));\n```\n\r\n* in `GovernanceFeeReceiver` anyone can intentionally force unwrapping of pool tokens or perform swaps in the worst time possible. e.g. The checks for `withdraw(..., minAmounts)` is disabled.\r\n\r\n\n**code/contracts/governance/GovernanceFeeReceiver.sol:L18-L26**\n```solidity\nfunction unwrapLPTokens(Mooniswap mooniswap) external validSpread(mooniswap) {\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n}\n\nfunction swap(IERC20[] memory path) external validPath(path) {\n    (uint256 amount,) = _maxAmountForSwap(path, path[0].uniBalanceOf(address(this)));\n    uint256 result = _swap(path, amount, payable(address(rewards)));\n    rewards.notifyRewardAmount(result);\n}\n```\n\r\n#### Examples\r\n\r\nA malicious user can drain all token by calling `claimFrozenEpoch` with a custom contract as `mooniswap` that returns a token address the `ReferralFeeReceiver` contracts holds token from in `IERC20[] memory tokens = mooniswap.getTokens();`. A subsequent call to `_transferTokenShare()` will then send out any amount of token requested by the attacker to the attacker-controlled address (`msg.sender`).\r\n\r\nLet's assume the following scenario:\r\n\r\n* `ReferralFeeReceiver` holds `DAI` token and we want to steal them.\r\n\r\nAn attacker may be able to drain the contract from `DAI` token via  `claimFrozenToken` if\r\n\r\n* they control the `mooniswap` address argument and provide a malicious contract\r\n* `user.share[mooniswap][firstUnprocessedEpoch] > 0` - this can be arbitrarily set in `updateReward`\r\n*  `token.epochBalance[currentEpoch].token0Balance > 0` - this can be manipulated in `freezeEpoch` by providing a malicious `mooniswap` contract\r\n* they own a worthless `ERC20` token e.g. named `ATTK`\r\n\r\nThe following steps outline the attack:\r\n\r\n1. The attacker calls into `updateReward` to set `user.share[mooniswap][currentEpoch]` to a value that is greater than zero to make sure that `share` in `claimFrozenEpoch` takes the `_transferTokenShare` path.\r\n\r\n\n**code/contracts/ReferralFeeReceiver.sol:L38-L50**\n```solidity\nfunction updateReward(address referral, uint256 amount) external override {\n    Mooniswap mooniswap = Mooniswap(msg.sender);\n    TokenInfo storage token = tokenInfo[mooniswap];\n    UserInfo storage user = userInfo[referral];\n    uint256 currentEpoch = token.currentEpoch;\n\n    // Add new reward to current epoch\n    user.share[mooniswap][currentEpoch] = user.share[mooniswap][currentEpoch].add(amount);\n    token.epochBalance[currentEpoch].totalSupply = token.epochBalance[currentEpoch].totalSupply.add(amount);\n\n    // Collect all processed epochs and advance user token epoch\n    _collectProcessedEpochs(user, token, mooniswap, currentEpoch);\n}\n```\n\r\n2. The attacker then calls `freezeEpoch()` providing the malicious `mooniswap` contract address controlled by the attacker.\r\n  * The malicious contract returns token that is controlled by the attacker (e.g. `ATTK`) in a call to `mooniswap.getTokens();`\r\n  * The contract then stores the current balance of the attacker-controlled token in `token0Balance/token1Balance`. Note that the token being returned here by the malicious contract can be different from the one we're checking out in the last step (balance manipulation via `ATTK`, checkout of `DAI` in the last step). \r\n  * Then the contract calls out to the malicious `mooniswap` contract. This gives the malicious contract an easy opportunity to send some attacker-controlled token (`ATTK`) to the `ReferralFeeReceiver` in order to freely manipulate the frozen tokenbalances (`tokens[0].uniBalanceOf(address(this)).sub(token0Balance);`). \r\n  * Note that the used token addresses are never stored anywhere. The balances recorded here are for an attacker-controlled token (`ATTK`), not the actual one that we're about to steal (e.g. `DAI`)\r\n  * The token balances are now set-up for checkout in the last step (`claimFrozenEpoch`).\r\n\r\n\n**code/contracts/ReferralFeeReceiver.sol:L52-L64**\n```solidity\nfunction freezeEpoch(Mooniswap mooniswap) external validSpread(mooniswap) {\n    TokenInfo storage token = tokenInfo[mooniswap];\n    uint256 currentEpoch = token.currentEpoch;\n    require(token.firstUnprocessedEpoch == currentEpoch, \"Previous epoch is not finalized\");\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n    uint256 token0Balance = tokens[0].uniBalanceOf(address(this));\n    uint256 token1Balance = tokens[1].uniBalanceOf(address(this));\n    mooniswap.withdraw(mooniswap.balanceOf(address(this)), new uint256[](0));\n    token.epochBalance[currentEpoch].token0Balance = tokens[0].uniBalanceOf(address(this)).sub(token0Balance);\n    token.epochBalance[currentEpoch].token1Balance = tokens[1].uniBalanceOf(address(this)).sub(token1Balance);\n    token.currentEpoch = currentEpoch.add(1);\n}\n```\n\r\n3. A call to `claimFrozenEpoch` checks-out the previously frozen token balance. \r\n  * The `claim > 0` requirement was fulfilled in step 1. \r\n  * The token balance was prepared for the attacker-controlled token (`ATTK`) in step 2, but we're now checking out `DAI`. \r\n  * When the contract calls out to the attackers `mooniswap` contract the call to `IERC20[] memory tokens = mooniswap.getTokens();` returns the address of the token to be stolen (e.g. `DAI`) instead of the attacker-controlled token (`ATTK`) that was used to set-up the balance records.\r\n  * Subsequently, the valuable target tokens (`DAI`) are sent out to the caller in `_transferTokenShare`.\r\n\r\n\n**code/contracts/ReferralFeeReceiver.sol:L153-L162**\n```solidity\nif (share > 0) {\n    EpochBalance storage epochBalance = token.epochBalance[firstUnprocessedEpoch];\n    uint256 totalSupply = epochBalance.totalSupply;\n    user.share[mooniswap][firstUnprocessedEpoch] = 0;\n    epochBalance.totalSupply = totalSupply.sub(share);\n\n    IERC20[] memory tokens = mooniswap.getTokens();\n    epochBalance.token0Balance = _transferTokenShare(tokens[0], epochBalance.token0Balance, share, totalSupply);\n    epochBalance.token1Balance = _transferTokenShare(tokens[1], epochBalance.token1Balance, share, totalSupply);\n    epochBalance.inchBalance = _transferTokenShare(inchToken, epochBalance.inchBalance, share, totalSupply);\n```\n\r\n#### Recommendation\r\n\r\nEnforce that the user-provided `mooniswap` contract was actually deployed by the linked factory. Other contracts cannot be trusted. Consider implementing token sorting and de-duplication (tokenA!=tokenB) in the pool contract constructor as well. Consider employing a reentrancy guard to safeguard the contract from reentrancy attacks.\r\n\r\nImprove testing. The methods mentioned here are not covered at all. Improve documentation and provide a specification that outlines how this contract is supposed to be used.\r\n\r\nReview the \"additional notes\" provided with this issue.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/"
    }
  },
  {
    "title": "The `uniTransferFrom` function can potentially be used with invalid params",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe system is using the `UniERC20` contract to incapsulate transfers of both ERC-20 tokens and ETH. This contract has `uniTransferFrom` function that can be used for any ERC-20 or ETH:\r\n\r\n\n**code/contracts/libraries/UniERC20.sol:L36-L48**\n```solidity\nfunction uniTransferFrom(IERC20 token, address payable from, address to, uint256 amount) internal {\n    if (amount > 0) {\n        if (isETH(token)) {\n            require(msg.value >= amount, \"UniERC20: not enough value\");\n            if (msg.value > amount) {\n                // Return remainder if exist\n                from.transfer(msg.value.sub(amount));\n            }\n        } else {\n            token.safeTransferFrom(from, to, amount);\n        }\n    }\n}\n```\n\r\nIn case if the function is called for the normal ERC-20 token, everything works as expected. The tokens are transferred from the `from` address to the `to` address.  If the token is ETH - the transfer is expected to be from the `msg.sender` to `this` contract. Even if the `to` and `from` parameters are different. \r\n\r\nThis issue's severity is not high because the function is always called with the proper parameters in the current codebase.\r\n\r\n#### Recommendation\r\n\r\nMake sure that the `uniTransferFrom` function is always called with expected parameters.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/"
    }
  },
  {
    "title": "The owner can borrow token0/token1 in the `rescueFunds`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nIf some random tokens/funds are accidentally transferred to the pool, the `owner` can call the `rescueFunds` function to withdraw any funds manually:\r\n\r\n\n**code/contracts/Mooniswap.sol:L331-L340**\n```solidity\nfunction rescueFunds(IERC20 token, uint256 amount) external nonReentrant onlyOwner {\n    uint256 balance0 = token0.uniBalanceOf(address(this));\n    uint256 balance1 = token1.uniBalanceOf(address(this));\n\n    token.uniTransfer(msg.sender, amount);\n\n    require(token0.uniBalanceOf(address(this)) >= balance0, \"Mooniswap: access denied\");\n    require(token1.uniBalanceOf(address(this)) >= balance1, \"Mooniswap: access denied\");\n    require(balanceOf(address(this)) >= _BASE_SUPPLY, \"Mooniswap: access denied\");\n}\n```\n\r\nThere's no restriction on which funds the `owner` can try to withdraw and which token to call. It's theoretically possible to transfer pool tokens and then return them to the contract (e.g. in the case of ERC-777). That action would be similar to a free flash loan.\r\n\r\n#### Recommendation\r\n\r\nExplicitly check that the `token` is not equal to any of the pool tokens.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/1inch-liquidity-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/12/1inch-liquidity-protocol/"
    }
  },
  {
    "title": "Evaluate all tokens prior to inclusion in the system",
    "severity": null,
    "body": "Each `gToken` is concerned with many underlying 3rd-party tokens, and may be dependent on them conforming to the ERC20 standard. Although most token interactions use OpenZeppelin's `SafeERC20` library, this library only protects against the more common deviations from the ERC20 standard.\r\n\r\nReview current and future tokens in the system for non-standard behavior. [This](https://consensys.net/diligence/blog/2020/11/token-interaction-checklist/) is a helpful resource outlining known non-standard behaviors. Also consider using [`slither-check-erc`](https://github.com/crytic/building-secure-contracts/blob/master/development-guidelines/token_integration.md). \r\n\r\nParticularly dangerous functionality to look for includes a callback (ie. ERC777) which would enable an attacker to execute potentially arbitrary code during the transaction, fees on transfers, or inflationary/deflationary tokens.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/growth-defi-v1/",
      "repo": "https://consensys.net//diligence/audits/2020/12/growth-defi-v1/",
      "url": "https://consensys.net//diligence/audits/2020/12/growth-defi-v1/"
    }
  },
  {
    "title": "Avoid 'shallow' wrapper functions where possible",
    "severity": null,
    "body": "#### Description\r\n\r\nThe codebase contains many instances where calls to one library simply forward calls to another library with no additional logic. \r\n\r\nFor example:\r\n\r\n* `Transfers._getBalance(token)` obfuscates a simple call to `ERC20(token).balanceOf(address(this))`. The fact that `address(this)` is the balance being queried is obfuscated by this shallow wrapper.\r\n* `Transfers._pullFunds` and `Transfers._pushFunds` wrap `SafeERC20.safeTransferFrom` and `SafeERC20.safeTransfer`, respectively. They also obfuscate the optimization `if (_amount == 0) return`. This is helpful for gas optimization, but whether or not an external call is being made is crucial information that belongs at the call site.\r\n\r\nAnother example is the use of the `G` library, as in this call to `G.min`\r\n\r\n\n**code/contracts/GCTokenBase.sol:L226**\n```solidity\n_underlyingCost = G.min(_underlyingCost, GC.getLendAmount(reserveToken));\n```\n\r\nwhich simply calls `Math.min`:\r\n\r\n\n**code/contracts/G.sol:L21-L23**\n```solidity\nlibrary G\n{\n\tfunction min(uint256 _amount1, uint256 _amount2) public pure returns (uint256 _minAmount) { return Math._min(_amount1, _amount2); }\n```\n\r\nThe result is that the reader is subjected to frequent context switching in order to understand the actual implementation.",
    "dataSource": {
      "name": "/diligence/audits/2020/12/growth-defi-v1/",
      "repo": "https://consensys.net//diligence/audits/2020/12/growth-defi-v1/",
      "url": "https://consensys.net//diligence/audits/2020/12/growth-defi-v1/"
    }
  },
  {
    "title": "`UniswapFeature`: Non-static call to `ERC20.allowance()`",
    "severity": "minor",
    "body": "#### Description\r\nIn the case where a token is possibly \"greedy\" (consumes all gas on failure), `UniswapFeature` makes a call to the token's `allowance()` function to check whether the user has provided a token allowance to the protocol proxy or to the `AllowanceTarget`. This call is made using `call()`, potentially allowing state-changing operations to take place before control of the execution returns to `UniswapFeature`.\r\n\r\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L373-L377**\n```solidity\n// `token.allowance()``\nmstore(0xB00, ALLOWANCE_CALL_SELECTOR_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n```\n\r\n#### Recommendation\r\nReplace the `call()` with a `staticcall()`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/12/0x-exchange-v4/",
      "repo": "https://consensys.net//diligence/audits/2020/12/0x-exchange-v4/",
      "url": "https://consensys.net//diligence/audits/2020/12/0x-exchange-v4/"
    }
  },
  {
    "title": "`UniswapFeature`: Unchecked `returndatasize` in low-level external calls",
    "severity": "minor",
    "body": "#### Description\r\n`UniswapFeature` makes a number of external calls from low-level assembly code. Two of these calls rely on the `CALL` opcode to copy the returndata to memory without checking that the call returned the expected amount of data. Because the `CALL` opcode does not zero memory if the call returns less data than expected, this can lead to usage of dirty memory under the assumption that it is data returned from the most recent call.\r\n\r\n#### Examples\r\n* Call to `UniswapV2Pair.getReserves()`\r\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L201-L205**\n```solidity\n// Call pair.getReserves(), store the results at `0xC00`\nmstore(0xB00, UNISWAP_PAIR_RESERVES_CALL_SELECTOR_32)\nif iszero(staticcall(gas(), pair, 0xB00, 0x4, 0xC00, 0x40)) {\n    bubbleRevert()\n}\n```\n\r\n* Call to `ERC20.allowance()`\r\n\n**code/contracts/zero-ex/contracts/src/features/UniswapFeature.sol:L372-L377**\n```solidity\n// Check if we have enough direct allowance by calling\n// `token.allowance()``\nmstore(0xB00, ALLOWANCE_CALL_SELECTOR_32)\nmstore(0xB04, caller())\nmstore(0xB24, address())\nlet success := call(gas(), token, 0, 0xB00, 0x44, 0xC00, 0x20)\n```\n\r\n#### Recommendation\r\n\r\nInstead of providing a memory range for `call()` to write returndata to, explicitly check `returndatasize()` after the call is made and then copy the data into memory using `returndatacopy()`.\r\n\r\n```solidity\r\nif lt(returndatasize(), EXPECTED_SIZE) { \r\n    revert(0, 0) \r\n} \r\nreturndatacopy(0xC00, 0x00, EXPECTED_SIZE)\r\n```\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/12/0x-exchange-v4/",
      "repo": "https://consensys.net//diligence/audits/2020/12/0x-exchange-v4/",
      "url": "https://consensys.net//diligence/audits/2020/12/0x-exchange-v4/"
    }
  },
  {
    "title": "Where possible, functions should accept a specific contract type rather than `address` parameters",
    "severity": null,
    "body": "#### Description\r\n\r\nRather than accepting address parameters and then casting to the known contract type, it is better to use the most specific type possible so the compiler can check for type safety. Typecasting inside the corpus of a function is unneeded when the type of the parameter is known beforehand.\r\n\r\n#### Examples\r\n\r\nThere are more cases like this but here are some examples:\r\n\r\n* `address erc721` -> `IERC721 erc721`\r\n\r\n\n**code/loot-box/contracts/LootBoxController.sol:L49-L62**\n```solidity\nfunction plunder(\n  address erc721,\n  uint256 tokenId,\n  IERC20[] calldata erc20s,\n  LootBox.WithdrawERC721[] calldata erc721s,\n  LootBox.WithdrawERC1155[] calldata erc1155s\n) external {\n  address payable owner = payable(IERC721(erc721).ownerOf(tokenId));\n  LootBox lootBoxAction = _createLootBox(erc721, tokenId);\n  lootBoxAction.plunder(erc20s, erc721s, erc1155s, owner);\n  lootBoxAction.destroy(owner);\n\n  emit Plundered(erc721, tokenId, msg.sender);\n}\n```\n\r\n\n**code/loot-box/contracts/LootBoxController.sol:L21-L24**\n```solidity\nevent Plundered(address indexed erc721, uint256 indexed tokenId, address indexed operator);\n\n/// @notice Emitted when a Loot Box is executed\nevent Executed(address indexed erc721, uint256 indexed tokenId, address indexed operator);\n```\n\r\n\n**code/loot-box/contracts/LootBoxController.sol:L70-L75**\n```solidity\nfunction executeCalls(\n  address erc721,\n  uint256 tokenId,\n  LootBox.Call[] calldata calls\n) external returns (bytes[] memory) {\n  address payable owner = payable(IERC721(erc721).ownerOf(tokenId));\n```\n\r\n* `address indexed token` -> `IERC721 indexed token` etc. to avoid typecasts in `_withdraw*` functions\r\n\r\n\n**code/loot-box/contracts/LootBox.sol:L38-L44**\n```solidity\nevent WithdrewERC20(address indexed token, uint256 amount);\n\n/// @notice Emitted when an ERC721 token is withdrawn\nevent WithdrewERC721(address indexed token, uint256[] tokenIds);\n\n/// @notice Emitted when an ERC1155 token is withdrawn\nevent WithdrewERC1155(address indexed token, uint256[] ids, uint256[] amounts, bytes data);\n```\n\r\n* MultipleWinners\r\n\r\n\n**code/pool/contracts/builders/MultipleWinnersBuilder.sol:L43-L43**\n```solidity\nemit CreatedMultipleWinners(address(prizeStrategy), address(mw), numberOfWinners);\n```\n\r\n* `PeriodicPrizeStrategy` - `ticket`, `sponsorship`\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L141-L143**\n```solidity\nticket = TicketInterface(_ticket);\nrng = _rng;\nsponsorship = IERC20(_sponsorship);\n```\n\r\n#### Recommendation\r\n\r\nReview the complete codebase and, where possible, use more specific types instead of `address`. ",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "LootBox - Unprotected selfdestruct in proxy implementation",
    "severity": "critical",
    "body": "#### Description\r\n\r\nWhen the `LootBoxController` is deployed, it also deploys an instance of `LootBox`. When someone calls `LootBoxController.plunder()` or `LootBoxController.executeCall()` the controller actually deploys a temporary proxy contract to a deterministic address using `create2`, then calls out to it to collect the loot. \r\n\r\nThe `LootBox` implementation contract is completely unprotected, exposing all its functionality to any actor on the blockchain. The most critical functionality is actually the `LootBox.destroy()` method that calls `selfdestruct()` on the implementation contract.\r\n\r\nTherefore, an unauthenticated user can `selfdestruct` the `LootBox` proxy implementation and cause the complete system to become dysfunctional. As an effect, none of the AirDrops that were delivered based on this contract will be redeemable (Note: `create2` deploy address is calculated from the current contract address and salt). Funds may be lost.\r\n\r\n\r\n#### Examples\r\n\r\n\n**code/loot-box/contracts/LootBoxController.sol:L28-L31**\n```solidity\nconstructor () public {\n  lootBoxActionInstance = new LootBox();\n  lootBoxActionBytecode = MinimalProxyLibrary.minimalProxy(address(lootBoxActionInstance));\n}\n```\n\r\n\n**code/loot-box/contracts/LootBox.sol:L86-L90**\n```solidity\n/// @notice Destroys this contract using `selfdestruct`\n/// @param to The address to send remaining Ether to\nfunction destroy(address payable to) external {\n  selfdestruct(to);\n}\n```\n\r\n* not in scope but listed for completeness\r\n\r\n\n**code/pool/contracts/counterfactual-action/CounterfactualAction.sol:L7-L21**\n```solidity\n\ncontract CounterfactualAction {\n  function depositTo(address payable user, PrizePool prizePool, address output, address referrer) external {\n    IERC20 token = IERC20(prizePool.token());\n    uint256 amount = token.balanceOf(address(this));\n    token.approve(address(prizePool), amount);\n    prizePool.depositTo(user, amount, output, referrer);\n    selfdestruct(user);\n  }\n\n  function cancel(address payable user, PrizePool prizePool) external {\n    IERC20 token = IERC20(prizePool.token());\n    token.transfer(user, token.balanceOf(address(this)));\n    selfdestruct(user);\n  }\n```\n\r\n#### Recommendation\r\n\r\nEnforce that only the deployer of the contract can call functionality in the contract. Make sure that nobody can destroy the implementation of proxy contracts.",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "PeriodicPriceStrategy - `trustedForwarder` can impersonate any `msg.sender`",
    "severity": "major",
    "body": "#### Description\r\n\r\nThe `trustedForwarder` undermines the trust assumptions in the system. For example, one would assume that the access control modifier `onlyPrizePool` would only allow the configured `PrizePool` to call certain methods. However, in reality, the `trustedForwarder` can assume this position as well. The same is true for the `onlyOwnerOrListener` modifier. One would assume `msg.sender` must either be `periodicPrizeStrategyListener` or `owner` (the initial deployer) while the `trustedForwarder` can assume any of the administrative roles.\r\n\r\nThe centralization of power to allow one account to impersonate other components and roles (`owner`, `listener`, `prizePool`) in the system is a concern by itself and may give users pause when deciding whether to trust the contract system. The fact that the `trustedForwarder` can spoof events for any `msg.sender` may also make it hard to keep an accurate log trail of events in case of a security incident.\r\n\r\n\r\n**Note**: The same functionality seems to be used in `ControlledToken` and other contracts which allows the `trustedForwarder` to assume any tokenholder in `ERC20UpgradeSafe`. There is practically no guarantee to `ControlledToken` holders. \r\n\r\n**Note**: The `trustedForwarder`/`msgSender()` pattern is used in multiple contracts, many of which are not in the scope of this assessment.\r\n\r\n#### Examples\r\n\r\n* access control modifiers that can be impersonated\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L588-L591**\n```solidity\nmodifier onlyPrizePool() {\n  require(_msgSender() == address(prizePool), \"PeriodicPrizeStrategy/only-prize-pool\");\n  _;\n}\n```\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L565-L568**\n```solidity\nmodifier onlyOwnerOrListener() {\n  require(_msgSender() == owner() || _msgSender() == address(periodicPrizeStrategyListener), \"PeriodicPrizeStrategy/only-owner-or-listener\");\n  _;\n}\n```\n\r\n* event `msg.sender` that can be spoofed because the actual `msg.sender` can be `trustedForwarder`\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L164-L164**\n```solidity\nemit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n```\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L340-L340**\n```solidity\nemit PrizePoolAwardStarted(_msgSender(), address(prizePool), requestId, lockBlock);\n```\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L356-L357**\n```solidity\nemit PrizePoolAwarded(_msgSender(), randomNumber);\nemit PrizePoolOpened(_msgSender(), prizePeriodStartedAt);\n```\n\r\n\r\n* `_msgSender()` implementation allows the `trustedForwarder` to impersonate any `msg.sender` address\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L541-L551**\n```solidity\n/// @dev Provides information about the current execution context for GSN Meta-Txs.\n/// @return The payable address of the message sender\nfunction _msgSender()\n  internal\n  override(BaseRelayRecipient, ContextUpgradeSafe)\n  virtual\n  view\n  returns (address payable)\n{\n  return BaseRelayRecipient._msgSender();\n}\n```\n\r\n```solidity\r\n// File: @opengsn/gsn/contracts/BaseRelayRecipient.sol\r\n\r\n...\r\n\r\n   /**\r\n     * return the sender of this call.\r\n     * if the call came through our trusted forwarder, return the original sender.\r\n     * otherwise, return `msg.sender`.\r\n     * should be used in the contract anywhere instead of msg.sender\r\n     */\r\n    function _msgSender() internal override virtual view returns (address payable ret) {\r\n        if (msg.data.length >= 24 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // so we trust that the last bytes of msg.data are the verified sender address.\r\n            // extract sender address from the end of msg.data\r\n            assembly {\r\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        } else {\r\n            return msg.sender;\r\n        }\r\n    }\r\n```\r\n\r\n#### Recommendation\r\n\r\nRemove the `trustedForwarder` or restrict the type of actions the forwarder can perform and don't allow it to impersonate other components in the system. Make sure users understand the trust assumptions and who has what powers in the system. Make sure to keep an accurate log trail of who performed which action on whom's behalf. \r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "Unpredictable behavior for users due to admin front running or general bad timing",
    "severity": "major",
    "body": "#### Description\r\n\r\nIn a number of cases, administrators of contracts can update or upgrade things in the system without warning. This has the potential to violate a security goal of the system.\r\n\r\nSpecifically, privileged roles could use front running to make malicious changes just ahead of incoming transactions, or purely accidental negative effects could occur due to unfortunate timing of changes.\r\n\r\nIn general users of the system should have assurances about the behavior of the action they're about to take.\r\n\r\n#### Examples\r\n\r\nAn administrator (deployer) of `MultipleWinners` can change the number of winners in the system without warning. This has the potential to violate a security goal of the system.\r\n\r\n* admin can change the number of winners during a prize-draw period\r\n\r\n\n**code/pool/contracts/prize-strategy/multiple-winners/MultipleWinners.sol:L38-L42**\n```solidity\nfunction setNumberOfWinners(uint256 count) external onlyOwner {\n  __numberOfWinners = count;\n\n  emit NumberOfWinnersSet(count);\n}\n```\n\r\n* `PeriodicPriceStrategy` - admin may switch-out RNG service at any time (when RNG is not in inflight or timed-out)\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L413-L418**\n```solidity\nfunction setRngService(RNGInterface rngService) external onlyOwner {\n  require(!isRngRequested(), \"PeriodicPrizeStrategy/rng-in-flight\");\n\n  rng = rngService;\n  emit RngServiceUpdated(address(rngService));\n}\n```\n\r\n* `PeriodicPriceStrategy` - admin can effectively disable the rng request timeout by setting a high value during a prize-draw (e.g. to indefinitely block payouts)\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L420-L422**\n```solidity\nfunction setRngRequestTimeout(uint32 _rngRequestTimeout) external onlyOwner {\n  _setRngRequestTimeout(_rngRequestTimeout);\n}\n```\n\r\n* `PeriodicPriceStrategy` - admin may set new tokenListener which might intentionally block token-transfers\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L175-L179**\n```solidity\nfunction setTokenListener(TokenListenerInterface _tokenListener) external onlyOwner {\n  tokenListener = _tokenListener;\n\n  emit TokenListenerUpdated(address(tokenListener));\n}\n```\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L360-L364**\n```solidity\nfunction setPeriodicPrizeStrategyListener(address _periodicPrizeStrategyListener) external onlyOwner {\n  periodicPrizeStrategyListener = PeriodicPrizeStrategyListener(_periodicPrizeStrategyListener);\n\n  emit PeriodicPrizeStrategyListenerSet(_periodicPrizeStrategyListener);\n}\n```\n\r\n* out of scope but mentioned as a relevant example: `PrizePool` owner can set new `PrizeStrategy` at any time\r\n\r\n\n**code/pool/contracts/prize-pool/PrizePool.sol:L1003-L1008**\n```solidity\n/// @notice Sets the prize strategy of the prize pool.  Only callable by the owner.\n/// @param _prizeStrategy The new prize strategy\nfunction setPrizeStrategy(address _prizeStrategy) external override onlyOwner {\n  _setPrizeStrategy(TokenListenerInterface(_prizeStrategy));\n}\n\n```\n\r\n* a malicious admin may remove all external ERC20/ERC721 token awards prior to the user claiming them (admin front-running opportunity)\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L461-L464**\n```solidity\nfunction removeExternalErc20Award(address _externalErc20, address _prevExternalErc20) external onlyOwner {\n  externalErc20s.removeAddress(_prevExternalErc20, _externalErc20);\n  emit ExternalErc20AwardRemoved(_externalErc20);\n}\n```\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L506-L510**\n```solidity\nfunction removeExternalErc721Award(address _externalErc721, address _prevExternalErc721) external onlyOwner {\n  externalErc721s.removeAddress(_prevExternalErc721, _externalErc721);\n  delete externalErc721TokenIds[_externalErc721];\n  emit ExternalErc721AwardRemoved(_externalErc721);\n}\n```\n\r\n* the `PeriodicPrizeStrategy` `owner` (also see concerns outlined in 12) can transfer external ERC20 at any time to avoid them being awarded to users. there is no guarantee to the user.\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L517-L526**\n```solidity\nfunction transferExternalERC20(\n  address to,\n  address externalToken,\n  uint256 amount\n)\n  external\n  onlyOwner\n{\n  prizePool.transferExternalERC20(to, externalToken, amount);\n}\n```\n\r\n#### Recommendation\r\n\r\nThe underlying issue is that users of the system can't be sure what the behavior of a function call will be, and this is because the behavior can change at any time.\r\n\r\nWe recommend giving the user advance notice of changes with a time lock. For example, make all system-parameter and upgrades require two steps with a mandatory time window between them. The first step merely broadcasts to users that a particular change is coming, and the second step commits that change after a suitable waiting period. This allows users that do not accept the change to withdraw immediately.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "PeriodicPrizeStrategy - Token with callback related warnings (`ERC777` a.o.)",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThis issue is highly dependent on the configuration of the system. If an admin decides to allow callback enabled token (e.g. `ERC20` compliant `ERC777` or other `ERC721`/`ERC20` extensions) as awards then one recipient may be able to \r\n\r\n* block the payout for everyone by forcing a revert in the callback when accepting token awards\r\n* use the callback to siphon gas, mint gas token, or similar activities\r\n* potentially re-enter the `PrizeStrategy` contract in an attempt to manipulate the payout (e.g. by immediately withdrawing from the pool to manipulate the 2nd `ticket.draw()`)\r\n\r\n#### Examples\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L252-L263**\n```solidity\nfunction _awardExternalErc721s(address winner) internal {\n  address currentToken = externalErc721s.start();\n  while (currentToken != address(0) && currentToken != externalErc721s.end()) {\n    uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));\n    if (balance > 0) {\n      prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);\n      delete externalErc721TokenIds[currentToken];\n    }\n    currentToken = externalErc721s.next(currentToken);\n  }\n  externalErc721s.clearAll();\n}\n```\n\r\n#### Recommendation\r\n\r\nIt is highly recommended to not allow tokens with callback functionality into the system. Document and/or implement safeguards that disallow the use of callback enabled tokens. Consider implementing means for the \"other winners\" to withdraw their share of the rewards independently from others.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "PeriodicPrizeStrategy - unbounded external tokens linked list may be used to force a gas DoS",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe size of the linked list of ERC20/ERC721 token awards is not limited. This fact may be exploited by an administrative account by adding an excessive number of external token addresses.\r\n\r\nThe winning user might want to claim their win by calling `completeAward()` which fails in one of the `_distribute() -> _awardAllExternalTokens() ->  _awardExternalErc20s/_awardExternalErc721s` while loops if too many token addresses are configured and gas consumption hits the block gas limit (or it just gets too expensive for the user to call).\r\n\r\nNote: an admin can recover from this situation by removing items from the list.\r\n\r\n#### Examples\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L436-L448**\n```solidity\n/// @notice Adds an external ERC20 token type as an additional prize that can be awarded\n/// @dev Only the Prize-Strategy owner/creator can assign external tokens,\n/// and they must be approved by the Prize-Pool\n/// @param _externalErc20 The address of an ERC20 token to be awarded\nfunction addExternalErc20Award(address _externalErc20) external onlyOwnerOrListener {\n  _addExternalErc20Award(_externalErc20);\n}\n\nfunction _addExternalErc20Award(address _externalErc20) internal {\n  require(prizePool.canAwardExternal(_externalErc20), \"PeriodicPrizeStrategy/cannot-award-external\");\n  externalErc20s.addAddress(_externalErc20);\n  emit ExternalErc20AwardAdded(_externalErc20);\n}\n```\n\r\n\n**code/pool/contracts/utils/MappedSinglyLinkedList.sol:L46-L53**\n```solidity\n/// @param newAddress The address to shift to the front of the list\nfunction addAddress(Mapping storage self, address newAddress) internal {\n  require(newAddress != SENTINEL && newAddress != address(0), \"Invalid address\");\n  require(self.addressMap[newAddress] == address(0), \"Already added\");\n  self.addressMap[newAddress] = self.addressMap[SENTINEL];\n  self.addressMap[SENTINEL] = newAddress;\n  self.count = self.count + 1;\n}\n```\n\r\n* awarding the tokens loops through the linked list of configured tokens\r\n\r\n\n**code/pool/contracts/prize-strategy/PeriodicPrizeStrategy.sol:L248-L263**\n```solidity\n/// @notice Awards all external ERC721 tokens to the given user.\n/// The external tokens must be held by the PrizePool contract.\n/// @dev The list of ERC721s is reset after every award\n/// @param winner The user to transfer the tokens to\nfunction _awardExternalErc721s(address winner) internal {\n  address currentToken = externalErc721s.start();\n  while (currentToken != address(0) && currentToken != externalErc721s.end()) {\n    uint256 balance = IERC721(currentToken).balanceOf(address(prizePool));\n    if (balance > 0) {\n      prizePool.awardExternalERC721(winner, currentToken, externalErc721TokenIds[currentToken]);\n      delete externalErc721TokenIds[currentToken];\n    }\n    currentToken = externalErc721s.next(currentToken);\n  }\n  externalErc721s.clearAll();\n}\n```\n\r\n#### Recommendation\r\n\r\nLimit the number of tokens an admin can add. Consider implementing an interface that allows the user to claim tokens one-by-one or in user-configured batches.",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "LootBox - `plunder` should disallow plundering to `address(0)`",
    "severity": "medium",
    "body": "#### Description\r\n\r\nAnyone can call `LootboxController.plunder()` to plunder on behalf of a `tokenId` owner. If a `LootBox` received an AirDrop but no `NFT` was issued to an owner (yet) this might open up an opportunity for a malicious actor to call `plunder()` in an attempt to burn the ETH and any airdropped tokens that allow transfers to `address(0)`.\r\n\r\nNote: \r\n\r\n* Depending on the token implementation, transfers may or may not revert if the `toAddress == address(0)`, while burning the `ETH` will succeed.\r\n* This might allow anyone to  forcefully burn received ETH that would otherwise be available to the future beneficiary\r\n* If the airdrop and transfer of `LootBox` ownership are not done within one transaction, this might open up a front-running window that allows a third party to burn air-dropped ETH before it can be claimed by the owner.\r\n  * consider one component issues the airdrop in one transaction (or block) and setting the owner in a later transaction (or block). The `owner` is unset for a short duration of time which might allow anyone to burn `ETH` held by the `LootBox` proxy instance.\r\n\r\n#### Examples\r\n\r\n* `plunder()` receiving the `owner` of an `ERC721.tokenId`\r\n\r\n\n**code/loot-box/contracts/LootBoxController.sol:L49-L56**\n```solidity\nfunction plunder(\n  address erc721,\n  uint256 tokenId,\n  IERC20[] calldata erc20s,\n  LootBox.WithdrawERC721[] calldata erc721s,\n  LootBox.WithdrawERC1155[] calldata erc1155s\n) external {\n  address payable owner = payable(IERC721(erc721).ownerOf(tokenId));\n```\n\r\n* The modified `ERC721` returns `address(0)` if the owner is not known\r\n\r\n\n**code/loot-box/contracts/external/openzeppelin/ERC721.sol:L102-L107**\n```solidity\n * @dev See {IERC721-ownerOf}.\n */\nfunction ownerOf(uint256 tokenId) public view override returns (address) {\n    return _tokenOwners[tokenId];\n}\n\n```\n\r\n* While `withdraw[ERC20|ERC721|ERC1155]` fail with `to == address(0)`, `transferEther()` succeeds and burns the eth by sending it to  `address(0)`\r\n\r\n\n**code/loot-box/contracts/LootBox.sol:L74-L84**\n```solidity\nfunction plunder(\n  IERC20[] memory erc20,\n  WithdrawERC721[] memory erc721,\n  WithdrawERC1155[] memory erc1155,\n  address payable to\n) external {\n  _withdrawERC20(erc20, to);\n  _withdrawERC721(erc721, to);\n  _withdrawERC1155(erc1155, to);\n  transferEther(to, address(this).balance);\n}\n```\n\r\n#### Recommendation\r\n\r\nRequire that the destination address `to` in `plunder()` and `transferEther()` is not `address(0)`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/",
      "url": "https://consensys.net//diligence/audits/2020/11/pooltogether-lootbox-and-multiplewinners-strategy/"
    }
  },
  {
    "title": "ERC20 tokens with no return value will fail to transfer",
    "severity": "major",
    "body": "#### Description\r\n\r\nAlthough the ERC20 standard suggests that a transfer should return `true` on success, many tokens are non-compliant in this regard. \r\n\r\nIn that case, the `.transfer()` call here will revert even if the transfer is successful, because solidity will check that the RETURNDATASIZE matches the ERC20 interface.\r\n\r\n\n**code/contracts/ExchangeDeposit.sol:L229-L231**\n```solidity\nif (!instance.transfer(getSendAddress(), forwarderBalance)) {\n    revert('Could not gather ERC20');\n}\n```\n\r\n#### Recommendation\r\n\r\nConsider using [OpenZeppelin's SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/SafeERC20.sol).\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/bitbank/",
      "repo": "https://consensys.net//diligence/audits/2020/11/bitbank/",
      "url": "https://consensys.net//diligence/audits/2020/11/bitbank/"
    }
  },
  {
    "title": "Attacker can abuse `swapLiquidity` function to drain users' funds",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe `swapLiquidity` function allows liquidity providers to atomically swap their collateral. The function takes \r\na `receiverAddress`argument that normally points to an `ISwapAdapter` implementation trusted by the user.\r\n\r\n\n**code/contracts/lendingpool/LendingPoolCollateralManager.sol:L490-L517**\n```solidity\nvars.fromReserveAToken.burn(\n  msg.sender,\n  receiverAddress,\n  amountToSwap,\n  fromReserve.liquidityIndex\n);\n// Notifies the receiver to proceed, sending as param the underlying already transferred\nISwapAdapter(receiverAddress).executeOperation(\n  fromAsset,\n  toAsset,\n  amountToSwap,\n  address(this),\n  params\n);\n\nvars.amountToReceive = IERC20(toAsset).balanceOf(receiverAddress);\nif (vars.amountToReceive != 0) {\n  IERC20(toAsset).transferFrom(\n    receiverAddress,\n    address(vars.toReserveAToken),\n    vars.amountToReceive\n  );\n\n  if (vars.toReserveAToken.balanceOf(msg.sender) == 0) {\n    _usersConfig[msg.sender].setUsingAsCollateral(toReserve.id, true);\n  }\n\n  vars.toReserveAToken.mint(msg.sender, vars.amountToReceive, toReserve.liquidityIndex);\n```\n\r\nHowever, since an attacker can pass any address as the `receiverAddress`, they can arbitrarily transfer funds from other contracts that have given allowances to the `LendingPool` contract (for example, another `ISwapAdapter`).  \r\n\r\nThe `amountToSwap` is defined by the caller and can be very small. The attacker gets the difference between `IERC20(toAsset).balanceOf(receiverAddress)` value of `toAsset` and the `amountToSwap` of `fromToken`.\r\n\r\n#### Remediation\r\n\r\nEnsure that no funds can be stolen from contracts that have granted allowances to the `LendingPool` contract. \r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/09/aave-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/"
    }
  },
  {
    "title": "Unhandled return values of transfer and transferFrom",
    "severity": "medium",
    "body": "ERC20 implementations are not always consistent. Some implementations of `transfer` and `transferFrom` could return 'false' on failure instead of reverting. It is safer to wrap such calls into `require()` statements to these failures. Unsafe `transferFrom` calls were found in the following locations:\r\n\r\n\n**code/contracts/lendingpool/LendingPool.sol:L578**\n```solidity\nIERC20(asset).transferFrom(receiverAddress, vars.aTokenAddress, vars.amountPlusPremium);\n```\n\r\n\n**code/contracts/lendingpool/LendingPoolCollateralManager.sol:L407**\n```solidity\nIERC20(principal).transferFrom(receiver, vars.principalAToken, vars.actualAmountToLiquidate);\n```\n\r\n\n**code/contracts/lendingpool/LendingPoolCollateralManager.sol:L507-L511**\n```solidity\nIERC20(toAsset).transferFrom(\n  receiverAddress,\n  address(vars.toReserveAToken),\n  vars.amountToReceive\n);\n```\n\r\n**Recommendation**\r\n\r\nCheck the return value and revert on `0`/`false` or use OpenZeppelin's `SafeERC20` wrapper functions.",
    "dataSource": {
      "name": "/diligence/audits/2020/09/aave-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/"
    }
  },
  {
    "title": "Re-entrancy attacks with ERC-777",
    "severity": "minor",
    "body": "#### Description\r\n\r\nSome tokens may allow users to perform re-entrancy while calling the `transferFrom` function. For example, it would be possible for an attacker to \"borrow\" a large amount of ERC-777 tokens from the lending pool by re-entering the `deposit` function from within `transferFrom`.\r\n\r\n\n**code/contracts/lendingpool/LendingPool.sol:L91-L118**\n```solidity\nfunction deposit(\n  address asset,\n  uint256 amount,\n  address onBehalfOf,\n  uint16 referralCode\n) external override {\n  _whenNotPaused();\n  ReserveLogic.ReserveData storage reserve = _reserves[asset];\n\n  ValidationLogic.validateDeposit(reserve, amount);\n\n  address aToken = reserve.aTokenAddress;\n\n  reserve.updateState();\n  reserve.updateInterestRates(asset, aToken, amount, 0);\n\n  bool isFirstDeposit = IAToken(aToken).balanceOf(onBehalfOf) == 0;\n  if (isFirstDeposit) {\n    _usersConfig[onBehalfOf].setUsingAsCollateral(reserve.id, true);\n  }\n\n  IAToken(aToken).mint(onBehalfOf, amount, reserve.liquidityIndex);\n\n  //transfer to the aToken contract\n  IERC20(asset).safeTransferFrom(msg.sender, aToken, amount);\n\n  emit Deposit(asset, msg.sender, onBehalfOf, amount, referralCode);\n}\n```\n\r\nBecause the `safeTransferFrom` call is happening at the end of the `deposit` function, the deposit will be fully processed before the tokens are actually transferred.\r\n\r\nSo at the beginning of the transfer, the attacker can re-enter the call to withdraw their deposit. The withdrawal will succeed even though the attacker's tokens have not yet been transferred to the lending pool. Essentially, the attacker is granted a flash-loan but without paying fees.\r\n\r\nAdditionally, after these calls, interest rates will be skewed because interest rate update relies on the actual current balance.\r\n\r\n#### Remediation\r\n\r\nDo not whitelist ERC-777 or other re-entrable tokens to prevent this kind of attack.",
    "dataSource": {
      "name": "/diligence/audits/2020/09/aave-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/"
    }
  },
  {
    "title": "Attacker can front-run delegator when changing allowance",
    "severity": "minor",
    "body": "Users can grant allowances to borrow debt assets to other users using the `delegateAllowance` function. Similar to the classical ERC20 `approve` attack, it is possible for a malicious user to front-run the delegator when they attempt to change the allowance and borrow the sum of the old and new values. \r\n\r\nExample scenario:\r\n\r\n1. Bob creates an allowance of 100 DAI for Malice: `delegateBorrowAllowance(DAI, Malice, 100)`\r\n2. Later, Bob attempts to lower the allowance to 90: `delegateBorrowAllowance(DAI, Malice, 90)`\r\n3. Malice borrows a total of 190 DAI by first frontrunning Bob's second transaction borrowing 100 DAI and then borrowing another 90 DAI after Bob's transaction was mined.\r\n\r\n**Recommentation**\r\n\r\nA commonly used way of preventing this attack is using `increaseAllowance()` and `decreaseAllowance()` functions specifically for increasing and decreasing allowances.\r\n\r\n\r\n ",
    "dataSource": {
      "name": "/diligence/audits/2020/09/aave-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/09/aave-protocol-v2/"
    }
  },
  {
    "title": "Unhandled return values of transfer and transferFrom",
    "severity": "medium",
    "body": "ERC20 implementations are not always consistent. Some implementations of `transfer` and `transferFrom` could return 'false' on failure instead of reverting. It is safer to wrap such calls into `require()` statements to these failures.\r\n\r\n\n**code/contracts/stake/StakedToken.sol:L92**\n```solidity\nIERC20(STAKED_TOKEN).transferFrom(msg.sender, address(this), amount);\n```\n\r\n\n**code/contracts/stake/StakedToken.sol:L156**\n```solidity\nREWARD_TOKEN.transferFrom(REWARDS_VAULT, to, amountToWithdraw);\n```\n\r\n\n**code/contracts/stake/StakedToken.sol:L125**\n```solidity\nIERC20(STAKED_TOKEN).transfer(to, amount);\n```\n\r\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/09/aave-safety-module/",
      "repo": "https://consensys.net//diligence/audits/2020/09/aave-safety-module/",
      "url": "https://consensys.net//diligence/audits/2020/09/aave-safety-module/"
    }
  },
  {
    "title": "Document assumptions about ERC20 tokens",
    "severity": null,
    "body": "Most ERC20-compatible tokens can be used with the `FeeDistributor` contract, but it's wise to document some assumptions made by the contract:\r\n\r\n* Token balances will not be too big (relative to the number of shares). Specifically, the total number of token units received by the contract must be able to be multiplied by the largest share amount held by a recipient.\r\n* Token balances will not be too small (relative to share amounts). It's impossible to divide a balance of 1 among more than 1 recipient. To be safe, it would be good to make sure that no one cares about losing less than `totalShares` token units. For example, if there are 1,000,000 total shares, an asset like ether would not be a problem because 1,000,000 wei is a trivial amount.\r\n* Token balances will not decrease without an explicit transfer. The contract makes the assumption that it can always compute the total received tokens by adding `tokenBalance(token)` and `_totalWithdrawn[token]`. This is not the case if the token balance can be manipulated externally.",
    "dataSource": {
      "name": "/diligence/audits/2020/08/metaswap/",
      "repo": "https://consensys.net//diligence/audits/2020/08/metaswap/",
      "url": "https://consensys.net//diligence/audits/2020/08/metaswap/"
    }
  },
  {
    "title": "Consider checking adapter existence in `MetaSwap`",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`MetaSwap` doesn't check that an adapter exists before calling into `Spender`:\r\n\r\n\n**code/contracts/MetaSwap.sol:L87-L100**\n```solidity\nfunction swap(\n    string calldata aggregatorId,\n    IERC20 tokenFrom,\n    uint256 amount,\n    bytes calldata data\n) external payable whenNotPaused nonReentrant {\n    Adapter storage adapter = adapters[aggregatorId];\n\n    if (address(tokenFrom) != Constants.ETH) {\n        tokenFrom.safeTransferFrom(msg.sender, address(spender), amount);\n    }\n\n    spender.swap{value: msg.value}(\n        adapter.addr,\n```\n\r\nThen `Spender` performs the check and reverts if it receives `address(0)`.\r\n\r\n\n**code/contracts/Spender.sol:L15-L16**\n```solidity\nfunction swap(address adapter, bytes calldata data) external payable {\n    require(adapter != address(0), \"ADAPTER_NOT_SUPPORTED\");\n```\n\r\nIt can be difficult to decide where to put a check like this, especially when the operation spans multiple contracts. Arguments can be made for either choice (or even duplicating the check), but as a general rule it's a good idea to avoid passing invalid parameters internally. Checking for adapter existence in `MetaSwap.swap()` is a natural place to do input validation, and it means `Spender` can have a simpler model where it trusts its inputs (which always come from `MetaSwap`).\r\n\r\n#### Recommendation\r\n\r\nDrop the check from `Spender.swap()` and perform the check instead in `MetaSwap.swap()`.",
    "dataSource": {
      "name": "/diligence/audits/2020/08/metaswap/",
      "repo": "https://consensys.net//diligence/audits/2020/08/metaswap/",
      "url": "https://consensys.net//diligence/audits/2020/08/metaswap/"
    }
  },
  {
    "title": "Simplify accounting and better handle remainders",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe current code does some fairly complex and redundant calculations during withdrawal to keep track of various pieces of state. In particular, the pair of `_available[recipient][token]` and `_totalOnLastUpdate[recipient][token]` is difficult to describe and reason about.\r\n\r\n#### Recommendation\r\n\r\nFor a given token and recipient, we recommend instead just tracking how much has already been withdrawn. The rest can be easily calculated:\r\n\r\n```solidity\r\nfunction earned(IERC20 token, address recipient) public view returns (uint256) {\r\n    uint256 totalReceived = tokenBalance(token).add(_totalWithdrawn[token]);\r\n    return totalReceived.mul(shares[recipient]).div(totalShares);\r\n}\r\n\r\nfunction available(IERC20 token, address recipient) public view returns (uint256) {\r\n    return earned(token, recipient).sub(_withdrawn[token][recipient]);\r\n}\r\n\r\nfunction withdraw(IERC20[] calldata tokens) external {\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n        IERC20 token = tokens[i];\r\n        uint256 amount = available(token, msg.sender);\r\n\r\n        _withdrawn[token][msg.sender] += amount;\r\n        _totalWithdrawn[token] += amount;\r\n        _transfer(token, msg.sender, amount);\r\n    }\r\n    emit Withdrawal(tokens, msg.sender);\r\n}\r\n```\r\n\r\nThis code is easier to reason about:\r\n\r\n* It's easy to see that `withdrawn[token][msg.sender]` is correct because it's only increased when there's a corresponding transfer.\r\n* It's easy to see that `_totalWithdrawn[token]` is correct for the same reason.\r\n* It's easy to see that `earned()` is correct under standard assumptions about ERC20 balances.\r\n* It's easy to see that `available()` is correct, as it's just the earned amount less the already-withdrawn amount.\r\n* Remainders are better handled. If 1 token unit is available and you own half the shares, nothing happens on withdrawal, and if there are later 2 token units available, you can withdraw 1. (Under the previous code, if you tried to withdraw when 1 token unit was available, you would be unable to withdraw when 2 were available.)",
    "dataSource": {
      "name": "/diligence/audits/2020/08/metaswap/",
      "repo": "https://consensys.net//diligence/audits/2020/08/metaswap/",
      "url": "https://consensys.net//diligence/audits/2020/08/metaswap/"
    }
  },
  {
    "title": "Permit expiration can be set indefinite by using MAX_UINT",
    "severity": null,
    "body": "#### Description\r\n\r\nIn the `permit()` function, a deadline of `0` is treated as non-expiring. \r\n\n**code/contracts/token/AaveToken.sol:L114**\n```solidity\nrequire(expiration == 0 || block.timestamp <= expiration, \"INVALID_EXPIRATION\");\n```\n\r\n#### Recommendation\r\n\r\nThis extra check is unnecessary, the same can be achieved by setting the deadline to MAX_UINT.\r\nThis would also be more consistent with the [Uniswap-V2 implementation](https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol#L82) referenced in EIP-2612.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/07/aave-token/",
      "repo": "https://consensys.net//diligence/audits/2020/07/aave-token/",
      "url": "https://consensys.net//diligence/audits/2020/07/aave-token/"
    }
  },
  {
    "title": "Remove `Loihi` methods that can be used as backdoors by the administrator",
    "severity": "major",
    "body": "#### Description\r\n\r\nThere are several functions in `Loihi` that give extreme powers to the shell administrator. The most dangerous set of those is the ones granting the capability to add assimilators.\r\n\r\nSince assimilators are essentially a proxy architecture to delegate code to several different implementations of the same interface, the administrator could, intentionally or unintentionally, deploy malicious or faulty code in the implementation of an assimilator.\r\nThis means that the administrator is essentially totally trusted to not run code that, for example, drains the whole pool or locks up the users' and LPs' tokens.\r\n\r\nIn addition to these, the function `safeApprove` allows the administrator to move any of the tokens the contract holds to any address regardless of the balances any of the users have.\r\n\r\nThis can also be used by the owner as a backdoor to completely drain the contract.\r\n\r\n\n**src/Loihi.sol:L643-L649**\n```solidity\nfunction safeApprove(address _token, address _spender, uint256 _value) public onlyOwner {\n\n    (bool success, bytes memory returndata) = _token.call(abi.encodeWithSignature(\"approve(address,uint256)\", _spender, _value));\n\n    require(success, \"SafeERC20: low-level call failed\");\n\n}\n```\n\r\n#### Recommendation\r\n\r\nRemove the `safeApprove` function and, instead, use a trustless escape-hatch mechanism like the one suggested in 17.\r\n\r\nFor the assimilator addition functions, our recommendation is that they are made completely internal, only callable in the constructor, at deploy time.\r\n\r\nEven though this is not a big structural change (in fact, it _reduces_ the attack surface), it is, indeed, a feature loss. However, this is the only way to make each shell a time-invariant system.\r\n\r\nThis would not only increase Shell's security but also would greatly improve the trust the users have in the protocol since, after deployment, the code is now **static** and auditable.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/shell-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/06/shell-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/06/shell-protocol/"
    }
  },
  {
    "title": "Assimilators do not conform to the ERC20 specification",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe assimilators in the codebase make heavy usage of both the `transfer` and `transferFrom` methods in the ERC20 standard.\r\n\r\nQuoting the relevant parts of the specification of the standard:\r\n\r\n> Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The function SHOULD throw if the message caller’s account balance does not have enough tokens to spend.\r\n\r\n> The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\r\n\r\nWe can see that, even though it is suggested that ERC20-compliant tokens do `throw` on the lack of authorization from the sender or lack of funds to complete the transfer, the standard does not enforce it.\r\n\r\nThis means that, in order to make the system both more resilient and future-proof, code in each implementation of current and future assimilators should check for the return value of both `transfer` and `transferFrom` call instead of just relying on the external contract to revert execution.\r\n\r\nThe extent of this issue is only mitigated by the fact that new assets are only added by the shell administrator and could, therefore, be audited prior to their addition.\r\n\r\n#### Non-exhaustive Examples\r\n\r\n\n**src/assimilators/mainnet/daiReserves/mainnetDaiToDaiAssimilator.sol:L45**\n```solidity\ndai.transferFrom(msg.sender, address(this), _amount);\n```\n\r\n\n**src/assimilators/mainnet/daiReserves/mainnetDaiToDaiAssimilator.sol:L64**\n```solidity\ndai.transfer(_dst, _amount);\n```\n\r\n#### Recommendation\r\n\r\nAdd a check for the return boolean of the function.\r\n\r\nExample:\r\n\r\n`require(dai.transferFrom(msg.sender, address(this), _amount) == true);`\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/06/shell-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/06/shell-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/06/shell-protocol/"
    }
  },
  {
    "title": "Use one file for each contract or library",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe repository contains a lot of contracts and libraries that are added in the same file as another contract or library.\r\n\r\nOrganizing the code in this manner makes it hard to navigate, develop and audit. It is a best practice to have each contract or library in its own file. The file also needs to bear the name of the hosted contract or library.\r\n\r\n#### Examples\r\n\r\n\n**src/Shells.sol:L20**\n```solidity\nlibrary SafeERC20Arithmetic {\n```\n\r\n\n**src/Shells.sol:L32**\n```solidity\nlibrary Shells {\n```\n\r\n\n**src/Loihi.sol:L26-L28**\n```solidity\ncontract ERC20Approve {\n    function approve (address spender, uint256 amount) public returns (bool);\n}\n```\n\r\n\n**src/Loihi.sol:L30**\n```solidity\ncontract Loihi is LoihiRoot {\n```\n\r\n\n**src/Assimilators.sol:L19**\n```solidity\nlibrary Delegate {\n```\n\r\n\n**src/Assimilators.sol:L33**\n```solidity\nlibrary Assimilators {\n```\n\r\n#### Recommendation\r\n\r\nSplit up contracts and libraries in single files.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/shell-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/06/shell-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/06/shell-protocol/"
    }
  },
  {
    "title": "Function `supportsInterface` can be restricted to `pure`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe function `supportsInterface` returns a `bool` stating that the contract supports one of the defined interfaces.\r\n\r\n\n**src/Loihi.sol:L140-L142**\n```solidity\nfunction supportsInterface (bytes4 interfaceID) public returns (bool) {\n    return interfaceID == ERC20ID || interfaceID == ERC165ID;\n}\n```\n\r\nThe function does not access or change the state of the contract, this is why it can be restricted to `pure`.\r\n\r\n#### Recommendation\r\n\r\nRestrict the function definition to `pure`.\r\n\r\n```solidity\r\nfunction supportsInterface (bytes4 interfaceID) public pure returns (bool) {\r\n```",
    "dataSource": {
      "name": "/diligence/audits/2020/06/shell-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/06/shell-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/06/shell-protocol/"
    }
  },
  {
    "title": "ERC20 compatibility of Amp token using defaultPartition",
    "severity": "medium",
    "body": "#### Description\r\n\r\nIt is somewhat unclear how the Amp token ensures ERC20 compatibility. While the `default` partition is used in some places (for instance, in function `balanceOf`) there are also separate fields for (aggregated) balances/allowances. This seems to introduce some redundancy and raises certain questions about when which fields are relevant. \r\n\r\n#### Examples\r\n\r\n- `_allowed` is used in function `allowance` instead of `_allowedByPartition` with the default partition\r\n\r\n- An `Approval` event should be emitted when approving the default partition \r\n\r\n\n**code/amp-contracts/contracts/Amp.sol:L1494**\n```solidity\nemit ApprovalByPartition(_partition, _tokenHolder, _spender, _amount);\n```\n\r\n- `increaseAllowance()` vs. `increaseAllowanceByPartition()`\r\n \r\n\r\n#### Recommendation\r\n\r\nAfter the mid-audit discussion, it was clear that the general `balanceOf` method (with no partition) is not needed and can be replaced with a `balanceOf` function that returns balance of the default partition, similarly for allowance, the general `increaseAllowance` function can simply call `increaseAllowanceByPartition` using default partition (same for decreaseAllowance).\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/06/amp/",
      "repo": "https://consensys.net//diligence/audits/2020/06/amp/",
      "url": "https://consensys.net//diligence/audits/2020/06/amp/"
    }
  },
  {
    "title": "Discrepancy between code and comments",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThere are some discrepancies between (uncommented) code and the documentations comment:\r\n\r\n\r\n\r\n#### Examples\r\n\r\n\n**code/amp-contracts/contracts/Amp.sol:L459-L462**\n```solidity\n// Indicate token verifies Amp, ERC777 and ERC20 interfaces\nERC1820Implementer._setInterface(AMP_INTERFACE_NAME);\nERC1820Implementer._setInterface(ERC20_INTERFACE_NAME);\n// ERC1820Implementer._setInterface(ERC777_INTERFACE_NAME);\n```\n\r\n\n**code/flexa-collateral-manager/contracts/FlexaCollateralManager.sol:L268-L279**\n```solidity\n/**\n * @notice Indicates a supply refund was executed\n * @param supplier Address whose refund authorization was executed\n * @param partition Partition from which the tokens were transferred\n * @param amount Amount of tokens transferred\n */\nevent SupplyRefund(\n    address indexed supplier,\n    bytes32 indexed partition,\n    uint256 amount,\n    uint256 indexed nonce\n);\n```\n\r\n#### Recommendation\r\n\r\nConsider updating either the code or the comment.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/06/amp/",
      "repo": "https://consensys.net//diligence/audits/2020/06/amp/",
      "url": "https://consensys.net//diligence/audits/2020/06/amp/"
    }
  },
  {
    "title": "`ERC1400ERC20` whitelist circumvents partition restrictions",
    "severity": "critical",
    "body": "#### Description\r\n\r\nERC1400/1410 enable \"partially fungible tokens\" in that not all tokens are equivalent. A specific use case is placing restrictions on some tokens, such as lock-up periods.\r\n\r\nThe whitelist in `ERC1400ERC20` circumvents these restrictions. When a token holder uses the ERC20 `transfer` function, tokens are transferred from that user's \"default partitions\", which a user can choose themselves by calling `ERC1410.setDefaultPartitions`. This means they can transfer tokens from any partition, and the only restriction that's placed on the transfer is that the _recipient_ must be whitelisted.\r\n\r\nIt should be noted that the comment and error message around the whitelisting feature suggests that it is meant to be applied to both the sender and recipient:\r\n\r\n\n**code/contracts/token/ERC20/ERC1400ERC20.sol:L24-L30**\n```solidity\n/**\n * @dev Modifier to verify if sender and recipient are whitelisted.\n */\nmodifier isWhitelisted(address recipient) {\n  require(_whitelisted[recipient], \"A3: Transfer Blocked - Sender lockup period not ended\");\n  _;\n}\n```\n\r\n#### Remediation\r\n\r\nThere are many possibilities, but here are concrete suggestions for addressing this:\r\n\r\n1. Require whitelisting both the sender and recipient, and make sure that whitelisted accounts only own (and _will_ only own) unrestricted tokens.\r\n2. Make sure that the only whitelisted recipients are those that apply partition restrictions when receiving tokens. (I.e. they implement the modified ERC777 receiving hook, examine the source partition, and reject transfers that should not occur.)\r\n3. Instead of implementing the ERC20 interface on top of the ERC1400 token, support transferring _out_ of the ERC1400 token and into a standard ERC20 token. Partition restrictions can then be applied on the ERC1400 transfer, and once ERC20 tokens are obtained, they can be transferred without restriction.\r\n4. Don't allow token holders to set their own default partitions. Rather, have the token specify a single, unrestricted partition that is used for all ERC20 transfers.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/codefi-erc1400-assessment/",
      "repo": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/",
      "url": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/"
    }
  },
  {
    "title": "ERC20/ERC777 compatibility: ERC20 transfer functions should not revert if the recipient is a contract without a registered ERC777TokensRecipient implementation",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe ERC20 functions `ERC1400ERC20.transfer` and `ERC1400ERC20.transferFrom` call `ERC1410._transferByDefaultPartitions`, which calls `ERC1410._transferByPartition`, which calls `ERC777._transferWithData` with the `preventLocking` argument of `true`.\r\n\r\nThis will block transfers to a contract that doesn't have an `ERC777TokensRecipient` implementation. This is in violation of [ERC 777](https://eips.ethereum.org/EIPS/eip-777), which says:\r\n\r\n> If the recipient is a contract, which has not registered an `ERC777TokensRecipient` implementation; then the token contract:\r\n> \r\n> * MUST `revert` if the `tokensReceived` hook is called from a mint or send call.\r\n> * SHOULD continue processing the transaction if the `tokensReceived` hook is called from an ERC20 `transfer` or `transferFrom` call.\r\n\r\n#### Remediation\r\n\r\nMake sure that ERC20-compatible transfer calls do not set `preventLocking` to `true`.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/codefi-erc1400-assessment/",
      "repo": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/",
      "url": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/"
    }
  },
  {
    "title": "Inaccurate error message in `ERC777ERC20.approve`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nIf the _spender_ is address `0`, the revert message says that the _receiver_ is not eligible.\r\n\r\n\n**code/contracts/token/ERC20/ERC777ERC20.sol:L153**\n```solidity\nrequire(spender != address(0), \"A6: Transfer Blocked - Receiver not eligible\");\n```\n\r\n#### Remediation\r\n\r\nFix the revert message to match the actual issue.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/codefi-erc1400-assessment/",
      "repo": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/",
      "url": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/"
    }
  },
  {
    "title": "Non-standard treatment of a `from` address of `0`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nA number of functions throughout the system treat a `from` address of `0` as equivalent to `msg.sender`. In some cases, this seems to violate existing standards (e.g. in ERC20 transfers). In other cases, it is merely surprising.\r\n\r\n`ERC1400ERC20.transferFrom` and `ERC777ERC20.transferFrom` both treat a `from` address as `0` as equivalent to `msg.sender`. This is unexpected behavior for an ERC20 token.\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/ERC1400.sol:L206-L214**\n```solidity\nfunction canOperatorTransferByPartition(bytes32 partition, address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n  external\n  view\n  returns (byte, bytes32, bytes32)\n{\n  if(!_checkCertificate(operatorData, 0, 0x8c0dee9c)) { // 4 first bytes of keccak256(operatorTransferByPartition(bytes32,address,address,uint256,bytes,bytes))\n    return(hex\"A3\", \"\", partition); // Transfer Blocked - Sender lockup period not ended\n  } else {\n    address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/ERC1400.sol:L417-L421**\n```solidity\nfunction redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\n  external\n  isValidCertificate(operatorData)\n{\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC20/ERC1400ERC20.sol:L180-L181**\n```solidity\nfunction transferFrom(address from, address to, uint256 value) external isWhitelisted(to) returns (bool) {\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC20/ERC777ERC20.sol:L179-L180**\n```solidity\nfunction transferFrom(address from, address to, uint256 value) external isWhitelisted(to) returns (bool) {\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC777/ERC777.sol:L194-L198**\n```solidity\nfunction transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n  external\n  isValidCertificate(operatorData)\n{\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC777/ERC777.sol:L226-L230**\n```solidity\nfunction redeemFrom(address from, uint256 value, bytes calldata data, bytes calldata operatorData)\n  external\n  isValidCertificate(operatorData)\n{\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC1410/ERC1410.sol:L130-L142**\n```solidity\nfunction operatorTransferByPartition(\n  bytes32 partition,\n  address from,\n  address to,\n  uint256 value,\n  bytes calldata data,\n  bytes calldata operatorData\n)\n  external\n  isValidCertificate(operatorData)\n  returns (bytes32)\n{\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n\n**code/contracts/token/ERC1410/ERC1410.sol:L430-L434**\n```solidity\nfunction transferFromWithData(address from, address to, uint256 value, bytes calldata data, bytes calldata operatorData)\n  external\n  isValidCertificate(operatorData)\n{\n  address _from = (from == address(0)) ? msg.sender : from;\n```\n\r\n#### Remediation\r\n\r\nRemove this fallback logic and always use the `from` address that was passed in. This avoids surprises where, for example, an uninitialized value leads to loss of funds.",
    "dataSource": {
      "name": "/diligence/audits/2020/06/codefi-erc1400-assessment/",
      "repo": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/",
      "url": "https://consensys.net//diligence/audits/2020/06/codefi-erc1400-assessment/"
    }
  },
  {
    "title": "Unable to compile contracts",
    "severity": "major",
    "body": "#### Description\r\n\r\nIn the `Fairswap_iDOLvsImmortalOptions`repository: \r\n\r\nCompilation with truffle fails due to a missing file: `contracts/testTokens/TestBondMaker.sol`. \r\nCompilation with `solc` fails due to an undefined interface function:\r\n\r\n```\r\nError: Member \"calculatePrice\" not found or not visible after argument-dependent lookup in contract CalculatorInterface.\r\n   --> contracts/BoxExchange.sol:821:36:\r\n    |\r\n821 |         uint256[5] memory Prices = calc.calculatePrice(\r\n    |                                    ^^^^^^^^^^^^^^^^^^^\r\n```\r\n\r\nIn the `Fairswap_iDOLvsLien` repository: \r\n\r\nCompilation with truffle fails due to a missing file: `./ERC20RegularlyRecord.sol`. The correct filename is `./TestERC20RegularlyRecord.sol`. \r\n\r\n#### Recommendation\r\n\r\nEnsure all contracts are easily compilable by following simple instructions in the README.",
    "dataSource": {
      "name": "/diligence/audits/2020/05/lien-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/05/lien-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/05/lien-protocol/"
    }
  },
  {
    "title": "Documented function `getERC20TokenDividend()` does not exist",
    "severity": "medium",
    "body": "#### Description\r\n\r\nIn the README of Fairswap_iDOLvsLien, a function is listed which is not implemented in the codebase: \r\n\r\n> `getERC20TokenDividend()` function withdraws ETH and baseToken dividends for the Lien token stored in the exchange.(the dividends are stored in the contract at this moment) \r\n\r\n\r\n#### Recommendation\r\n\r\nImplement the function, or update the documentation\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/05/lien-protocol/",
      "repo": "https://consensys.net//diligence/audits/2020/05/lien-protocol/",
      "url": "https://consensys.net//diligence/audits/2020/05/lien-protocol/"
    }
  },
  {
    "title": "Perpetual - The specified decimals for the collateral may not reflect the token's actual decimals",
    "severity": "minor",
    "body": "#### Description\r\n\r\nWhen initializing the `Perpetual` contract, the deployer can decide to use either `ETH`, or an  `ERC20`-compliant collateral. In the latter case, the deployer must provide a nonzero address for the token, as well as the number of `decimals` used by the token:\r\n\r\n\n**code/contracts/perpetual/Collateral.sol:L28-L34**\n```solidity\nconstructor(address _collateral, uint256 decimals) public {\n    require(decimals <= MAX_DECIMALS, \"decimals out of range\");\n    require(_collateral != address(0x0) || (_collateral == address(0x0) && decimals == 18), \"invalid decimals\");\n\n    collateral = _collateral;\n    scaler = (decimals == MAX_DECIMALS ? 1 : 10**(MAX_DECIMALS - decimals)).toInt256();\n}\n```\n\r\nThe provided `decimals` value is not checked for validity and can differ from the actual token's decimals.\r\n\r\n#### Recommendation\r\n\r\nEnsure to establish documentation that makes users aware of the fact that the decimals configured are not enforced to match the actual tokens decimals. This is to allow users to audit the system configuration and decide whether they want to participate in it.",
    "dataSource": {
      "name": "/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/"
    }
  },
  {
    "title": "AMM - Unchecked return value in `ShareToken.mint`",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`ShareToken` is an extension of the Openzeppelin [ERC20Mintable](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v2.5.1/contracts/token/ERC20/ERC20Mintable.sol#L20-L23) pattern which exposes a method called `mint()` that allows accounts owning the minter role to mint new tokens. The return value of `ShareToken.mint()` is not checked.\r\n\r\nSince the ERC20 standard does not define whether this method should return a value or revert it may be problematic to assume that all tokens revert. If, for example, an implementation is used that does not revert on error but returns a boolean error indicator instead the caller might falsely continue without the token minted.\r\n\r\nWe would like to note that the functionality is intended to be used with the provided `ShareToken` and therefore the contract is safe to use assuming `ERC20Mintable.mint` reverts on error. The issue arises if the system is used with a different `ShareToken` implementation that is not implemented in the same way.\r\n\r\n#### Examples\r\n\r\n* Openzeppelin implementation\r\n\r\n```solidity\r\nfunction mint(address account, uint256 amount) public onlyMinter returns (bool) {\r\n    _mint(account, amount);\r\n    return true;\r\n}\r\n```\r\n\r\n* Call with unchecked return value\r\n\r\n\n**code/contracts/liquidity/AMM.sol:L499-L502**\n```solidity\n\nfunction mintShareTokenTo(address guy, uint256 amount) internal {\n    shareToken.mint(guy, amount);\n}\n```\n\r\n#### Recommendation\r\n\r\nConsider wrapping the `mint` statement in a `require` clause, however, this way only tokens that are returning a boolean error indicator are supported. Document the specification requirements for the `ShareToken` and clearly state if the token is expected to revert or return an error indicator.\r\n\r\nIt should also be documented that the Token exposes a `burn` method that does not adhere to the Openzeppelin `ERC20Burnable` implementation. The `ERC20Burnable` import is unused as noted in 18.",
    "dataSource": {
      "name": "/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/"
    }
  },
  {
    "title": "Unused Imports",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe following source units are imported but not referenced in the contract:\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/perpetual/Perpetual.sol:L4-L5**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\n```\n\r\n\n**code/contracts/perpetual/Perpetual.sol:L14-L15**\n```solidity\nimport \"../interface/IPriceFeeder.sol\";\nimport \"../interface/IGlobalConfig.sol\";\n```\n\r\n\n**code/contracts/token/ShareToken.sol:L5-L5**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\n```\n\r\n\n**code/contracts/token/ShareToken.sol:L3-L3**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n```\n\r\n#### Recommendation\r\n\r\nCheck all imports and remove all unused/unreferenced and unnecessary imports.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/"
    }
  },
  {
    "title": "Where possible, a specific contract type should be used rather than `address`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nRather than storing `address`es and then casting to the known contract type, it's better to use the best type available so the compiler can check for type safety.\r\n\r\n#### Examples\r\n\r\n`Collateral. collateral` is of type `address`, but it could be type `IERC20` instead. Not only would this give a little more type safety when deploying new modules, but it would avoid repeated casts throughout the codebase of the form `IERC20(collateral)`, `IPerpetual(_perpetual)` and others. The following is an incomplete list of examples:\r\n\r\n* declare collateral as IERC20\r\n\r\n\n**code/contracts/perpetual/Collateral.sol:L19-L19**\n```solidity\naddress public collateral;\n```\n\r\n\n**code/contracts/perpetual/Collateral.sol:L51-L51**\n```solidity\nIERC20(collateral).safeTransferFrom(guy, address(this), rawAmount);\n```\n\r\n* declare argument `perpetual` as `IPerpetual`\r\n\n**code/contracts/exchange/Exchange.sol:L34-L42**\n```solidity\nfunction matchOrders(\n    LibOrder.OrderParam memory takerOrderParam,\n    LibOrder.OrderParam[] memory makerOrderParams,\n    address _perpetual,\n    uint256[] memory amounts\n) public {\n    require(!takerOrderParam.isMakerOnly(), \"taker order is maker only\");\n\n    IPerpetual perpetual = IPerpetual(_perpetual);\n```\n\r\n* declare argument `feeder` as `IChainlinkFeeder`\r\n\r\n\n**code/contracts/oracle/ChainlinkAdapter.sol:L12-L14**\n```solidity\nconstructor(address _feeder) public {\n    feeder = IChainlinkFeeder(_feeder);\n}\n```\n\r\n\r\n#### Remediation\r\n\r\nWhere possible, use more specific types instead of `address`. This goes for parameter types as well as state variable types.",
    "dataSource": {
      "name": "/diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "repo": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/",
      "url": "https://consensys.net//diligence/audits/2020/05/mcdex-mai-protocol-v2/"
    }
  },
  {
    "title": "Ensure bound and rebound token values are exactly correct",
    "severity": null,
    "body": "#### Description\r\n\r\nFor both `BPool.bind` and `BPool.rebind`, the `balance` parameter is used to determine how many tokens the pool will absorb from `msg.sender` (or release to `msg.sender`):\r\n\r\n\n**code/contracts/BPool.sol:L286-L297**\n```solidity\n// Adjust the balance record and actual token balance\nuint oldBalance = _records[token].balance;\n_records[token].balance = balance;\nif (balance > oldBalance) {\n    _pullUnderlying(token, msg.sender, bsub(balance, oldBalance));\n} else if (balance < oldBalance) {\n    // In this case liquidity is being withdrawn, so charge EXIT_FEE\n    uint tokenBalanceWithdrawn = bsub(oldBalance, balance);\n    uint tokenExitFee = bmul(tokenBalanceWithdrawn, EXIT_FEE);\n    _pushUnderlying(token, msg.sender, bsub(tokenBalanceWithdrawn, tokenExitFee));\n    _pushUnderlying(token, _factory, tokenExitFee);\n}\n```\n\r\nBecause token balance changes can happen outside of the context of this function, an extra check at the bottom would ensure that the `rebind` operation was performed successfully and with complete understanding of the state of the pool:\r\n\r\n`require(_records[token].balance == token.balanceOf(address(this)));`\r\n\r\nAlternatively, consider performing an operation similar to that implemented in `gulp`:\r\n\r\n\n**code/contracts/BPool.sol:L333-L341**\n```solidity\n// Absorb any tokens that have been sent to this contract into the pool\nfunction gulp(address token)\n    external\n    _logs_\n    _lock_\n{\n    require(_records[token].bound, \"ERR_NOT_BOUND\");\n    _records[token].balance = IERC20(token).balanceOf(address(this));\n}\n```\n",
    "dataSource": {
      "name": "/diligence/audits/2020/05/balancer-finance/",
      "repo": "https://consensys.net//diligence/audits/2020/05/balancer-finance/",
      "url": "https://consensys.net//diligence/audits/2020/05/balancer-finance/"
    }
  },
  {
    "title": "CPM token price is susceptible to manipulation",
    "severity": "critical",
    "body": "#### Description\r\n\r\nThe calculation of the CPM token price is based on the combined value of the Ether and ERC20 Token liquidity that can be withdrawn per CPM token. \r\n\r\nThis can be represented simply as `Price = (EtherValue  + TokenAmount*EthPriceOfToken) / CpmTotalSupply`, where `EthPriceOfToken` is taken from the chainlink oracle. \r\n\r\nHowever this calculation does not properly account for the Constant Price Model which is susceptible to price slippage at larger trading volumes. This would enable an attacker to make a large trade (possibly funded by a Flash Loan), shifting the balance of the ETH and Token reserves, and reducing the real value of the liquidity held in the exchange.\r\n\r\nOne way to think of this is that for any given price, there is a \"correct\" ratio of ETH to Token in the reserve. \r\n\r\nThe consequence of this issue is that the wrong price is returned, which breaks the security model of this contract.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/05/aave-cpm-price-provider/",
      "repo": "https://consensys.net//diligence/audits/2020/05/aave-cpm-price-provider/",
      "url": "https://consensys.net//diligence/audits/2020/05/aave-cpm-price-provider/"
    }
  },
  {
    "title": "Consistent use of `SafeERC20` for external tokens",
    "severity": "medium",
    "body": "#### Description\r\n\r\nUse `SafeERC20` features to interact with potentially broken tokens used in the system. E.g. `TokenGrant.receiveApproval()` is using `safeTransferFrom` while other contracts aren't.\r\n\r\n#### Examples\r\n\r\n* `TokenGrant.receiveApproval` using `safeTransferFrom`\r\n\r\n\n**keep-core/contracts/solidity/contracts/TokenGrant.sol:L200-L200**\n```solidity\ntoken.safeTransferFrom(_from, address(this), _amount);\n```\n\r\n* `TokenStaking.receiveApproval` not using `safeTransferFrom` while `safeTransfer` is being used.\r\n\r\n\n**keep-core/contracts/solidity/contracts/TokenStaking.sol:L75-L75**\n```solidity\ntoken.transferFrom(_from, address(this), _value);\n```\n\r\n\n**keep-core/contracts/solidity/contracts/TokenStaking.sol:L103-L103**\n```solidity\ntoken.safeTransfer(owner, amount);\n```\n\r\n\n**keep-core/contracts/solidity/contracts/TokenStaking.sol:L193-L193**\n```solidity\ntoken.transfer(tattletale, tattletaleReward);\n```\n\r\n* `distributeERC20ToMembers` not using `safeTransferFrom`\r\n\r\n\n**keep-tecdsa/solidity/contracts/BondedECDSAKeep.sol:L459-L463**\n```solidity\ntoken.transferFrom(\n    msg.sender,\n    tokenStaking.magpieOf(members[i]),\n    dividend\n);\n```\n\r\n#### Recommendation\r\n\r\nConsistently use `SafeERC20` to support potentially broken tokens external to the system.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/02/thesis-tbtc-and-keep/",
      "repo": "https://consensys.net//diligence/audits/2020/02/thesis-tbtc-and-keep/",
      "url": "https://consensys.net//diligence/audits/2020/02/thesis-tbtc-and-keep/"
    }
  },
  {
    "title": "keep-core - TokenGrant and TokenStaking allow staking zero amount of tokens and front-running",
    "severity": "medium",
    "body": "#### Description\r\n\r\nTokens are staked via the callback `receiveApproval()` which is normally invoked when calling `approveAndCall()`. The method is not restricting who can initiate the staking of tokens and relies on the fact that the token transfer to the `TokenStaking` contract is pre-approved by the owner, otherwise, the call would revert.\r\n\r\nHowever, `receiveApproval()` allows the staking of a zero amount of tokens. The only check performed on the number of tokens transferred is, that the token holders balance covers the amount to be transferred. This check is both relatively weak - having enough balance does not imply that tokens are approved for transfer - and does not cover the fact that someone can call the method with a zero amount of tokens.\r\n\r\nThis way someone could create an arbitrary number of operators staking no tokens at all. This passes the token balance check, `token.transferFrom()` will succeed and an operator struct with a zero stake and arbitrary values for `operator, from, magpie, authorizer` can be set. Finally, an event is emitted for a zero stake.\r\n\r\nAn attacker could front-run calls to `receiveApproval` to block staking of a legitimate operator by creating a zero stake entry for the operator before she is able to. This vector might allow someone to permanently inconvenience an operator's address. To recover from this situation one could be forced to `cancelStake` terminating the zero stake struct in order to call the contract with the correct stake again.\r\n\r\nThe same issue exists for `TokenGrant`.\r\n\r\n#### Examples\r\n\r\n\n**keep-core/contracts/solidity/contracts/TokenStaking.sol:L54-L81**\n```solidity\n/**\n * @notice Receives approval of token transfer and stakes the approved amount.\n * @dev Makes sure provided token contract is the same one linked to this contract.\n * @param _from The owner of the tokens who approved them to transfer.\n * @param _value Approved amount for the transfer and stake.\n * @param _token Token contract address.\n * @param _extraData Data for stake delegation. This byte array must have the\n * following values concatenated: Magpie address (20 bytes) where the rewards for participation\n * are sent, operator's (20 bytes) address, authorizer (20 bytes) address.\n */\nfunction receiveApproval(address _from, uint256 _value, address _token, bytes memory _extraData) public {\n    require(ERC20Burnable(_token) == token, \"Token contract must be the same one linked to this contract.\");\n    require(_value <= token.balanceOf(_from), \"Sender must have enough tokens.\");\n    require(_extraData.length == 60, \"Stake delegation data must be provided.\");\n\n    address payable magpie = address(uint160(_extraData.toAddress(0)));\n    address operator = _extraData.toAddress(20);\n    require(operators[operator].owner == address(0), \"Operator address is already in use.\");\n    address authorizer = _extraData.toAddress(40);\n\n    // Transfer tokens to this contract.\n    token.transferFrom(_from, address(this), _value);\n\n    operators[operator] = Operator(_value, block.number, 0, _from, magpie, authorizer);\n    ownerOperators[_from].push(operator);\n\n    emit Staked(operator, _value);\n}\n```\n\r\n#### Recommendation\r\n\r\nRequire tokens to be staked and explicitly disallow the zero amount of tokens case. The balance check can be removed. \r\n\r\nNote: Consider checking the calls return value or calling the contract via `SafeERC20` to support potentially broken tokens that do not revert in error cases (`token.transferFrom`).",
    "dataSource": {
      "name": "/diligence/audits/2020/02/thesis-tbtc-and-keep/",
      "repo": "https://consensys.net//diligence/audits/2020/02/thesis-tbtc-and-keep/",
      "url": "https://consensys.net//diligence/audits/2020/02/thesis-tbtc-and-keep/"
    }
  },
  {
    "title": "Warning about ERC20 handling function",
    "severity": null,
    "body": "#### Description\r\n\r\nThere is something worth bringing up for discussion in the ERC20 disbursement function.\r\n\r\n\n**code/BitwaveMultiSend.sol:L55**\n```solidity\nassert(token.transferFrom(msg.sender, _to[i], _value[i]) == true);\n```\n\r\nIn the above presented line, the external call is being compared to a truthful boolean.\r\nAnd, even though, this is clearly part of the ERC20 specification there have historically been cases where tokens with sizeable market caps and liquidity have erroneously not implemented return values in any of the transfer functions.\r\n\r\nThe question presents itself as to whether these non-ERC20-conforming tokens are meant to be supported or not.\r\n\r\nThe audit team believes that the purpose of this smart contract is to disburse OXT tokens and therefore, since its development was under the umbrella of the Orchid team, absolutely no security concerns should arise from this issue.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "repo": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/",
      "url": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/"
    }
  },
  {
    "title": "Discussion on the permissioning of send functions",
    "severity": null,
    "body": "#### Description\r\n\r\nSince the disbursement of funds is all made atomically (i.e., the Ether funds held by the smart contract are transient) there is no need to permission the function with the `restrictedToOwner` modifier.\r\n\r\nEven in the case of ERC20 tokens, there is no need to permission the function since the smart contract can only spend allowance attributed to it by the caller (`msg.sender`).\r\n\r\nThis being said there *is value in permissioning this contract*, specifically if attribution of the deposited funds in readily available tools like Etherscan is important. Because turning this into a publicly available tool for batch sends of Ether and ERC20 tokens would mean that someone could wrongly attribute some disbursement to Orchid Labs should they be ignorant to this fact.\r\n\r\nA possible solution to this problem would be the usage of events to properly attribute the disbursements but it is, indeed, an additional burden to carefully analyse these for proper attribution.",
    "dataSource": {
      "name": "/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "repo": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/",
      "url": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/"
    }
  },
  {
    "title": "Unneeded type cast of contract type",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe typecast being done on the `address` parameter in the lien below is unneeded.\r\n\r\n\n**code/BitwaveMultiSend.sol:L51**\n```solidity\nERC20 token = ERC20(_tokenAddress);\n```\n\r\n#### Recommendation\r\n\r\nAssign the right type at the function parameter definition like so:\r\n\r\n```\r\n    function sendErc20(ERC20 _tokenAddress, address[] memory _to, uint256[] memory _value) public restrictedToOwner returns (bool _success) {\r\n```",
    "dataSource": {
      "name": "/diligence/audits/2020/01/orchid-bitwavemultisend/",
      "repo": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/",
      "url": "https://consensys.net//diligence/audits/2020/01/orchid-bitwavemultisend/"
    }
  },
  {
    "title": "ERC20Lockable - inconsistent locking status",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`Vega_Token.is_tradable()` will incorrectly return `false` if the token is never manually unlocked by the owner but `unlock_time` has passed, which will automatically unlock trading.\r\n\r\n#### Examples\r\n\r\n\n**code/ERC20Lockable.sol:L48-L67**\n```solidity\n/**\n * @dev locked status, only applicable before unlock_date\n */\nbool public _is_locked = true;\n\n/**\n * @dev Modifier that only allows function to run if either token is unlocked or time has expired.\n * Throws if called while token is locked.\n */\nmodifier onlyUnlocked() {\n    require(!_is_locked || now > unlock_date);\n    _;\n}\n\n/**\n * @dev Internal function that unlocks token. Can only be ran before expiration (give that it's irrelevant after)\n */\nfunction _unlock() internal {\n    require(now <= unlock_date);\n    _is_locked = false;\n```\n\r\n#### Recommendation\r\n\r\n* declare `_is_locked` as `private` instead of `public`\r\n* create a getter method that correctly returns the locking status\r\n ```solidity\r\nfunction _isLocked() internal view {\r\n        return !_is_locked || now > unlock_date;\r\n}\r\n```\r\n* make `modifier onlyUnlocked()` use the newly created getter (`_isLocked()`)\r\n* make `Vega_Token.is_tradeable()` use the newly created getter (`_isLocked()`)\r\n* `_unlock()` should raise an errorcondition when called on an already unlocked contract \r\n  * it could make sense to emit a \"contract hast been unlocked\" event for auditing purposes",
    "dataSource": {
      "name": "/diligence/audits/2020/01/vega-vegatoken/",
      "repo": "https://consensys.net//diligence/audits/2020/01/vega-vegatoken/",
      "url": "https://consensys.net//diligence/audits/2020/01/vega-vegatoken/"
    }
  },
  {
    "title": "Maintainer can bypass exit game quarantine by registering not-yet-deployed contracts",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe plasma framework uses an `ExitGameRegistry` to allow the maintainer to add new exit games after deployment. An exit game is any arbitrary contract. In order to prevent the maintainer from adding malicious exit games that steal user funds, the framework uses a \"quarantine\" system whereby newly-registered exit games have restricted permissions until their quarantine period has expired. The quarantine period is by default `3 * minExitPeriod`, and is intended to facilitate auditing of the new exit game's functionality by the plasma users. \r\n\r\nHowever, by registering an exit game at a contract which has not yet been deployed, the maintainer can prevent plasma users from auditing the game until the quarantine period has expired. After the quarantine period has expired, the maintainer can deploy the malicious exit game and immediately steal funds.\r\n\r\n#### Explanation\r\n\r\nExit games are registered in the following function, callable only by the plasma contract maintainer:\r\n\r\n\n**code/plasma_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L58-L78**\n```solidity\n/**\n * @notice Registers an exit game within the PlasmaFramework. Only the maintainer can call the function.\n * @dev Emits ExitGameRegistered event to notify clients\n * @param _txType The tx type where the exit game wants to register\n * @param _contract Address of the exit game contract\n * @param _protocol The transaction protocol, either 1 for MVP or 2 for MoreVP\n */\nfunction registerExitGame(uint256 _txType, address _contract, uint8 _protocol) public onlyFrom(getMaintainer()) {\n    require(_txType != 0, \"Should not register with tx type 0\");\n    require(_contract != address(0), \"Should not register with an empty exit game address\");\n    require(_exitGames[_txType] == address(0), \"The tx type is already registered\");\n    require(_exitGameToTxType[_contract] == 0, \"The exit game contract is already registered\");\n    require(Protocol.isValidProtocol(_protocol), \"Invalid protocol value\");\n\n    _exitGames[_txType] = _contract;\n    _exitGameToTxType[_contract] = _txType;\n    _protocols[_txType] = _protocol;\n    _exitGameQuarantine.quarantine(_contract);\n\n    emit ExitGameRegistered(_txType, _contract, _protocol);\n}\n```\n\r\nNotably, the function does not check the `extcodesize` of the submitted contract. As such, the maintainer can submit the address of a contract which does not yet exist and is not auditable.\r\n\r\nAfter at least `3 * minExitPeriod` seconds pass, the submitted contract now has full permissions as a registered exit game and can pass all checks using the `onlyFromNonQuarantinedExitGame` modifier:\r\n\r\n\n**code/plasma_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L33-L40**\n```solidity\n/**\n * @notice A modifier to verify that the call is from a non-quarantined exit game\n */\nmodifier onlyFromNonQuarantinedExitGame() {\n    require(_exitGameToTxType[msg.sender] != 0, \"The call is not from a registered exit game contract\");\n    require(!_exitGameQuarantine.isQuarantined(msg.sender), \"ExitGame is quarantined\");\n    _;\n}\n```\n\r\nAdditionally, the submitted contract passes checks made by external contracts using the `isExitGameSafeToUse` function:\r\n\r\n\n**code/plasma_framework/contracts/src/framework/registries/ExitGameRegistry.sol:L48-L56**\n```solidity\n/**\n * @notice Checks whether the contract is safe to use and is not under quarantine\n * @dev Exposes information about exit games quarantine\n * @param _contract Address of the exit game contract\n * @return boolean Whether the contract is safe to use and is not under quarantine\n */\nfunction isExitGameSafeToUse(address _contract) public view returns (bool) {\n    return _exitGameToTxType[_contract] != 0 && !_exitGameQuarantine.isQuarantined(_contract);\n}\n```\n\r\nThese permissions allow a registered quarantine to:\r\n\r\n1. Withdraw any users' tokens from `ERC20Vault`:\r\n\r\n\n**code/plasma_framework/contracts/src/vaults/Erc20Vault.sol:L52-L55**\n```solidity\nfunction withdraw(address payable receiver, address token, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    IERC20(token).safeTransfer(receiver, amount);\n    emit Erc20Withdrawn(receiver, token, amount);\n}\n```\n\r\n2. Withdraw any users' ETH from `EthVault`:\r\n\r\n\n**code/plasma_framework/contracts/src/vaults/EthVault.sol:L46-L54**\n```solidity\nfunction withdraw(address payable receiver, uint256 amount) external onlyFromNonQuarantinedExitGame {\n    // we do not want to block exit queue if transfer is unucessful\n    // solhint-disable-next-line avoid-call-value\n    (bool success, ) = receiver.call.value(amount)(\"\");\n    if (success) {\n        emit EthWithdrawn(receiver, amount);\n    } else {\n        emit WithdrawFailed(receiver, amount);\n    }\n```\n\r\n3. Activate and deactivate the `ExitGameController` reentrancy mutex:\r\n\r\n\n**code/plasma_framework/contracts/src/framework/ExitGameController.sol:L63-L66**\n```solidity\nfunction activateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n    require(!mutex, \"Reentrant call\");\n    mutex = true;\n}\n```\n\r\n\n**code/plasma_framework/contracts/src/framework/ExitGameController.sol:L72-L75**\n```solidity\nfunction deactivateNonReentrant() external onlyFromNonQuarantinedExitGame() {\n    require(mutex, \"Not locked\");\n    mutex = false;\n}\n```\n\r\n4. `enqueue` arbitrary exits:\r\n\r\n\n**code/plasma_framework/contracts/src/framework/ExitGameController.sol:L115-L138**\n```solidity\nfunction enqueue(\n    uint256 vaultId,\n    address token,\n    uint64 exitableAt,\n    TxPosLib.TxPos calldata txPos,\n    uint160 exitId,\n    IExitProcessor exitProcessor\n)\n    external\n    onlyFromNonQuarantinedExitGame\n    returns (uint256)\n{\n    bytes32 key = exitQueueKey(vaultId, token);\n    require(hasExitQueue(key), \"The queue for the (vaultId, token) pair is not yet added to the Plasma framework\");\n    PriorityQueue queue = exitsQueues[key];\n\n    uint256 priority = ExitPriority.computePriority(exitableAt, txPos, exitId);\n\n    queue.insert(priority);\n    delegations[priority] = exitProcessor;\n\n    emit ExitQueued(exitId, priority);\n    return priority;\n}\n```\n\r\n5. Flag outputs as \"spent\":\r\n\r\n\n**code/plasma_framework/contracts/src/framework/ExitGameController.sol:L210-L213**\n```solidity\nfunction flagOutputSpent(bytes32 _outputId) external onlyFromNonQuarantinedExitGame {\n    require(_outputId != bytes32(\"\"), \"Should not flag with empty outputId\");\n    isOutputSpent[_outputId] = true;\n}\n```\n\r\n#### Recommendation\r\n\r\n`registerExitGame` should check that `extcodesize` of the submitted contract is non-zero.\r\n\r\nCorresponding issue in plasma-contracts repo: https://github.com/omisego/plasma-contracts/issues/410",
    "dataSource": {
      "name": "/diligence/audits/2020/01/omisego-morevp/",
      "repo": "https://consensys.net//diligence/audits/2020/01/omisego-morevp/",
      "url": "https://consensys.net//diligence/audits/2020/01/omisego-morevp/"
    }
  },
  {
    "title": "Not compliant with ERC1404 ",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe ERC1404 standard is an extension of the ERC20 standard. Here it has been implemented as a standalone contract, but does not contain all of the extra functions required by ERC1404.\r\n\r\nAs such, neither the `FAIR` contract nor the `ERC1404` contract is ERC1404-compliant.\r\n\r\n#### Recommendations\r\n\r\n1. Rename the `ERC1404` contract to be something more generic like `Whitelist`. This is more descriptive, and avoids confusion between `Whitelist.approve()` and the completely unrelated `approve()` function that an ERC1404-compliant contract should inherit from ERC20.\r\n2. Fully implement ERC1404 in `FAIR` by adding `messageForTransferRestriction()`, if and only if the standard can be changed to [accommodate Vyper's types](https://github.com/ethereum/EIPs/issues/1404#issuecomment-515483660). If it cannot, drop all claims or implications of ERC1404 support.\r\n3. To further reduce confusion, consider renaming `approve()`, and perhaps splitting it into 2 separate functions. E.g. `allow()` and `deny()`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/fairmint-continuous-securities-offering/",
      "repo": "https://consensys.net//diligence/audits/2019/11/fairmint-continuous-securities-offering/",
      "url": "https://consensys.net//diligence/audits/2019/11/fairmint-continuous-securities-offering/"
    }
  },
  {
    "title": "EOPBCTemplate - misleading method names `_cacheFundraisingApps` and `_cacheFundraisingParams`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe methods `_cacheFundraisingApps` and `_cacheFundraisingParams` suggest that parameters are cached as state variables in the contract similar to the multi-step deployment contract used for AragonBlack/Fundraising. However, the methods are just returning memory structs.\r\n\r\n\n**code/fundraising/templates/externally_owned_presale_bonding_curve/contracts/EOPBCTemplate.sol:L254-L300**\n```solidity\nfunction _cacheFundraisingApps(\n    Agent          _reserve,\n    Presale        _presale,\n    MarketMaker    _marketMaker,\n    Tap            _tap,\n    Controller     _controller,\n    TokenManager   _tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = _reserve;\n    fundraisingApps.presale            = _presale;\n    fundraisingApps.marketMaker        = _marketMaker;\n    fundraisingApps.tap                = _tap;\n    fundraisingApps.controller         = _controller;\n    fundraisingApps.bondedTokenManager = _tokenManager;\n}\n\nfunction _cacheFundraisingParams(\n    address       _owner,\n    string        _id,\n    ERC20         _collateralToken,\n    MiniMeToken   _bondedToken,\n    uint64        _period,\n    uint256       _exchangeRate,\n    uint64        _openDate,\n    uint256       _reserveRatio,\n    uint256       _batchBlocks,\n    uint256       _slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n{\n    fundraisingParams = FundraisingParams({\n        owner:           _owner,\n        id:              _id,\n        collateralToken: _collateralToken,\n        bondedToken:     _bondedToken,\n        period:          _period,\n        exchangeRate:    _exchangeRate,\n        openDate:        _openDate,\n        reserveRatio:    _reserveRatio,\n        batchBlocks:     _batchBlocks,\n        slippage:        _slippage\n    });\n}\n```\n\r\n\r\n#### Recommendation\r\n\r\nThe functions are only called once throughout the deployment process. The structs can therefore be created directly in the main method. Otherwise rename the functions to properly reflect their purpose.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonone-aragon-network-presale/"
    }
  },
  {
    "title": "EOPBCTemplate - inconsistent storage location declaration ",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`_cacheFundraisingParams()` does not explicitly declare the return value memory location. \r\n\r\n\n**code/fundraising/templates/externally_owned_presale_bonding_curve/contracts/EOPBCTemplate.sol:L273-L286**\n```solidity\nfunction _cacheFundraisingParams(\n    address       _owner,\n    string        _id,\n    ERC20         _collateralToken,\n    MiniMeToken   _bondedToken,\n    uint64        _period,\n    uint256       _exchangeRate,\n    uint64        _openDate,\n    uint256       _reserveRatio,\n    uint256       _batchBlocks,\n    uint256       _slippage\n)\n    internal\n    returns (FundraisingParams fundraisingParams)\n```\n\r\n`_cacheFundraisingApps()` explicitly declares to return a copy of the storage struct.\r\n\r\n\n**code/fundraising/templates/externally_owned_presale_bonding_curve/contracts/EOPBCTemplate.sol:L254-L271**\n```solidity\nfunction _cacheFundraisingApps(\n    Agent          _reserve,\n    Presale        _presale,\n    MarketMaker    _marketMaker,\n    Tap            _tap,\n    Controller     _controller,\n    TokenManager   _tokenManager\n)\n    internal\n    returns (FundraisingApps memory fundraisingApps)\n{\n    fundraisingApps.reserve            = _reserve;\n    fundraisingApps.presale            = _presale;\n    fundraisingApps.marketMaker        = _marketMaker;\n    fundraisingApps.tap                = _tap;\n    fundraisingApps.controller         = _controller;\n    fundraisingApps.bondedTokenManager = _tokenManager;\n}\n```\n\r\n#### Recommendation\r\n\r\nStorage declarations should be consistent.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonone-aragon-network-presale/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonone-aragon-network-presale/"
    }
  },
  {
    "title": "Document that math in `OrchidDirectory` assumes a maximum number of tokens",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`OrchidDirectory` relies on mathematical operations being unable to overflow due to the particular ERC20 token being used being capped at less than `2**128`.\r\n\r\n#### Examples\r\n\r\nThe following code in `step()` assumes that no before/after amount can reach `2**128`:\r\n\r\n\n**code/dir-ethereum/directory.sol:L145-L148**\n```solidity\nif (name(stake.left_) == key)\n    stake.before_ += amount;\nelse\n    stake.after_ += amount;\n```\n\r\nThe following code in `lift()` assumes that no staked amount (or total amount for a given stakee) can reach `2**128`:\r\n\r\n\n**code/dir-ethereum/directory.sol:L157-L164**\n```solidity\nuint128 local = stake.amount_;\nlocal += amount;\nstake.amount_ = local;\nemit Update(staker, stakee, local);\n\nuint128 global = stakees_[stakee].amount_;\nglobal += amount;\nstakees_[stakee].amount_ = global;\n```\n\r\nThe following code in `have()` assumes that the total amount staked cannot reach `2**128`:\r\n\r\n\n**code/dir-ethereum/directory.sol:L103**\n```solidity\nreturn stake.before_ + stake.after_ + stake.amount_;\n```\n\r\n#### Recommendation\r\n\r\nDocument this assumption in the form of code comments where potential overflows exist.\r\n\r\nConsider also `assert`ing the ERC20 token's total supply in the constructor to attempt to block using a token that violates this constraint and/or checking in `push()` that the total amount staked will remain less than `2**128`. This recommendation is in line with the mitigation proposed for 8. ",
    "dataSource": {
      "name": "/diligence/audits/2019/11/orchid-network-protocol/",
      "repo": "https://consensys.net//diligence/audits/2019/11/orchid-network-protocol/",
      "url": "https://consensys.net//diligence/audits/2019/11/orchid-network-protocol/"
    }
  },
  {
    "title": "Tap payments inconsistency",
    "severity": "major",
    "body": "#### Description\r\n\r\nEvery time project managers want to withdraw tapped funds, the maximum amount of withdrawable funds is calculated in `tap._maximumWithdrawal` function. The method ensures that project managers can only withdraw unlocked funds (balance exceeding the collaterals `minimum` comprised of the collaterals configured `floor` including the minimum tokens to `hold`) even though their allowance might be higher.\r\n \r\n1. if there are **no** unlocked funds available, the maximum withdrawal is zero (`balance <= minimum`).\r\n2. if there are unlocked funds available (`balance > minimum`) and the allowance (`tapped`) would result in a `balance >= minimum`, the maximum withdrawal amount is the calculated allowance `tapped`.\r\n3. if there are unlocked funds available (`balance > minimum`) and the allowance (`tapped`) would result in a `balance < minimum`, the maximum withdrawal amount `tapped` is capped to `balance - minimum` to ensure that the remaining collateral `balance` is at least at the `minimum` and not below.\r\n\r\nThis means that in the case of (3) if there are not enough funds to withdraw [`tapped`](https://github.com/AragonBlack/fundraising/blob/master/apps/tap/contracts/Tap.sol)(`time*tap_rate`) amount of tokens, it gets truncated and only a part of tapped tokens gets withdrawn. \r\n\r\n\n**code/apps/tap/contracts/Tap.sol:L239-L255**\n```solidity\nfunction _maximumWithdrawal(address _token) internal view returns (uint256) {\n    uint256 toBeClaimed = controller.collateralsToBeClaimed(_token);\n    uint256 floor = floors[_token];\n    uint256 minimum = toBeClaimed.add(floor);\n    uint256 balance = _token == ETH ? address(reserve).balance : ERC20(_token).staticBalanceOf(reserve);\n    uint256 tapped = (_currentBatchId().sub(lastWithdrawals[_token])).mul(rates[_token]);\n\n    if (minimum >= balance) {\n        return 0;\n    }\n\n    if (balance >= tapped.add(minimum)) {\n        return tapped;\n    }\n\n    return balance.sub(minimum);\n}\n```\n\r\nThe problem is that the remaining tokens  (`tapped - capped_tapped`) cannot be claimed afterward and `tapped` value is reset to zero.\r\n\r\n#### Remediation\r\n\r\nIn case the maximum withdrawal amount gets capped, the information about the remaining tokens that the project team should have been able to withdraw should be kept to allow them to withdraw the tokens at a later point in time when there are enough funds for it.",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "[New] Tapped collaterals can be bought by traders",
    "severity": "medium",
    "body": "#### Description\r\n\r\nWhen a trader submits a sell order, `_openSellOrder()` function checks that there are enough tokens in `reserve` by calling `_poolBalanceIsSufficient` function \r\n\r\n\n**code/apps/batched-bancor-market-maker/contracts/BatchedBancorMarketMaker.sol:L483-L485**\n```solidity\nfunction _poolBalanceIsSufficient(address _collateral) internal view returns (bool) {\n    return controller.balanceOf(address(reserve), _collateral) >= collateralsToBeClaimed[_collateral];\n}\n```\n\r\nthe problem is that because `collateralsToBeClaimed[_collateral]` has increased, `controller.balanceOf(address(reserve), _collateral)` could also increase. It happens so because `controller.balanceOf()` function subtracts tapped amount from the reserve's balance.\r\n\r\n\n**code/apps/aragon-fundraising/contracts/AragonFundraisingController.sol:L358-L366**\n```solidity\nfunction balanceOf(address _who, address _token) public view isInitialized returns (uint256) {\n    uint256 balance = _token == ETH ? _who.balance : ERC20(_token).staticBalanceOf(_who);\n\n    if (_who == address(reserve)) {\n        return balance.sub(tap.getMaximumWithdrawal(_token));\n    } else {\n        return balance;\n    }\n}\n```\n\r\nAnd `tap.getMaximumWithdrawal(_token)` could decrease because it depends on `collateralsToBeClaimed[_collateral]`\r\n\r\n\n**apps/tap/contracts/Tap.sol:L231-L264**\n```solidity\nfunction _tappedAmount(address _token) internal view returns (uint256) {\n    uint256 toBeKept = controller.collateralsToBeClaimed(_token).add(floors[_token]);\n    uint256 balance = _token == ETH ? address(reserve).balance : ERC20(_token).staticBalanceOf(reserve);\n    uint256 flow = (_currentBatchId().sub(lastTappedAmountUpdates[_token])).mul(rates[_token]);\n    uint256 tappedAmount = tappedAmounts[_token].add(flow);\n    /**\n     * whatever happens enough collateral should be\n     * kept in the reserve pool to guarantee that\n     * its balance is kept above the floor once\n     * all pending sell orders are claimed\n    */\n\n    /**\n     * the reserve's balance is already below the balance to be kept\n     * the tapped amount should be reset to zero\n    */\n    if (balance <= toBeKept) {\n        return 0;\n    }\n\n    /**\n     * the reserve's balance minus the upcoming tap flow would be below the balance to be kept\n     * the flow should be reduced to balance - toBeKept\n    */\n    if (balance <= toBeKept.add(tappedAmount)) {\n        return balance.sub(toBeKept);\n    }\n\n    /**\n     * the reserve's balance minus the upcoming flow is above the balance to be kept\n     * the flow can be added to the tapped amount\n    */\n    return tappedAmount;\n}\n```\n\r\nThat means that the amount that beneficiary can withdraw has just decreased, which should not be possible.\r\n\r\n#### Recommendation\r\n\r\nEnsure that `tappedAmount` cannot be decreased once updated.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "Presale - `contributionToken` double cast and invalid comparison",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe Presale can be configured to accept `ETH` or a valid `ERC20` token. This token is stored as an `ERC20` contract type in the state variable `contributionToken`. It is then directly compared to constant `ETH` which is `address(0x0)` in various locations. Additionally, the `_transfer` function double casts the `token` to `ERC20` if the `contributionToken` is passed as an argument.\r\n\r\n#### Examples\r\n\r\n* `contribute` - invalid comparison of contract type against `address(0x00)`. Even though this is accepted in solidity `<0.5.0` it is going to raise a compiler error with newer versions (`>=0.5.0`).\r\n\n**code/apps/presale/contracts/Presale.sol:L163-L170**\n```solidity\nfunction contribute(address _contributor, uint256 _value) external payable nonReentrant auth(CONTRIBUTE_ROLE) {\n    require(state() == State.Funding, ERROR_INVALID_STATE);\n\n    if (contributionToken == ETH) {\n        require(msg.value == _value, ERROR_INVALID_CONTRIBUTE_VALUE);\n    } else {\n        require(msg.value == 0,      ERROR_INVALID_CONTRIBUTE_VALUE);\n    }\n```\n\r\n* `_transfer` - double cast `token` to `ERC20` if it is the contribution token.\r\n\n**code/apps/presale/contracts/Presale.sol:L344-L344**\n```solidity\nrequire(ERC20(_token).safeTransfer(_to, _amount), ERROR_TOKEN_TRANSFER_REVERTED);\n```\n\r\n#### Recommendation\r\n\r\n`contributionToken` can either be `ETH` or a valid `ERC20` contract address. It is therefore recommended to store the token as an address type instead of the more precise contract type to resolve the double cast and the invalid contract type to address comparison or cast the `ERC20` type to `address()` before comparison.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "Presale - should not allow zero value contributions",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe Presale accepts zero value contributions emitting a contribution event if none of the Aragon components (TokenManager, MinimeToken) raises an exception.\r\n\r\n\n**code/apps/presale/contracts/Presale.sol:L163-L173**\n```solidity\nfunction contribute(address _contributor, uint256 _value) external payable nonReentrant auth(CONTRIBUTE_ROLE) {\n    require(state() == State.Funding, ERROR_INVALID_STATE);\n\n    if (contributionToken == ETH) {\n        require(msg.value == _value, ERROR_INVALID_CONTRIBUTE_VALUE);\n    } else {\n        require(msg.value == 0,      ERROR_INVALID_CONTRIBUTE_VALUE);\n    }\n\n    _contribute(_contributor, _value);\n}\n```\n\r\n#### Recommendation\r\n\r\nReject zero value `ETH` or `ERC20` contributions.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "FundraisingMultisigTemplate - unused import `ERC20`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe interface `ERC20` is imported but never used.\r\n\r\n\n**code/templates/multisig/contracts/FundraisingMultisigTemplate.sol:L4-L4**\n```solidity\nimport \"@aragon/os/contracts/lib/token/ERC20.sol\";\n```\n\r\n#### Recommendation\r\n\r\nRemove the unused import.",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "FundraisingMultisigTemplate - DAI/ANT token address cannot be zero",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe fundraising template is configured with the `DAI` and `ANT` token address upon deployment and checks if the provided addresses are valid. The check performed is `_ensureTokenIsContractOrETH()` which allows the `address(0)` (constant for `ETH`) for the token contracts. However, `address(0)` is not a valid option for either `DAI` or `ANT` and the contract expects a valid token address to be provided as the deployment of a new DAO will have unexpected results (collateral `ETH` is added instead of an ERC20 token) or fail (`DAI` == `ANT` == `0x0`).\r\n\r\n\n**code/templates/multisig/contracts/FundraisingMultisigTemplate.sol:L71-L72**\n```solidity\n_ensureTokenIsContractOrETH(_dai);\n_ensureTokenIsContractOrETH(_ant);\n```\n\r\n\n**code/templates/multisig/contracts/FundraisingMultisigTemplate.sol:L572-L575**\n```solidity\n\n function _ensureTokenIsContractOrETH(address _token) internal view returns (bool) {\n    require(isContract(_token) || _token == ETH, ERROR_BAD_SETTINGS);\n}\n```\n\r\n#### Recommendation\r\n\r\nUse `isContract()` instead of `_ensureTokenIsContractOrETH()` and optionally require that `collateral[0] != collateral[1]` as an additional check to prevent that the fundraising template is being deployed with an invalid configuration.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2019/11/aragonblack-fundraising/",
      "repo": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/",
      "url": "https://consensys.net//diligence/audits/2019/11/aragonblack-fundraising/"
    }
  },
  {
    "title": "Lack of reentrancy protection in token interactions",
    "severity": "major",
    "body": "#### Description\r\n\r\nToken operations may potentially re-enter the system. For example, `univTransfer` may perform a low-level `to.call{value}()` and, depending on the token's specification (e.g. `ERC-20` extension or `ERC-20` compliant `ERC-777`), `token` may implement callbacks when being called as ` token.safeTransfer(to, amount)` (or `token.transfer*()`).\r\n\r\nTherefore, it is crucial to strictly adhere to the checks-effects pattern and safeguard affected methods using a mutex.\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/fantom/libraries/LibUniversalERC20FTM.sol:L26-L40**\n```solidity\nfunction univTransfer(\n  IERC20 token,\n  address payable to,\n  uint256 amount\n) internal {\n  if (amount > 0) {\n    if (isFTM(token)) {\n      (bool sent, ) = to.call{ value: amount }(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      token.safeTransfer(to, amount);\n    }\n  }\n}\n\n```\n\r\n* `withdraw` is `nonReentrant` while `paybackAndWithdraw` is not, which appears to be inconsistent\r\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L172-L182**\n```solidity\n/**\n * @dev Paybacks the underlying asset and withdraws collateral in a single function call from activeProvider\n * @param _paybackAmount: amount of underlying asset to be payback, pass -1 to pay full amount\n * @param _collateralAmount: amount of collateral to be withdrawn, pass -1 to withdraw maximum amount\n */\nfunction paybackAndWithdraw(int256 _paybackAmount, int256 _collateralAmount) external payable {\n  updateF1155Balances();\n  _internalPayback(_paybackAmount);\n  _internalWithdraw(_collateralAmount);\n}\n\n```\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L232-L241**\n```solidity\n/**\n * @dev Paybacks Vault's type underlying to activeProvider - called by users\n * @param _repayAmount: token amount of underlying to repay, or\n * pass any 'negative number' to repay full ammount\n * Emits a {Repay} event.\n */\nfunction payback(int256 _repayAmount) public payable override {\n  updateF1155Balances();\n  _internalPayback(_repayAmount);\n}\n```\n\r\n\r\n\r\n* `depositAndBorrow` is not `nonReentrant` while `borrow()` is which appears to be inconsistent\r\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L161-L171**\n```solidity\n/**\n * @dev Deposits collateral and borrows underlying in a single function call from activeProvider\n * @param _collateralAmount: amount to be deposited\n * @param _borrowAmount: amount to be borrowed\n */\nfunction depositAndBorrow(uint256 _collateralAmount, uint256 _borrowAmount) external payable {\n  updateF1155Balances();\n  _internalDeposit(_collateralAmount);\n  _internalBorrow(_borrowAmount);\n}\n\n```\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L222-L230**\n```solidity\n/**\n * @dev Borrows Vault's type underlying amount from activeProvider\n * @param _borrowAmount: token amount of underlying to borrow\n * Emits a {Borrow} event.\n */\nfunction borrow(uint256 _borrowAmount) public override nonReentrant {\n  updateF1155Balances();\n  _internalBorrow(_borrowAmount);\n}\n```\n\r\nHere's an example call stack for `depositAndBorrow` that outlines how a reentrant `ERC20` token (e.g. `ERC777`) may call back into `depositAndBorrow` again, `updateBalances` twice in the beginning before tokens are even transferred and then continues to call `internalDeposit`, `internalBorrow`, `internalBorrow` without an update before the 2nd borrow. Note that both `internalDeposit` and `internalBorrow` read indexes that may now be outdated.\r\n\r\n```console\r\ndepositAndBorrow\r\n    updateBalances\r\n    internalDeposit ->\r\n                        ERC777(collateralAsset).safeTransferFrom()  ---> calls back!\r\n                        ---callback:beforeTokenTransfer---->\r\n                                !! depositAndBorrow\r\n                                        updateBalances\r\n                                        internalDeposit\r\n                                            --> ERC777.safeTransferFrom()\r\n                                            <--\r\n                                            _deposit\r\n                                            mint\r\n                                        internalBorrow\r\n                                            mint\r\n                                            _borrow\r\n                                            ERC777(borrowAsset).univTransfer(msg.sender) --> might call back\r\n\r\n                    <-------------------------------\r\n                    _deposit\r\n                    mint\r\n    internalBorrow \r\n        mint\r\n        _borrow               \r\n        --> ERC777(borrowAsset).univTransfer(msg.sender) --> might call back\r\n        <--\r\n```\r\n\r\n#### Recommendation\r\n\r\nConsider decorating methods that may call back to untrusted sources (i.e., native token transfers, callback token operations) as `nonReentrant` and strictly follow the checks-effects pattern for all contracts in the code-base. \r\n\r\n\r\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Unchecked Return Values - ICErc20 `repayBorrow`",
    "severity": "major",
    "body": "#### Description\r\n\r\n`ICErc20.repayBorrow` returns a non-zero uint on error. Multiple providers do not check for this error condition and might return `success` even though `repayBorrow` failed, returning an error code. \r\n\r\nThis can potentially allow a malicious user to call `paybackAndWithdraw()` while not repaying by causing an error in the sub-call to `Compound.repayBorrow()`, which ends up being silently ignored. Due to the missing success condition check, execution continues normally with `_internalWithdraw()`.\r\n\r\nAlso, see 20.\r\n\r\n\n**code/contracts/interfaces/compound/ICErc20.sol:L11-L12**\n```solidity\n\nfunction repayBorrow(uint256 repayAmount) external returns (uint256);\n```\n\r\nThe method may return an error due to multiple reasons:\r\n\r\n\n**contracts/CToken.sol:L808-L816**\n```solidity\nfunction repayBorrowInternal(uint repayAmount) internal nonReentrant returns (uint, uint) {\n    uint error = accrueInterest();\n    if (error != uint(Error.NO_ERROR)) {\n        // accrueInterest emits logs on errors, but we still want to log the fact that an attempted borrow failed\n        return (fail(Error(error), FailureInfo.REPAY_BORROW_ACCRUE_INTEREST_FAILED), 0);\n    }\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    return repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n}\n```\n\r\n\n**contracts/CToken.sol:L855-L873**\n```solidity\nif (allowed != 0) {\n    return (failOpaque(Error.COMPTROLLER_REJECTION, FailureInfo.REPAY_BORROW_COMPTROLLER_REJECTION, allowed), 0);\n}\n\n/* Verify market's block number equals current block number */\nif (accrualBlockNumber != getBlockNumber()) {\n    return (fail(Error.MARKET_NOT_FRESH, FailureInfo.REPAY_BORROW_FRESHNESS_CHECK), 0);\n}\n\nRepayBorrowLocalVars memory vars;\n\n/* We remember the original borrowerIndex for verification purposes */\nvars.borrowerIndex = accountBorrows[borrower].interestIndex;\n\n/* We fetch the amount the borrower owes, with accumulated interest */\n(vars.mathErr, vars.accountBorrows) = borrowBalanceStoredInternal(borrower);\nif (vars.mathErr != MathError.NO_ERROR) {\n    return (failOpaque(Error.MATH_ERROR, FailureInfo.REPAY_BORROW_ACCUMULATED_BALANCE_CALCULATION_FAILED, uint(vars.mathErr)), 0);\n}\n```\n\r\n#### Examples\r\n\r\nMultiple providers, here are some examples:\r\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L168-L173**\n```solidity\n\n  // Check there is enough balance to pay\n  require(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");\n  erc20token.univApprove(address(cyTokenAddr), _amount);\n  cyToken.repayBorrow(_amount);\n}\n```\n\r\n\n**code/contracts/fantom/providers/ProviderScream.sol:L170-L172**\n```solidity\nrequire(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");\nerc20token.univApprove(address(cyTokenAddr), _amount);\ncyToken.repayBorrow(_amount);\n```\n\r\n\n**code/contracts/mainnet/providers/ProviderCompound.sol:L139-L155**\n```solidity\nif (_isETH(_asset)) {\n  // Create a reference to the corresponding cToken contract\n  ICEth cToken = ICEth(cTokenAddr);\n\n  cToken.repayBorrow{ value: msg.value }();\n} else {\n  // Create reference to the ERC20 contract\n  IERC20 erc20token = IERC20(_asset);\n\n  // Create a reference to the corresponding cToken contract\n  ICErc20 cToken = ICErc20(cTokenAddr);\n\n  // Check there is enough balance to pay\n  require(erc20token.balanceOf(address(this)) >= _amount, \"Not-enough-token\");\n  erc20token.univApprove(address(cTokenAddr), _amount);\n  cToken.repayBorrow(_amount);\n}\n```\n\r\n\r\n\r\n#### Recommendation\r\n\r\nCheck for `cyToken.repayBorrow(_amount) != 0` or `Error.NO_ERROR`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Unsafe arithmetic casts",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe reason for using signed integers in some situations appears to be to use negative values as an indicator to withdraw everything. Using a whole bit of uint256 for this is quite a lot when using `type(uint256).max` would equal or better serve as a flag to withdraw everything.\r\n\r\nFurthermore, even though the code uses `solidity 0.8.x`, which safeguards arithmetic operations against under/overflows, arithmetic typecast is not protected.\r\n\r\nAlso, see 26 for a related issue.\r\n\r\n```console\r\n⇒  solidity-shell\r\n\r\n🚀 Entering interactive Solidity ^0.8.11 shell. '.help' and '.exit' are your friends.\r\n »  ℹ️  ganache-mgr: starting temp. ganache instance ...\r\n »  uint(int(-100))\r\n115792089237316195423570985008687907853269984665640564039457584007913129639836\r\n »  int256(uint(2**256-100))\r\n-100\r\n```\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/fantom/FliquidatorFTM.sol:L167-L178**\n```solidity\n// Compute how much collateral needs to be swapt\nuint256 collateralInPlay = _getCollateralInPlay(\n  vAssets.collateralAsset,\n  vAssets.borrowAsset,\n  debtTotal + bonus\n);\n\n// Burn f1155\n_burnMulti(addrs, borrowBals, vAssets, _vault, f1155);\n\n// Withdraw collateral\nIVault(_vault).withdrawLiq(int256(collateralInPlay));\n```\n\r\n\n**code/contracts/fantom/FliquidatorFTM.sol:L264-L276**\n```solidity\n// Compute how much collateral needs to be swapt for all liquidated users\nuint256 collateralInPlay = _getCollateralInPlay(\n  vAssets.collateralAsset,\n  vAssets.borrowAsset,\n  _amount + _flashloanFee + bonus\n);\n\n// Burn f1155\n_burnMulti(_addrs, _borrowBals, vAssets, _vault, f1155);\n\n// Withdraw collateral\nIVault(_vault).withdrawLiq(int256(collateralInPlay));\n\n```\n\r\n\n**code/contracts/fantom/FliquidatorFTM.sol:L334-L334**\n```solidity\nuint256 amount = _amount < 0 ? debtTotal : uint256(_amount);\n```\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L213-L220**\n```solidity\nfunction withdrawLiq(int256 _withdrawAmount) external override nonReentrant onlyFliquidator {\n  // Logic used when called by Fliquidator\n  _withdraw(uint256(_withdrawAmount), address(activeProvider));\n  IERC20Upgradeable(vAssets.collateralAsset).univTransfer(\n    payable(msg.sender),\n    uint256(_withdrawAmount)\n  );\n}\n```\n\r\n* pot. unsafe truncation (unlikely)\r\n\r\n\n**code/contracts/FujiERC1155.sol:L53-L59**\n```solidity\nfunction updateState(uint256 _assetID, uint256 newBalance) external override onlyPermit {\n  uint256 total = totalSupply(_assetID);\n  if (newBalance > 0 && total > 0 && newBalance > total) {\n    uint256 newIndex = (indexes[_assetID] * newBalance) / total;\n    indexes[_assetID] = uint128(newIndex);\n  }\n}\n```\n\r\n#### Recommendation\r\n\r\nIf negative values are only used as a flag to indicate that all funds should be used for an operation, use `type(uint256).max` instead. It is wasting less value-space for a simple flag than using the uint256 high-bit range. Avoid typecast where possible. Use `SafeCast` instead or verify that the casts are safe because the values they operate on cannot under- or overflow. Add inline code comments if that's the case.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Separation of concerns and consistency in vaults",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe `FujiVaultFTM` contract contains multiple balance-changing functions. Most notably, `withdraw` is passed an `int256` denoted amount parameter. Negative values of this parameter are given to the `_internalWithdraw` function, where they trigger the withdrawal of all collateral. This approach can result in accounting mistakes in the future as beyond a certain point in the vault's accounting; amounts are expected to be only positive. Furthermore, the concerns of withdrawing and entirely withdrawing are not separated.\r\n\r\nThe above issue applies analogously to the `payback` function and its dependency on `_internalPayback`.\r\n\r\nFor consistency, `withdrawLiq` also takes an `int256` amount parameter. This function is only accessible to the `Fliquidator` contract and withdraws collateral from the active provider. However, all occurrences of the `_withdrawAmount` parameter are cast to `uint256`.\r\n\r\n#### Examples\r\n\r\nThe `withdraw` entry point:\r\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L201-L204**\n```solidity\nfunction withdraw(int256 _withdrawAmount) public override nonReentrant {\n  updateF1155Balances();\n  _internalWithdraw(_withdrawAmount);\n}\n```\n\r\n`_internalWithdraw`'s negative amount check:\r\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L654-L657**\n```solidity\nuint256 amountToWithdraw = _withdrawAmount < 0\n  ? providedCollateral - neededCollateral\n  : uint256(_withdrawAmount);\n\n```\n\r\nThe `withdrawLiq` entry point for the `Fliquidator`:\r\n\r\n\n**code/contracts/fantom/FujiVaultFTM.sol:L213-L220**\n```solidity\nfunction withdrawLiq(int256 _withdrawAmount) external override nonReentrant onlyFliquidator {\n  // Logic used when called by Fliquidator\n  _withdraw(uint256(_withdrawAmount), address(activeProvider));\n  IERC20Upgradeable(vAssets.collateralAsset).univTransfer(\n    payable(msg.sender),\n    uint256(_withdrawAmount)\n  );\n}\n```\n\r\n#### Recommendation\r\n\r\nWe recommend splitting the `withdraw(int256)` function into two: `withdraw(uint256)` and `withdrawAll()`. These will provide the same functionality while rendering the updated code of `_internalWithdraw` easier to read, maintain, and harder to manipulate. The recommendation applies to `payback` and `_internalPayback`.\r\n\r\nSimilarly, `withdrawLiq`'s parameter should be a `uint256` to prevent unnecessary casts.",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Aave/Geist Interface declaration mismatch and unchecked return values",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe two lending providers, Geist & Aave, do not seem to be directly affiliated even though one is a fork of the other. However, the interfaces may likely diverge in the future. Using the same interface declaration for both protocols might become problematic with future upgrades to either protocol.\r\nThe interface declaration does not seem to come from the original upstream project. The interface `IAaveLendingPool` does not declare any return values while some of the functions called in Geist or Aave return them.\r\n\r\n**Note:** that we have not verified all interfaces for correctness. However, we urge the client to only use official interface declarations from the upstream projects and verify that all other interfaces match.\r\n\r\n#### Examples\r\n\r\nThe `ILendingPool` configured in `ProviderAave` (`0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5` -> implementation: `0xc6845a5c768bf8d7681249f8927877efda425baf`)\r\n\r\n\n**code/contracts/mainnet/providers/ProviderAave.sol:L19-L21**\n```solidity\nfunction _getAaveProvider() internal pure returns (IAaveLendingPoolProvider) {\n  return IAaveLendingPoolProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\n}\n```\n\r\nThe `IAaveLendingPool` does not declare return values for any function, while upstream does.\r\n\r\n\n**code/contracts/interfaces/aave/IAaveLendingPool.sol:L1-L46**\n```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ninterface IAaveLendingPool {\n  function flashLoan(\n    address receiverAddress,\n    address[] calldata assets,\n    uint256[] calldata amounts,\n    uint256[] calldata modes,\n    address onBehalfOf,\n    bytes calldata params,\n    uint16 referralCode\n  ) external;\n\n  function deposit(\n    address _asset,\n    uint256 _amount,\n    address _onBehalfOf,\n    uint16 _referralCode\n  ) external;\n\n  function withdraw(\n    address _asset,\n    uint256 _amount,\n    address _to\n  ) external;\n\n  function borrow(\n    address _asset,\n    uint256 _amount,\n    uint256 _interestRateMode,\n    uint16 _referralCode,\n    address _onBehalfOf\n  ) external;\n\n  function repay(\n    address _asset,\n    uint256 _amount,\n    uint256 _rateMode,\n    address _onBehalfOf\n  ) external;\n\n  function setUserUseReserveAsCollateral(address _asset, bool _useAsCollateral) external;\n}\n\n```\n\r\nMethods: `withdraw()`, `repay()` return `uint256` in the original implementation for Aave, see:\r\n\r\nhttps://etherscan.io/address/0xc6845a5c768bf8d7681249f8927877efda425baf#code\r\n\r\nThe `ILendingPool` configured for Geist:\r\n\r\nMethods `withdraw()`, `repay()` return `uint256` in the original implementation for Geist, see:\r\n\r\nhttps://ftmscan.com/address/0x3104ad2aadb6fe9df166948a5e3a547004862f90#code\r\n\r\n**Note:** that the actual amount withdrawn does not necessarily need to match the `amount` provided with the function argument. Here's an excerpt of the upstream `LendingProvider.withdraw()`:\r\n\r\n```solidity\r\n...\r\n    if (amount == type(uint256).max) {\r\n      amountToWithdraw = userBalance;\r\n    }\r\n...\r\n   return amountToWithdraw;\r\n```\r\n\r\nAnd here's the code in Fuji that calls that method. This will break the `withdrawAll` functionality of `LendingProvider` if token `isFTM`.\r\n\r\n\n**code/contracts/fantom/providers/ProviderGeist.sol:L151-L165**\n```solidity\nfunction withdraw(address _asset, uint256 _amount) external payable override {\n  IAaveLendingPool aave = IAaveLendingPool(_getAaveProvider().getLendingPool());\n\n  bool isFtm = _asset == _getFtmAddr();\n  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;\n\n  aave.withdraw(_tokenAddr, _amount, address(this));\n\n  // convert WFTM to FTM\n  if (isFtm)  {\n    address unwrapper = _getUnwrapper();\n    IERC20(_tokenAddr).univTransfer(payable(unwrapper), _amount);\n    IUnwrapper(unwrapper).withdraw(_amount);\n  }\n}\n```\n\r\nSimilar for `repay()`, which returns the actual amount repaid.\r\n\r\n#### Recommendation\r\n\r\n* Always use the original interface unless only a minimal subset of functions is used.\r\n* Use the original upstream interfaces of the corresponding project (link via the respective npm packages if available).\r\n* Avoid omitting parts of the function declaration! Especially when it comes to return values.\r\n* Check return values. Use the value returned from `withdraw()` AND `repay()`\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Inconsistent `isFTM`, `isETH` checks",
    "severity": "minor",
    "body": "#### Description\r\n\r\n`LibUniversalERC20FTM.isFTM()` and `LibUniversalERC20.isETH()` identifies native assets by matching against two distinct addresses while some components only check for one.\r\n\r\n#### Examples\r\n\r\nThe same is true for `FTM`.\r\n\r\n* `Flasher` only identifies a native asset transfer by matching `asset` against `_ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` while `univTransfer()` identifies it using `0x0 || 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE`\r\n\r\n\n**code/contracts/mainnet/flashloans/Flasher.sol:L122-L141**\n```solidity\nfunction callFunction(\n  address sender,\n  Account.Info calldata account,\n  bytes calldata data\n) external override {\n  require(msg.sender == _dydxSoloMargin && sender == address(this), Errors.VL_NOT_AUTHORIZED);\n  account;\n\n  FlashLoan.Info memory info = abi.decode(data, (FlashLoan.Info));\n\n  uint256 _value;\n  if (info.asset == _ETH) {\n    // Convert WETH to ETH and assign amount to be set as msg.value\n    _convertWethToEth(info.amount);\n    _value = info.amount;\n  } else {\n    // Transfer to Vault the flashloan Amount\n    // _value is 0\n    IERC20(info.asset).univTransfer(payable(info.vault), info.amount);\n  }\n```\n\r\n* `LibUniversalERC20`\r\n\r\n\n**code/contracts/mainnet/libraries/LibUniversalERC20.sol:L8-L16**\n```solidity\nlibrary LibUniversalERC20 {\n  using SafeERC20 for IERC20;\n\n  IERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n  IERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\n  function isETH(IERC20 token) internal pure returns (bool) {\n    return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\n  }\n```\n\r\n\n**code/contracts/mainnet/libraries/LibUniversalERC20.sol:L26-L40**\n```solidity\nfunction univTransfer(\n  IERC20 token,\n  address payable to,\n  uint256 amount\n) internal {\n  if (amount > 0) {\n    if (isETH(token)) {\n      (bool sent, ) = to.call{ value: amount }(\"\");\n      require(sent, \"Failed to send Ether\");\n    } else {\n      token.safeTransfer(to, amount);\n    }\n  }\n}\n\n```\n\r\n* There are multiple other instances of this\r\n\r\n\n**code/contracts/mainnet/Fliquidator.sol:L162-L162**\n```solidity\nuint256 _value = vAssets.borrowAsset == ETH ? debtTotal : 0;\n```\n\r\n#### Recommendation\r\n\r\nConsider using a consistent way to identify native asset transfers (i.e. `ETH`, `FTM`) by using `LibUniversalERC20.isETH()`. Alternatively, the system can be greatly simplified by expecting WFTM and only working with it. This simplification will remove all special cases where the library must handle non-ERC20 interfaces.",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Reduce code complexity",
    "severity": null,
    "body": "#### Description\r\n\r\nThroughout the codebase, snippets of code and whole functions have been copy-pasted. This duplication significantly increases code complexity and the potential for bugs.\r\nWe recommend re-using code across modules or providing library contracts that implement re-usable code fragments.\r\n\r\n#### Examples\r\n\r\n* Providers should use `LibUniversalERC20FTM.isFTM` instead of re-implementing `Helper.isFTM`.\r\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L17-L19**\n```solidity\nfunction _isFTM(address token) internal pure returns (bool) {\n  return (token == address(0) || token == address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\n}\n```\n\r\n\n**code/contracts/fantom/providers/ProviderScream.sol:L17-L19**\n```solidity\nfunction _isFTM(address token) internal pure returns (bool) {\n  return (token == address(0) || token == address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\n}\n```\n\r\n* `ProviderGeist` should provide an internal method instead of implementing multiple variants of the `isFtm` to token address mapping. E.g., both calls do the same thing. They select a different return value from the external call. Avoid re-implementing an inconsistent `isFtm` variant. Require that `isFtm && amount != 0` on `deposit/payback`.\r\n\r\n\n**code/contracts/fantom/providers/ProviderGeist.sol:L57-L67**\n```solidity\nfunction getBorrowBalance(address _asset) external view override returns (uint256) {\n  IAaveDataProvider aaveData = _getAaveDataProvider();\n\n  bool isFtm = _asset == _getFtmAddr();\n  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;\n\n  (, , uint256 variableDebt, , , , , , ) = aaveData.getUserReserveData(_tokenAddr, msg.sender);\n\n  return variableDebt;\n}\n\n```\n\r\n\n**code/contracts/fantom/providers/ProviderGeist.sol:L43-L52**\n```solidity\nfunction getBorrowRateFor(address _asset) external view override returns (uint256) {\n  IAaveDataProvider aaveData = _getAaveDataProvider();\n\n  (, , , , uint256 variableBorrowRate, , , , , ) = IAaveDataProvider(aaveData).getReserveData(\n    _asset == _getFtmAddr() ? _getWftmAddr() : _asset\n  );\n\n  return variableBorrowRate;\n}\n\n```\n\r\nAlso, note the unnecessary double cast `IAaveDataProvider`.\r\n\r\n\n**code/contracts/fantom/providers/ProviderGeist.sol:L73-L87**\n```solidity\nfunction getBorrowBalanceOf(address _asset, address _who)\n  external\n  view\n  override\n  returns (uint256)\n{\n  IAaveDataProvider aaveData = _getAaveDataProvider();\n\n  bool isFtm = _asset == _getFtmAddr();\n  address _tokenAddr = isFtm ? _getWftmAddr() : _asset;\n\n  (, , uint256 variableDebt, , , , , , ) = aaveData.getUserReserveData(_tokenAddr, _who);\n\n  return variableDebt;\n}\n```\n\r\n* Consider removing support for the native currency altogether in favor of only accepting pre-wrapped `WFTM` (`WETH`). This should remove a lot of glue code currently implemented to auto-wrap/unwrap native currency.\r\n\r\n* Unused functionality\r\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L52-L57**\n```solidity\nfunction _exitCollatMarket(address _cyTokenAddress) internal {\n  // Create a reference to the corresponding network Comptroller\n  IComptroller comptroller = IComptroller(_getComptrollerAddress());\n\n  comptroller.exitMarket(_cyTokenAddress);\n}\n```",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Redundant harvest check in vault",
    "severity": null,
    "body": "#### Description\r\n\r\nIn the `FujiVaultFTM.harvestRewards` function, the check for a returned token's address in the if condition and `require` statement overlap with `tokenReturned != address(0)`.\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/mainnet/FujiVault.sol:L553-L555**\n```solidity\nif (tokenReturned != address(0)) {\n  uint256 tokenBal = IERC20Upgradeable(tokenReturned).univBalanceOf(address(this));\n  require(tokenReturned != address(0) && tokenBal > 0, Errors.VL_HARVESTING_FAILED);\n```\n\r\n#### Recommendation\r\n\r\nWe recommend removing one of the statements for gas savings and increased readability.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Redeclaration of constant values in multiple contracts",
    "severity": null,
    "body": "#### Description\r\n\r\nThroughout the codebase, constant values are redeclared in various contracts. This duplication makes the code harder to maintain and increases the risk for bugs.\r\nA central contract, e.g., `Constants.sol`, `ConstantsFTM.sol`, and `ConstantsETH.sol`, to declare the constants used throughout the codebase instead of redeclaring them in multiple source units can fix this issue.\r\nIdeally, for example, an address constant for an external component is only configured in a single place but consumed by multiple contracts. This will significantly reduce the potential for misconfiguration.\r\n\r\nAvoid hardcoded addresses and use meaningful, constant names for them.\r\n\r\nNote that the solidity compiler is going to inline constants where possible.\r\n\r\n#### Examples\r\n\r\n\n**code/contracts/mainnet/WETHUnwrapper.sol:L7-L9**\n```solidity\ncontract WETHUnwrapper {\n  address constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n```\n\r\n\n**code/contracts/mainnet/Swapper.sol:L16-L19**\n```solidity\naddress public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress public constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\naddress public constant SUSHI_ROUTER_ADDR = 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F;\n\n```\n\r\n\n**code/contracts/mainnet/FujiVault.sol:L32-L34**\n```solidity\n\naddress public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n```\n\r\n\n**code/contracts/mainnet/Fliquidator.sol:L31-L31**\n```solidity\naddress public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n```\n\r\n\n**code/contracts/mainnet/providers/ProviderCompound.sol:L14-L18**\n```solidity\ncontract HelperFunct {\n  function _isETH(address token) internal pure returns (bool) {\n    return (token == address(0) || token == address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE));\n  }\n\n```\n\r\n\n**code/contracts/mainnet/libraries/LibUniversalERC20.sol:L10-L14**\n```solidity\n\nIERC20 private constant _ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\nIERC20 private constant _ZERO_ADDRESS = IERC20(0x0000000000000000000000000000000000000000);\n\nfunction isETH(IERC20 token) internal pure returns (bool) {\n```\n\r\n\n**code/contracts/mainnet/flashloans/Flasher.sol:L34-L36**\n```solidity\naddress private constant _ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\naddress private constant _WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\n```\n\r\n* Use meaningful names instead of hardcoded addresses\r\n\r\n\n**code/contracts/mainnet/Harvester.sol:L20-L29**\n```solidity\nif (_farmProtocolNum == 0) {\n  transaction.to = 0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B;\n  transaction.data = abi.encodeWithSelector(\n    bytes4(keccak256(\"claimComp(address)\")),\n    msg.sender\n  );\n  claimedToken = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n} else if (_farmProtocolNum == 1) {\n  uint256 harvestType = abi.decode(_data, (uint256));\n\n```\n\r\n* Avoid unnamed hardcoded inlined addresses\r\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L157-L162**\n```solidity\nif (_isFTM(_asset)) {\n  // Transform FTM to WFTM\n  IWETH(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83).deposit{ value: _amount }();\n  _asset = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n}\n\n```\n\r\n* comptroller address - can also be `private constant` state variables as the compiler/preprocessor will inline them.\r\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L21-L31**\n```solidity\nfunction _getMappingAddr() internal pure returns (address) {\n  return 0x1eEdE44b91750933C96d2125b6757C4F89e63E20; // Cream fantom mapper\n}\n\nfunction _getComptrollerAddress() internal pure returns (address) {\n  return 0x4250A6D3BD57455d7C6821eECb6206F507576cD2; // Cream fantom\n}\n\nfunction _getUnwrapper() internal pure returns(address) {\n  return 0xee94A39D185329d8c46dEA726E01F91641E57346;\n}\n```\n\r\n* `WFTM` multiple re-declarations\r\n\r\n\n**code/contracts/fantom/WFTMUnwrapper.sol:L7-L9**\n```solidity\ncontract WFTMUnwrapper {\n  address constant wftm = 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n\n```\n\r\n\n**code/contracts/fantom/providers/ProviderGeist.sol:L27-L29**\n```solidity\nfunction _getWftmAddr() internal pure returns (address) {\n  return 0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83;\n}\n```\n\r\n\n**code/contracts/fantom/providers/ProviderCream.sol:L79-L81**\n```solidity\n  IWETH(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83).deposit{ value: _amount }();\n  _asset = address(0x21be370D5312f44cB42ce377BC9b8a0cEF1A4C83);\n}\n```",
    "dataSource": {
      "name": "/diligence/audits/2022/03/fuji-protocol/",
      "repo": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/",
      "url": "https://consensys.net//diligence/audits/2022/03/fuji-protocol/"
    }
  },
  {
    "title": "Unused or Redundant Imports in Multiple Contracts",
    "severity": null,
    "body": "#### Description\r\n\r\nMultiple contracts import unused or redundant libraries.\r\n\r\n#### `PrivateOffer`\r\n\r\n\n**contracts/PrivateOffer.sol:L4**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n```\n\r\n#### `PriceLinear`\r\n\r\n\n**contracts/PriceLinear.sol:L6**\n```solidity\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\n```\n\r\n\r\n#### `VestingCloneFactory`\r\n\r\n\n**contracts/factories/VestingCloneFactory.sol:L7**\n```solidity\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n```\n\r\n#### `PrivateOfferFactory`\r\n\r\n\n**contracts/factories/PrivateOfferFactory.sol:L4-L5**\n```solidity\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n```\n\r\n#### `PriceLinearCloneFactory`\r\n\r\n\n**contracts/factories/PriceLinearCloneFactory.sol:L7**\n```solidity\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n```\n\r\n#### `CrowdinvestingCloneFactory.sol`\r\n\r\n\n**contracts/factories/CrowdinvestingCloneFactory.sol:L7**\n```solidity\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n```\n\r\n#### Recommendation\r\n\r\nRemove unused or redundant imports.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/12/tokenize-it/",
      "repo": "https://consensys.net//diligence/audits/2023/12/tokenize-it/",
      "url": "https://consensys.net//diligence/audits/2023/12/tokenize-it/"
    }
  },
  {
    "title": "Context.sol Is Not Required in the Present Use Case.",
    "severity": "minor",
    "body": "#### Description\r\n`ContextUpgradeable.sol` contract that is used in the `DramMintable` contract can be regarded as a foundational contract, the methods of which are intended for overriding to facilitate the implementation of varying meta transaction logics. \r\n\r\n\n**contracts/token/ERC20/extensions/DramMintable.sol:L18-L23**\n```solidity\nabstract contract DramMintable is\n    Initializable,\n    IDramMintable,\n    ContextUpgradeable,\n    ERC20Upgradeable\n{\n```\n\r\nIn its isolated state, it brings no additional value but rather makes code evaluation more difficult.\r\n\r\n#### Recommendation\r\nIn the case of `DramMintable` `msg.sender` can be used directly. In the case where meta-transactions are planned to be utilized, \r\n`ContextUpgradeable.sol` has to be overridden accordingly.",
    "dataSource": {
      "name": "/diligence/audits/2023/08/dram-stablecoin/",
      "repo": "https://consensys.net//diligence/audits/2023/08/dram-stablecoin/",
      "url": "https://consensys.net//diligence/audits/2023/08/dram-stablecoin/"
    }
  },
  {
    "title": "RPC `starkNet_addErc20Token` - Should Ask for User Confirmation",
    "severity": "medium",
    "body": "#### Description\r\n\r\nThe RPC method upserts ERC20 tokens received via RPC without asking the user for confirmation. This would allow a connected dapp to insert/change ERC20 token information anytime. This can even be more problematic when multiple dapps are connected to the StarkNet-Snap (race conditions).\r\n\r\n\n**packages/starknet-snap/src/addErc20Token.ts:L30-L47**\n```solidity\n  validateAddErc20TokenParams(requestParamsObj, network);\n\n  const erc20Token: Erc20Token = {\n    address: tokenAddress,\n    name: tokenName,\n    symbol: tokenSymbol,\n    decimals: tokenDecimals,\n    chainId: network.chainId,\n  };\n\n  await upsertErc20Token(erc20Token, wallet, saveMutex);\n\n  console.log(`addErc20Token:\\nerc20Token: ${JSON.stringify(erc20Token)}`);\n  return erc20Token;\n} catch (err) {\n  console.error(`Problem found: ${err}`);\n  throw err;\n}\n```\n\r\n#### Recommendation\r\n\r\nAsk the user for confirmation when changing the snaps state.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/metamask/partner-snaps-starknetsnap/",
      "repo": "https://consensys.net//diligence/audits/2023/06/metamask/partner-snaps-starknetsnap/",
      "url": "https://consensys.net//diligence/audits/2023/06/metamask/partner-snaps-starknetsnap/"
    }
  },
  {
    "title": "Use of `selfdestruct` Deprecated in `VotingVault`",
    "severity": "minor",
    "body": "#### Description\r\n\r\nThe `VotingVault.withdrawTokens` function invokes the `selfdestruct` operation when the vault is empty so that it can't be used again.\r\n\r\nThe use of`selfdestruct` [has been deprecated](https://eips.ethereum.org/EIPS/eip-6049) and a breaking change in its future behavior is expected.\r\n\r\n#### Examples\r\n\r\n\n**contracts/sharedContracts/VotingVault.sol:L36-L39**\n```solidity\nfunction withdrawTokens(address to, uint256 amount) external onlyController {\n    TransferHelper.withdrawTokens(token, to, amount);\n    if (IERC20(token).balanceOf(address(this)) == 0) selfdestruct;\n}\n```\n\r\n#### Recommendation\r\n\r\nRemove the line that invokes `selfdestruct` and consider changing internal state so that future calls to `delegateTokens` always revert.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "repo": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "url": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/"
    }
  },
  {
    "title": "Balance of `msg.sender` Is Used Instead of the `from` Address",
    "severity": "minor",
    "body": "#### Description\r\nThe `TransferHelper` library has methods that allow transferring tokens directly or on behalf of a different wallet that previously approved the transfer. Those functions also check the sender balance before conducting the transfer. In the second case, where the transfer happens on behalf of someone the code is checking not the actual token spender balance, but the `msg.sender` balance instead.\r\n\r\n#### Examples\r\n\r\n\n**contracts/libraries/TransferHelper.sol:L18-L25**\n```solidity\nfunction transferTokens(\n  address token,\n  address from,\n  address to,\n  uint256 amount\n) internal {\n  uint256 priorBalance = IERC20(token).balanceOf(address(to));\n  require(IERC20(token).balanceOf(msg.sender) >= amount, 'THL01');\n```\n\r\n#### Recommendation\r\n\r\nUse the `from` parameter instead of `msg.sender`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "repo": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "url": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/"
    }
  },
  {
    "title": "Use `_beforeTokenTransfer` to Override Behavior in OpenZeppelin Token Contracts",
    "severity": null,
    "body": "#### Description\r\n\r\nContracts such as `TokenVestingPlans`, `VotingTokenVestingPlans`, `TokenLockupPlans_Bound`, and `VotingTokenLockupPlans_Bound` add special conditions for allowing the transfer of tokens by overriding the `transferFrom`, `_safeTransfer`, and `_transfer` functions in OpenZeppelin token contracts.  While workable this approach can be error-prone and may break during future upgrades to the underlying contracts.\r\n\r\nFor example, in the unreleased version of OpenZeppelin's contracts, the `ERC20._transfer` function is no longer virtual and contains the warning:\r\n\r\n> NOTE: This function is not virtual, {_update} should be overridden instead.\r\n\r\n#### Examples\r\n\r\n\n**contracts/VestingPlans/TokenVestingPlans.sol:L282**\n```solidity\nfunction transferFrom(address from, address to, uint256 tokenId) public override(IERC721, ERC721) {\n```\n\r\n\n**contracts/VestingPlans/TokenVestingPlans.sol:L291**\n```solidity\nfunction _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal override {\n```\n\r\n\n**contracts/LockupPlans/NonTransferable/TokenLockupPlans_Bound.sol:L21**\n```solidity\nfunction _transfer(address from, address to, uint256 tokenId) internal virtual override {\n```\n\r\n#### Recommendation\r\n\r\nOpenZeppelin recognizes this as a common use case and provides [a hook](https://docs.openzeppelin.com/contracts/4.x/extending-contracts#using-hooks) for cleaner control over transfer behavior.  Use the  [_beforeTokenTransfer](https://docs.openzeppelin.com/contracts/4.x/api/token/ERC20#ERC20-_beforeTokenTransfer-address-address-uint256-) hook with version 4 contracts to enforce transfer conditions.\r\n\r\nPlease note however that the `_beforeTokenTransfer` hook [will be deprecated in the next release of OpenZeppelin's contracts](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/CHANGELOG.md#erc20-erc721-and-erc1155) in favor of a new function called `_update`.\r\n\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "repo": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/",
      "url": "https://consensys.net//diligence/audits/2023/06/hedgey-token-lockup-and-vesting-plans/"
    }
  },
  {
    "title": "Bridge Token Would Be Locked and Cannot Bridge to Native Token ",
    "severity": "critical",
    "body": "#### Description\r\nIf the bridge token B of a native token A is already deployed and `confirmDeployment` is called on the other layer and `setDeployed` sets  A's `nativeToBridgedToken`  value to `DEPLOYED_STATUS`. The bridge token B cannot bridge to native token A in `completeBridging` function, because A's `nativeToBridgedToken`  value is not `NATIVE_STATUS`, as a result the native token won't be transferred to the receiver. User's bridge token will be locked in the original layer  \r\n \r\n#### Examples\r\n\n**contracts/TokenBridge.sol:L217-L229**\n```solidity\nif (nativeMappingValue == NATIVE_STATUS) {\n  // Token is native on the local chain\n  IERC20(_nativeToken).safeTransfer(_recipient, _amount);\n} else {\n  bridgedToken = nativeMappingValue;\n  if (nativeMappingValue == EMPTY) {\n    // New token\n    bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n    bridgedToNativeToken[bridgedToken] = _nativeToken;\n    nativeToBridgedToken[_nativeToken] = bridgedToken;\n  }\n  BridgedToken(bridgedToken).mint(_recipient, _amount);\n}\n```\n\r\n\n**contracts/TokenBridge.sol:L272-L279**\n```solidity\nfunction setDeployed(address[] memory _nativeTokens) external onlyMessagingService fromRemoteTokenBridge {\n  address nativeToken;\n  for (uint256 i; i < _nativeTokens.length; i++) {\n    nativeToken = _nativeTokens[i];\n    nativeToBridgedToken[_nativeTokens[i]] = DEPLOYED_STATUS;\n    emit TokenDeployed(_nativeTokens[i]);\n  }\n}\n```\n\r\n\r\n#### Recommendation\r\n\r\nAdd an condition `nativeMappingValue` = `DEPLOYED_STATUS` for native token transfer in `confirmDeployment`\r\n ```\r\nif (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS) {\r\n    IERC20(_nativeToken).safeTransfer(_recipient, _amount);\r\n```\r\n<!-- Supply advice on how to best fix the problem. -->\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/linea-canonical-token-bridge/",
      "repo": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/",
      "url": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/"
    }
  },
  {
    "title": "Bridges Don't Support Multiple Native Tokens, Which May Lead to Incorrect Bridging",
    "severity": "major",
    "body": "#### Description\r\nCurrently, the system design does not support the scenarios where native tokens with the same addresses (which is possible with the same deployer and nonce) on different layers can be bridged.\r\n\r\nFor instance,\r\nLet's consider, there is a native token `A` on `L1` which has already been bridged on `L2`. If anyone tries to bridge native token `B` on `L2` with the same address as token `A` , instead of creating a new bridge on `L1` and minting new tokens, the token bridge will transfer native token `A` on `L1` to the `_recipient` which is incorrect.\r\n\r\nThe reason is the mappings don't differentiate between the native tokens on two different Layers.\r\n```\r\n  mapping(address => address) public nativeToBridgedToken;\r\n  mapping(address => address) public bridgedToNativeToken;\r\n```\r\n\r\n#### Examples\r\n\r\n\n**contracts/TokenBridge.sol:L208-L220**\n```solidity\nfunction completeBridging(\n  address _nativeToken,\n  uint256 _amount,\n  address _recipient,\n  bytes calldata _tokenMetadata\n) external onlyMessagingService fromRemoteTokenBridge {\n  address nativeMappingValue = nativeToBridgedToken[_nativeToken];\n  address bridgedToken;\n\n  if (nativeMappingValue == NATIVE_STATUS) {\n    // Token is native on the local chain\n    IERC20(_nativeToken).safeTransfer(_recipient, _amount);\n  } else {\n```\n\r\n#### Recommendation\r\n\r\nRedesign the approach to handle the same native tokens on different layers. One possible approach could be to define the set of mappings for each layer.",
    "dataSource": {
      "name": "/diligence/audits/2023/06/linea-canonical-token-bridge/",
      "repo": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/",
      "url": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/"
    }
  },
  {
    "title": "Owner May Exploit Bridged Tokens",
    "severity": "major",
    "body": "#### Description\r\nThe function `setCustomContract` allows the owner, to define a custom ERC20 contract for the native token. However, it doesn't check whether the target contract has already been defined as a bridge to a native token or not. As a result, the owner \r\nmay take advantage of the design flaw and bridge another new native token that has not been bridged yet, to an already existing target(already a bridge for another native token). \r\nNow, if a user tries to bridge this native token, the token bridge on the source chain will take the user's tokens, and instead of deploying a new bridge on the destination chain, tokens will be minted to the `_recipient` on an existing bridge defined by the owner, or it can be any random EOA address to create a DoS.\r\n\r\nThe owner can also try to front-run calls to `completeBridging` for new Native Tokens on the destination chain, by setting a different bridge via `setCustomContract`. Although, the team states that the role will be controlled by a multi-sig which makes frontrunning less likely to happen.\r\n\r\n#### Examples\r\n\r\n\n**contracts/TokenBridge.sol:L341-L348**\n```solidity\nfunction setCustomContract(\n  address _nativeToken,\n  address _targetContract\n) external onlyOwner isNewToken(_nativeToken) {\n  nativeToBridgedToken[_nativeToken] = _targetContract;\n  bridgedToNativeToken[_targetContract] = _nativeToken;\n  emit CustomContractSet(_nativeToken, _targetContract);\n}\n```\n\r\n\n**contracts/TokenBridge.sol:L220-L229**\n```solidity\n} else {\n  bridgedToken = nativeMappingValue;\n  if (nativeMappingValue == EMPTY) {\n    // New token\n    bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\n    bridgedToNativeToken[bridgedToken] = _nativeToken;\n    nativeToBridgedToken[_nativeToken] = bridgedToken;\n  }\n  BridgedToken(bridgedToken).mint(_recipient, _amount);\n}\n```\n\r\n#### Recommendation\r\n\r\nMake sure, a native token should bridge to a single target contract. A possible approach could be to check whether the `bridgedToNativeToken` for a target is `EMPTY` or not. If it's not EMPTY, it means it's already a bridge for a native token and the function should revert. The same can be achieved by adding the modifier `isNewToken(_targetContract)`.\r\n\r\n**Note**:- However, it doesn't resolve the issue of frontrunning, even if the likelihood is less.",
    "dataSource": {
      "name": "/diligence/audits/2023/06/linea-canonical-token-bridge/",
      "repo": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/",
      "url": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/"
    }
  },
  {
    "title": "Incorrect Bridging Due to Address Collision & Inconsistent State of Native Tokens",
    "severity": "medium",
    "body": "#### Description\r\n**In the second round of the audit**, we discovered an edge case that may exist because of an address collision of native tokens. In the first round, we found 7 explaining how the bridges only support a single native token on both layers and may cause incorrect bridging. In response to that, the Linea team implemented a change that reverts whenever there is an attempt to bridge a native token with the same address on the other layer.\r\n\r\nHowever, the issue still exists because of the inconsistent state of native tokens while bridging. The reason is, there could be an attempt to bridge a token with the same address on both layers at the same time, which could be done deliberately by an attacker by monitoring the bridging call at source layer and frontrunning them on the destination layer. As a consequence, both the tokens will get the `NATIVE_STATUS` on both layers, as the bridges can't check the state of a token on the other layer while bridging. Now, the bridging that was initiated for a native token on the source layer will be completed with the native token on the destination layer, as the bridging was initiated at the same time.\r\n\r\n```\r\n    if (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS) {\r\n      // Token is native on the local chain\r\n      IERC20Upgradeable(_nativeToken).safeTransfer(_recipient, _amount);\r\n```\r\n\r\nFor the issue, the Linea team came back with the solution in the PR [1041](https://github.com/Consensys/zkevm-monorepo/pull/1041) with the final commit `a875e67e0681ce387825127a08f1f924991a274c`. The solution implemented adds a flag `_isNativeLayer` while sending the message to Message Service on source layer\r\n```\r\n    messageService.sendMessage{ value: msg.value }(\r\n      remoteSender,\r\n      msg.value, // fees\r\n      abi.encodeCall(ITokenBridge.completeBridging, (nativeToken, _amount, _recipient, _isNativeLayer, tokenMetadata))\r\n    );\r\n ```\r\n and is used to verify the state of native token on destination layer while calling `completeBridging`.\r\n```\r\n...\r\n    if (_isNativeLayer == false && (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS)) {\r\n      // Token is native on the local chain\r\n      IERC20Upgradeable(_nativeToken).safeTransfer(_recipient, _amount);\r\n    }\r\n    else{\r\n    ...\r\n          if (\r\n        nativeMappingValue == EMPTY ||\r\n        (_isNativeLayer && (nativeMappingValue == NATIVE_STATUS || nativeMappingValue == DEPLOYED_STATUS))\r\n      ) {\r\n              // New token\r\n        bridgedToken = deployBridgedToken(_nativeToken, _tokenMetadata);\r\n        bridgedToNativeToken[bridgedToken] = _nativeToken;\r\n        nativeToBridgedToken[_nativeToken] = bridgedToken;\r\n      }\r\n      BridgedToken(bridgedToken).mint(_recipient, _amount);\r\n      ...\r\n    }\r\n    \r\n```\r\nThe logic adds two conditional checks:\r\n1- If `_isNativeLayer ` is false, it means the token is not native on the source layer, and if for the same address the status is either Native or Deployed, then the native token of the destination layer should be bridged.\r\n2- If the flag is true, it means the token is native on the source layer, and if there exists a collision of the Native or Deployed status, then a new bridge token should be created.\r\n\r\n**Minting Bad Tokens**\r\nWe reviewed the PR and new integrations and found that it is still problematic. The reason is the bridging of a token with the same address, will create a `bridgedToken` on each layer. Now the `nativeToBridgedToken` status is no more Native or Deployed, but a bridge address. \r\nLet's call the native token `A` and bridgedToken be `B` and `C` on each layer respectively. Now if the bridgeToken `B` is tried to be bridged back to native token `A`, it'll be not possible, as while doing `completeBridging` both of the conditional checks will be unsatisfied. However, in any case, the bridge on the destination layer will still mint the `bridgedTokens`\r\n\r\n```\r\n      BridgedToken(bridgedToken).mint(_recipient, _amount);\r\n\r\n```\r\nAs an example, the `B` tokens can be bridged to mint `C` bridgedTokens and vice-versa as and when needed. So, now it is mandatory to call `confirmDeployment` in order to allow condition 1 to be satisfied for this bridging and avoid this kind of bad minting.",
    "dataSource": {
      "name": "/diligence/audits/2023/06/linea-canonical-token-bridge/",
      "repo": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/",
      "url": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/"
    }
  },
  {
    "title": "Upgradeability Concerns",
    "severity": "minor",
    "body": "#### Description\r\n**1- Using Standard Interfaces and Libraries instead of Upgradeable ones.**\r\n\r\n\n**contracts/TokenBridge.sol:L5-L10**\n```solidity\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { OwnableUpgradeable } from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport { PausableUpgradeable } from \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\";\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n```\n\r\nWe recommend using upgradeable interfaces and libraries to avoid any unexpected issues while contract upgrades, also increasing code readability.\r\n\r\n**2- Using Deprecated Files**\r\nThe contract imports file `draft-IERC20Permit` from the npm module `openzeppelin/contracts`. \r\n\n**contracts/TokenBridge.sol:L5**\n```solidity\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\n```\nHowever, the file has been deprecated now, as the EIP2612 has been finalized. We recommend using the correct file which is `extensions/IERC20Permit.sol` or the corresponding upgradeable one.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/06/linea-canonical-token-bridge/",
      "repo": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/",
      "url": "https://consensys.net//diligence/audits/2023/06/linea-canonical-token-bridge/"
    }
  },
  {
    "title": "`refund` – Attacker Can Lock Insurance Holder's Refunds by Calling `refund` Before a Refund Was Allocated",
    "severity": "critical",
    "body": "#### Description\r\n\r\n`addPremium` is used to determine the refund amount that an insurance holder is eligible to claim. The amount is stored in the `refundMap` mapping and can then later be claimed by anyone on behalf of an insurance holder by calling `refund`. The `refund` function can't be called more than once for a given combination of `policyIndex_`, `week_`, and `who_`, as it would revert with an \"Already refunded\" error. This gives an attacker the opportunity to call `refund` on behalf of any insurance holder with value 0 inside the `refundMap`, causing any future refund allocated for that holder in a given week and for a given policy to be locked forever in the contract (unless the contract is upgraded).\r\n\r\n#### Examples\r\n\r\n\n**contracts/Pool.sol:L341-L367**\n```solidity\nfunction refund(\n    uint256 policyIndex_,\n    uint256 week_,\n    address who_\n) external noReenter {\n    Coverage storage coverage = coverageMap[policyIndex_][week_][who_];\n\n    require(!coverage.refunded, \"Already refunded\");\n\n    uint256 allCovered = coveredMap[policyIndex_][week_];\n    uint256 amountToRefund = refundMap[policyIndex_][week_].mul(\n        coverage.amount).div(allCovered);\n    coverage.amount = coverage.amount.mul(\n        coverage.premium.sub(amountToRefund)).div(coverage.premium);\n    coverage.refunded = true;\n\n    IERC20(baseToken).safeTransfer(who_, amountToRefund);\n\n    if (eventAggregator != address(0)) {\n        IEventAggregator(eventAggregator).refund(\n            policyIndex_,\n            week_,\n            who_,\n            amountToRefund\n        );\n    }\n}\n```\n\r\n#### Recommendation\r\n\r\nThere should be a validation check at the beginning of the function that reverts if  `refundMap[policyIndex_][week_] == 0`.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2023/05/tidal/",
      "repo": "https://consensys.net//diligence/audits/2023/05/tidal/",
      "url": "https://consensys.net//diligence/audits/2023/05/tidal/"
    }
  },
  {
    "title": "Several Issues Related to Upgradeability of Contracts",
    "severity": "medium",
    "body": "#### Description\r\n\r\nWe did not find a proxy contract or factory in the repository, but the README contains the following information:\r\n\r\n\n**README.md:L11**\n```solidity\nEvery Pool is a standalone smart contract. It is made upgradeable with OpenZeppelin’s Proxy Upgrade Pattern.\n```\n\r\n\n**README.md:L56**\n```solidity\nAnd there will be multiple proxies and one implementation of the Pools, and one proxy and one implementation of EventAggregator.\n```\n\r\nThere are several issues related to upgradeability or, generally, using the contracts as implementations for proxies. All recommendations in this report assume that it is not necessary to remain compatible with an existing deployment.\r\n\r\nA. The `Pool.sol` file imports `Initializable.sol` from OpenZeppelin's `contracts-upgradeable` and several other files from their \"regular\" `contracts` package.\r\n\r\n\n**contracts/Pool.sol:L5-L10**\n```solidity\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n```\n\r\nThese two should not be mixed, and in an upgradeable context, all files should be imported from `contracts-upgradeable`. Note that the import of `Ownable.sol` in `NonReentrancy.sol` can be removed completely; see 12.\r\n\r\nB. If upgradeability is supposed to work with inheritance, there should be dummy variables at the end of each contract in the inheritance hierarchy. Some of these have to be removed when \"real\" state variables are added. More precisely, it is conventional to use a fixed-size `uint256` array `__gap`, such that the consecutively occupied slots at the beginning (for the \"real\" state variables) add up to 50 with the size of the array. If state variables are added later, the gap's size has to be reduced accordingly to maintain this invariant. Currently, the contracts do not declare such a `__gap` variable.\r\n\r\nC. Implementation contracts should not remain uninitalized. To prevent initialization by an attacker – which, in some cases, can have an impact on the proxy – the implementation contract's constructor should call `_disableInitializers`.\r\n\r\n#### Recommendation\r\n\r\n1. Refamiliarize yourself with the subtleties and pitfalls of upgradeable contracts, in particular regarding state variables and the storage gap. A lot of useful information can be found [here](https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable).\r\n2. Only import from `contracts-upgradeable`, not from `contracts`.\r\n3. Add appropriately-sized storage gaps at least to `PoolModel`, `NonReentrancy`, and `EventAggregator`. (Note that adding a storage gap to `NonReentrancy` will break compatibility with existing deployments.) Ideally, add comments and warnings to each file that state variables may only be added at the end, that the storage gap's size has to be reduced accordingly, and that state variables must not be removed, rearranged, or in any way altered (e.g., type, `constant`, `immutable`). No state variables should ever be added to the `Pool` contract, and a comment should make that clear.\r\n4. Add a constructor to `Pool` and `EventAggregator` that calls `_disableInitializers`.",
    "dataSource": {
      "name": "/diligence/audits/2023/05/tidal/",
      "repo": "https://consensys.net//diligence/audits/2023/05/tidal/",
      "url": "https://consensys.net//diligence/audits/2023/05/tidal/"
    }
  },
  {
    "title": "New interfaces can add malicious code without any delay or check",
    "severity": "major",
    "body": "#### Description\r\nGeode Finance uses an interesting system of contracts for each individual staked ETH derivative. At the base of it all is an ERC1155 gETH contract where planet id acts as a token id. To make it more compatible with the rest of DeFi the Geode team pairs it up with an ERC20 contract that users would normally interact with and where all the allowances are stored. Naturally, since the balances are stored in the gETH contract, ERC20 interfaces need to ask gETH contract to update the balance. It is done in a way where the gETH contract will perform any transfer requested by the interface since the interface is expected to do all the checks and accountings. The issue comes with the fact that planet maintainers can whitelist new interfaces and that process does not require any approval. Planet maintainers could whitelist an interface that will send all the available tokens to the maintainer's wallet for example. This essentially allows Planet maintainers to steal all derivative tokens in circulation in one transaction. \r\n\r\n#### Examples\r\n\r\n\n**code/contracts/Portal/utils/StakeUtilsLib.sol:L165-L173**\n```solidity\nfunction setInterface(\n    StakePool storage self,\n    DataStoreUtils.DataStore storage DATASTORE,\n    uint256 id,\n    address _interface\n) external {\n    DATASTORE.authenticate(id, true, [false, true, true]);\n    _setInterface(self, DATASTORE, id, _interface);\n}\n```\n\r\n#### Recommendation\r\n\r\n`gETH.sol` contract has a concept of avoiders. One of the ways to fix this issue is to have the avoidance be set on a per-interface basis and avoiding new interfaces by default. This way users will need to allow the new tokens to access the balances.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/11/geodefi/",
      "repo": "https://consensys.net//diligence/audits/2022/11/geodefi/",
      "url": "https://consensys.net//diligence/audits/2022/11/geodefi/"
    }
  },
  {
    "title": "Updating interfaces of derivatives is done in a dangerous and unpredictable manner.",
    "severity": "medium",
    "body": "#### Description\r\nGeode Finance codebase provides planet maintainers with the ability to enable or disable different contracts to act as the main token contract. In fact, multiple separate contracts can be used at the same time if decided so by the planet maintainer. Those contracts will have shared balances but will not share the allowances as you can see below:\r\n\r\n\n**code/contracts/Portal/helpers/ERC1155SupplyMinterPauser.sol:L47**\n```solidity\nmapping(uint256 => mapping(address => uint256)) private _balances;\n```\n\r\n\n**code/contracts/Portal/gETHInterfaces/ERC20InterfaceUpgradable.sol:L60**\n```solidity\nmapping(address => mapping(address => uint256)) private _allowances;\n```\n\r\nUnfortunately, this approach comes with some implications that are very hard to predict as they involve interactions with other systems, but is possible to say that the consequences of those implications will most always be negative. We will not be able to outline all the implications of this issue, but we can try and outline the pattern that they all would follow. \r\n\r\n#### Examples\r\nThere are really two ways to update an interface: set the new one and immediately unset the old one, or have them both run in parallel for some time. Let's look at them one by one.\r\n\r\nin the first case, the old interface is disabled immediately. Given that interfaces share balances that will lead to some very serious consequences. Imagine the following sequence:\r\n\r\n1) Alice deposits her derivatives into the DWP contract for liquidity mining.\r\n2) Planet maintainer updates the interface and immediately disables the old one.\r\n3) DWP contract now has the old tokens and the new ones. But only the new ones are accounted for in the storage and thus can be withdrawn. Unfortunately, the old tokens are disabled meaning that now both old and new tokens are lost.\r\n\r\nThis can happen in pretty much any contract and not just the DWP token. Unless the holders had enough time to withdraw the derivatives back to their wallets all the funds deposited into contracts could be lost.\r\n\r\nThis leads us to the second case where the two interfaces are active in parallel. This would solve the issue above by allowing Alice to withdraw the old tokens from the DWP and make the new tokens follow. Unfortunately, there is an issue in that case as well. \r\n\r\nSome DeFi contracts allow their owners to withdraw any tokens that are not accounted for by the internal accounting. DWP allows the withdrawal of admin fees if the contract has more tokens than `balances[]` store. Some contracts even allow to withdraw funds that were accidentally sent to the contract by people. Either to recover them or just as a part of dust collection. Let's call such contracts \"dangerous contracts\" for our purposes.\r\n\r\n1) Alice deposits her derivatives into the dangerous contract.\r\n2) Planet maintainer sets a new interface.\r\n2) Owner of the dangerous contract sees that some odd and unaccounted tokens landed in the contract. He learns those are real and are part of Geode ecosystem. So he takes them. \r\n3) Old tokens will follow the new tokens. That means Alice now has no claim to them and the contract that they just left has broken accounting since numbers there are not backed by tokens anymore. \r\n\r\n\r\nOne other issue we would like to highlight here is that despite the contracts being expected to have separate allowances, if the old contract has the allowance set, the initial 0 value of the new one will be ignored. Here is an example:\r\n\r\n1) Alice approves Bob for 100 derivatives.\r\n2) Planet maintainer sets a new interface. The new interface has no allowance from Alice to Bob.\r\n3) Bob still can transfer new tokens from Alice to himself by transferring the old tokens for which he still has the allowance. New token balances will be updated accordingly. \r\n\r\nAlice could also give Bob an allowance of 100 tokens in the new contract since that was her original intent, but this would mean that Bob now has 200 token allowance.\r\n\r\nThis is extremely convoluted and will most likely result in errors made by the planet maintainers when updating the interfaces.\r\n\r\n\r\n\r\n#### Recommendation\r\n\r\nThe safest option is to only allow a list of whitelisted interfaces to be used that are well-documented and audited. Planet maintainers could then choose the once that they see fit.\r\n",
    "dataSource": {
      "name": "/diligence/audits/2022/11/geodefi/",
      "repo": "https://consensys.net//diligence/audits/2022/11/geodefi/",
      "url": "https://consensys.net//diligence/audits/2022/11/geodefi/"
    }
  },
  {
    "title": "The withdrawal mechanism is overcomplicated",
    "severity": "medium",
    "body": "#### Description\r\n\r\nTo withdraw the funds, anyone who has the account in `PaymentRegistry` should call the `withdrawDeposit` function and go through the withdrawal process. After the lockdown period (30 days), the user will withdraw all the funds from the account. \r\n\r\n\n**code/src/payment/PaymentRegistry.sol:L160-L210**\n```solidity\nfunction withdrawDeposit(\n  address token\n)\n  external\n{\n  address owner = _getContextAccount();\n  uint256 lockedUntil = deposits[owner].withdrawalLockedUntil[token];\n\n  /* solhint-disable not-rely-on-time */\n\n  if (lockedUntil != 0 && lockedUntil <= now) {\n    deposits[owner].withdrawalLockedUntil[token] = 0;\n\n    address depositAccount = deposits[owner].account;\n    uint256 depositValue;\n\n    if (token == address(0)) {\n      depositValue = depositAccount.balance;\n    } else {\n      depositValue = ERC20Token(token).balanceOf(depositAccount);\n    }\n\n    _transferFromDeposit(\n      depositAccount,\n      owner,\n      token,\n      depositValue\n    );\n\n    emit DepositWithdrawn(\n      depositAccount,\n      owner,\n      token,\n      depositValue\n    );\n  } else {\n    _deployDepositAccount(owner);\n\n    lockedUntil = now.add(depositWithdrawalLockPeriod);\n\n    deposits[owner].withdrawalLockedUntil[token] = lockedUntil;\n\n    emit DepositWithdrawalRequested(\n      deposits[owner].account,\n      owner,\n      token,\n      lockedUntil\n    );\n  }\n  /* solhint-enable not-rely-on-time */\n}\n```\n\r\nDuring that period, everyone who has a channel with the user is forced to commit their channels or lose money from that channel. When doing so, every user will reset the initial lockdown period and the withdrawer should start the process again. \r\n\r\n\n**code/src/payment/PaymentRegistry.sol:L479-L480**\n```solidity\nif (deposits[sender].withdrawalLockedUntil[token] > 0) {\n  deposits[sender].withdrawalLockedUntil[token] = 0;\n```\n\r\nThere is no way for the withdrawer to close the channel by himself. If the withdrawer has N channels, it's theoretically possible to wait for up to N*(30 days) period and make N+2 transactions.\r\n\r\n#### Recommendation\r\n\r\nThere may be some minor recommendations on how to improve that without major changes:\r\n\r\n* When committing a payment channel, do not reset the lockdown period to zero. Two better option would be either not change it at all or extend to `now + depositWithdrawalLockPeriod` \r\n",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pillar/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pillar/",
      "url": "https://consensys.net//diligence/audits/2020/11/pillar/"
    }
  },
  {
    "title": "The lockdown period shouldn't be extended when called multiple times",
    "severity": "minor",
    "body": "#### Description\r\n\r\nIn order to withdraw a deposit from the `PaymentRegistry`, the account owner should call the `withdrawDeposit` function and wait for `depositWithdrawalLockPeriod` (30 days) before actually transferring all the tokens from the account.\r\n\r\nThe issue is that if the withdrawer accidentally calls it for the second time before these 30 days pass, the waiting period gets extended for 30 days again.\r\n\r\n\n**code/src/payment/PaymentRegistry.sol:L170-L199**\n```solidity\nif (lockedUntil != 0 && lockedUntil <= now) {\n  deposits[owner].withdrawalLockedUntil[token] = 0;\n\n  address depositAccount = deposits[owner].account;\n  uint256 depositValue;\n\n  if (token == address(0)) {\n    depositValue = depositAccount.balance;\n  } else {\n    depositValue = ERC20Token(token).balanceOf(depositAccount);\n  }\n\n  _transferFromDeposit(\n    depositAccount,\n    owner,\n    token,\n    depositValue\n  );\n\n  emit DepositWithdrawn(\n    depositAccount,\n    owner,\n    token,\n    depositValue\n  );\n} else {\n  _deployDepositAccount(owner);\n\n  lockedUntil = now.add(depositWithdrawalLockPeriod);\n\n```\n\r\n#### Recommendation\r\n\r\nOnly extend the waiting period when a withdrawal is requested for the first time. ",
    "dataSource": {
      "name": "/diligence/audits/2020/11/pillar/",
      "repo": "https://consensys.net//diligence/audits/2020/11/pillar/",
      "url": "https://consensys.net//diligence/audits/2020/11/pillar/"
    }
  },
  {
    "title": "6.4 Incorrect Return Type of Decimals",
    "body": "```\nCorrectness Low Version 1 Code Corrected\nCS-YVV3-\n```\ndecimals() of contract VaultV3 returns an uint256 which does not comply with the ERC20 standard\nwhere an uint8 is returned.\n\n\nCode corrected:\n\nThe type of the return value has been changed to uint8 which is compliant with the specification.",
    "dataSource": {
      "name": "ChainSecurity/Yearn-Smart-Contract-Audit_V3_Vaults_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/05/Yearn-Smart-Contract-Audit_V3_Vaults_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/05/Yearn-Smart-Contract-Audit_V3_Vaults_-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.5 Return Value of Burn Function",
    "body": "Note Version 1\n\nThe system supports tokens that implement the IMintBurnToken, i.e., functions transfer,\ntransferFrom and mint return a boolean value. However, burn function is assumed to not return a\n\n\nvalue but revert if unsuccessful. This behavior is in line with the implementations of USDC and\nERC20Burnable from OpenZeppelin.",
    "dataSource": {
      "name": "ChainSecurity/Circle-Smart-Contract-Audit-_-Cross-Chain-Transfer-Protocol-CCTP-_-EVM-Bridge-_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/Circle-Smart-Contract-Audit-_-Cross-Chain-Transfer-Protocol-CCTP-_-EVM-Bridge-_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/Circle-Smart-Contract-Audit-_-Cross-Chain-Transfer-Protocol-CCTP-_-EVM-Bridge-_-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.4 burn() Read-Only Reentrancy",
    "body": "```\nDesign Low Version 1 Risk Accepted\nISSUEIDPREFIX-\n```\nThe burn() function in the pair contract first reduces the total supply and the user's balance, then\ntransfers the underlying tokens, and last reduces the stored reserves. If the transferred token is a\nreentrant token, a state inconsistency between the supply and the stored reserves is created.\n\nNote that any computation based on the current supply and the underlying reserves may return wrong\nresults.\n\nRisk accepted:\n\nUSDFI has accepted the risk to keep their implementation closer to Uniswap V2.\n\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 4\n```\n- Contracts Do Not Extend the Interfaces Code Corrected\n- DOS on Gauges When Derived Supply Is 0 Code Corrected\n- ERC-2612 Violations Code Corrected\n- Lack of Testing Code Corrected\n\n```\nLow-Severity Findings 7\n```\n- Different Library Versions Code Corrected\n- Fees Claimable After 50 Weeks Specification Changed\n- Initial Referral Fee Code Corrected\n- Lack of Events Code Corrected\n- Maximum Referral Fee Code Corrected\n- Used Weights Are Not Reset Code Corrected\n- recoverERC20() Allows Recovering Arbitrary Tokens Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf"
    }
  },
  {
    "title": "6.11 recoverERC20() Allows Recovering",
    "body": "Arbitrary Tokens\n\n```\nCorrectness Low Version 1 Code Corrected\nISSUEIDPREFIX-\n```\nThe recoverERC20() function should according to the documentation allow the governance to\nwithdraw non-reward tokens from the bribe contract. However, reward tokens can be withdrawn, too.\n\n\nCode corrected:\n\nUSDFI correctly has changed to code to check that the token to be withdrawn is not a reward token.",
    "dataSource": {
      "name": "ChainSecurity/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/USDFI-Smart-Contract-Audit_AMM_Gauges_and_Bribes_ChainSecurity.pdf"
    }
  },
  {
    "title": "9.1 ChildERC721 Static domainSeparator",
    "body": "Note Version 1\n\nIn all variants of ChildERC721, once and only once upon deployment, domainSeparator gets\ncalculated using the name of token and chain ID:\n\n```\ndomainSeperator = keccak256(\nabi.encode(\nEIP712_DOMAIN_TYPEHASH,\nkeccak256(bytes(name)),\nkeccak256(bytes(ERC712_VERSION)),\naddress(this),\nbytes32(getChainId())\n)\n);\n```\nHowever, in RootChainManager and UChildERC20, a functionality is devised to let recomputation of\ndomainSeparator, e.g. when name of token gets updated. Despite the fact, that forking and a\nconsequent change of chain ID may not be very possible, implementing this functionality in derivations of\nERC721Child could make the system more robust.",
    "dataSource": {
      "name": "ChainSecurity/Polygon_PoS_Portal_-Smart-Contract-Audit_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/Polygon_PoS_Portal_-Smart-Contract-Audit_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/Polygon_PoS_Portal_-Smart-Contract-Audit_ChainSecurity.pdf"
    }
  },
  {
    "title": "5.1 Trade Function Discrepancy",
    "severity": "minor",
    "body": "Correctness Low Version 1 Risk Accepted\n\nUsers can call the trade functions tradeBySourceAmount and tradeByTargetAmount with\ntradeActions that contain the same strategy multiple times. During the execution of the trade\nfunctions, the corresponding strategies are updated after each trade action has been executed.\n\nThis is, however, not true for the view functions tradeSourceAmount and tradeTargetAmount: y\nand z values of the associated strategies are not updated during the execution. If the same strategy is\ntraded against multiple times in one call, the trade result might therefore diverge from the result of the\ncorresponding trade functions in the same state.\n\nRisk accepted:\n\nBancor accepts the risk with the following statement:\n\n```\nThis is a known issue and is considered an edge case with minimal risk, as matching is done by the\nSDK that prevents this case. The alternative would be to check for duplicate strategies during the\ntrade which would increase the gas costs for all trades, so we decided against adding such a check\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 2\n```\n- Overflow Might DOS the App Code Corrected\n- Price Precision Very Low for Some Tokens Code Corrected\n\n```\nMedium-Severity Findings 0\n```\n```\nLow-Severity Findings 4\n```\n- Missing Events Code Corrected\n- No Function for Fee Withdrawal Code Corrected\n- Read-only Reentrancy Code Corrected\n- Zero Amount ERC20 Transfers Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.6 Zero Amount ERC20 Transfers",
    "severity": "minor",
    "body": "Correctness Low Version 1 Code Corrected\n\nSome tokens revert on transfers of 0 amount. Calls to CarbonController.createStrategy\npotentially try to perform such 0-amount-transfers if one of the given orders does not contain liquidity.\nThe call would revert in this case.\n\nCode corrected:\n\nThe code now transfers tokens only if the amount is greater than 0.",
    "dataSource": {
      "name": "ChainSecurity/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/04/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/04/Bancor-Smart-Contract-Audit-_-Carbon-_-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.4 Sweeping Non-ERC20-Compatible Tokens",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nOptions.sweep allows any user to transfer any ERC20 compatible tokens owned by the contract to its\nowner. However, this call will fail for tokens that are not compliant with the ERC20 standard. The most\nprominent example is the USDT. USDT's transfer does not return any value in contrast to the ERC\nstandard. This means that transfer call will fail. In Solidity, this issue is tackled with the\nsafeTransfer call (see Openzeppelin's safeERC20).\n\nCode corrected:\n\nThe default_return_value=True parameter was added in the Options.sweep token transfer\ncall, that enables safeTransfer functionality in Vyper smart contracts.\n\n\n\nWe utilize this section to point out informational findings that are less severe than issues. These\ninformational issues allow us to point out more theoretical findings. Their explanation hopefully improves\nthe overall understanding of the project's security. Furthermore, we point out findings which are unrelated\nto security.",
    "dataSource": {
      "name": "ChainSecurity/Yearn-Smart-Contract-Audit-oYfi-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/Yearn-Smart-Contract-Audit-oYfi-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/Yearn-Smart-Contract-Audit-oYfi-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.8 Use of Non-standard ERC20 Tokens",
    "body": "Note Version 1\n\nManagers (and users) should be aware that using a non-standard ERC20 token as the underlying can be\ndangerous for the system. Non-standard ERC20 tokens include but are not limited to the following\nbehaviors:\n\nTokens With Reentrancies:\n\nIf a portfolio is set up with an underlying token that is reentrant (e.g., ERC-777), various possibilities of\nreentrancy attacks are enabled. Here is an example of one possible attack vector:\n\n- A portfolio consists of 3 tranches and is in Live status with no active loans.\n- Users have deposited 100 tokens to each tranche with no accrued interest (i.e. 1 share per token).\n- An attacker calls deposit on the junior tranche with 99 tokens.\n- In the safeTransferFrom call, the underlying token calls back to the attacker's contract.\n- At this point, the checkpoint of the junior tranche has already been updated, while the\n    virtualTokenBalance in the portfolio has not.\n- The attacker now reenters into the deposit function if the equity tranche with a deposit of 100 tokens.\n- 10,000 shares are minted to the attacker as the virtualTokenBalance is still 300, while the\n    checkpoints of senior and junior tranches return a sum of 299 tokens, leaving only 1 token for the\n    equity tranche waterfall value.\n- After the call, the attacker now holds shares representing 99 tokens in the junior tranche and ~198\n    tokens in the equity tranche resulting in an instant profit of ~98 tokens.\n\nTokens With Fees:\n\nWhen transferring tokens with fees, the receiver does not get the amount the sender sends but a part of it\nas fees are deducted. However, updating the virtualTokenBalance for example makes the\nassumption the whole amount has been received. Thus, repetitive transfers will create a discrepancy\nbetween the internal accounting of the portfolio which uses the virtualTokenBalance and the actual\namount held by the portfolio.\n\nRebasing Tokens:\n\nWith rebasing tokens, the amount of tokens each account holds changes over time. This will lead,\nsimilarly to tokens with fees, to internal accounting being wrong.\n\nPausable Tokens:\n\nWhen a token is paused, it might revert on every call to functions like transfer. As Carbon extensively\nuses transfers in many functions, the system could become unusable on such occasions.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_TrueFi_Carbon_-Smart-Contract-Audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_TrueFi_Carbon_-Smart-Contract-Audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_TrueFi_Carbon_-Smart-Contract-Audit.pdf"
    }
  },
  {
    "title": "5.2 BondBuyer: Claims Involving Ether Track",
    "body": "Wrong Asset\n\nCorrectness Low Version 1 Acknowledged\n\n\nClaiming a position involving Ether will result in the wrong asset being added to the tracked assets of the\nvault. Note that the vault actually supports receiving Ether (it immediately wraps it as WETH).\n\nConsider the parser of the SolvV2BondBuyerPosition:\n\n```\nelse if (_actionId == uint256(ISolvV2BondBuyerPosition.Actions.Claim)) {\n(address voucher, uint256 tokenId, ) = __decodeClaimActionArgs(_encodedActionArgs);\n```\n```\nISolvV2BondVoucher voucherContract = ISolvV2BondVoucher(voucher);\n```\n```\nuint256 slotId = voucherContract.voucherSlotMapping(tokenId);\nISolvV2BondPool.SlotDetail memory slotDetail = voucherContract.getSlotDetail(slotId);\n```\n```\nassetsToReceive_ = new address[](2);\nassetsToReceive_[0] = voucherContract.underlying();\nassetsToReceive_[1] = slotDetail.fundCurrency;\n```\nFor arbitrary vouchers, one of the assets may be Ether as Ether is technically supported by the Solv v\nsmart contracts.\n\nSolv v2 represents the Ether asset as \"0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\" which in\nthis case will be added to assetsToReceive. Within Enzyme, however, the correct asset to track in this\ncase would be the address of WETH.\n\nThis results in an unsupported asset being tracked by a vault which may have severe consequences. For\nexample, it breaks calcGav().\n\nWhether such vouchers actually exist depends on the market configurations administrated by Solv\nProtocol. These markets may change in the future. Since the external position may interact with any offer\non the IVOMarket / any voucher, such an issue may arise.\n\nThe InitialVoucherOfferingMarket currently doesn't support to create offers with Ether as underlying since\noffer() misses the payable modifier. Note that the implementation otherwise supports the case to\nhandle Ether.\n\nThe currency of a voucher may be Ether. Contrary to offer() buy() features the payable modifier\nand hence such vouchers can be bought successfully. Note that one can't buy such a position in Ether\nvia the external position since it doesn't support providing ERC20 tokens. This however doesn't prevent\nall scenarios where claim() may return Ether as such an NFT may be transferred directly to the\nexternal position.\n\nAcknowledged:\n\nAvantgarde Finance states:\n\n```\nWhile ETH can technically be the currency of the offer, Solv’s refund\nlogic depends on it being a stablecoin:\nhttps://github.com/solv-finance/solv-v2-ivo/blob/\nac12b7f91a7af67993a0501dc705687801eb3673/vouchers/bond-voucher/\ncontracts/BondPool.sol#L\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 0\n```\n```\nLow-Severity Findings 0\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf"
    }
  },
  {
    "title": "7.2 OpenZeppelin ERC20 Hooks",
    "severity": "info",
    "body": "Informational Version 1\n\nThe GatedRedemptionQueueSharesWrapperLib overrides transfer()/transferFrom() in order to\nvalidate the transfer (__preProcessTransfer).\n\nThe OpenZeppelin ERC20 implementation provides a hook, (_beforeTokenTransfer) which could be\nused for this. Note that this hook is also executed upon minting/burning. For more information please\nrefer to documentation of OpenZeppelin:\n\n- https://docs.openzeppelin.com/contracts/3.x/extending-contracts#using-hooks\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IX_audit.pdf"
    }
  },
  {
    "title": "5.10 Unused Imports",
    "severity": "minor",
    "body": "Design Low Version 1 Acknowledged\n\nThe contract PlatformFactory imports ERC20 but does not use it.\n\nAcknowldeged\n\nStakeDao acknowledges the issue. No actions are taken.",
    "dataSource": {
      "name": "ChainSecurity/Smart-Contract-Audit_StakeDao_Bribe_Platform_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/Smart-Contract-Audit_StakeDao_Bribe_Platform_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/Smart-Contract-Audit_StakeDao_Bribe_Platform_-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.2 BaseERC20 Overflow",
    "severity": "minor",
    "body": "Correctness Low Version 1 Risk Accepted\n\n\nThe _increaseBalance function of the BaseERC20 contract can overflow. While it is checked that the\naccount is not frozen (i.e. the first bit of the balance is zero), it is not guaranteed that the addition will\nresult in a number smaller than 2^255. Hence, an account could become frozen by increasing its balance\nabove this value.\n\nRisk accepted:\n\nAssuming a reasonable total supply of the token (less than 2^255), it is impossible for any individual\naccount to have a balance large enough to cause this overflow to happen. Thus, the overflow cannot\noccur under normal circumstances.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "5.4 ERC20Permit.receiveWithPermit Signature",
    "body": "Can Be Front-Run\n\nDesign Low Version 1 Risk Accepted\n\nSimilar to issue ERC20Permit.receiveWithSaltedPermit signature can be front-run, the signatures\nbetween ERC20Permit.permit and ERC20Permit.receiveWithPermit are interchangeable as\nwell.\n\nThus, the attacker can front-run the signatures and use them in unintended functions to cause a user's\ntransactions to fail. However, this does not render the ZkBob system unsecure itself but might cause\nproblems for 3rd party integrations. Thus, the severity of this issue is low.\n\nRisk accepted:\n\nBOB Protocol accepted the risk and stated:\n\n```\nThird party integrations relying on permit/receiveWithPermit are advised to implement necessary\nfallbacks for failing permit/receiveWithPermit calls, avoiding entire transaction failures.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- ZkBobPool Fees Can Drain the Deposits of the User Code Corrected\n\n```\nMedium-Severity Findings 1\n```\n- ERC20Permit.receiveWithSaltedPermit Signature Can Be Front-Run Code Corrected\n\n```\nLow-Severity Findings 5\n```\n- Admin Reentrancy in ERC20Recovery Code Corrected\n- Avoiding Recovery by Admin Specification Changed\n- BobVault Uint Conversions Code Corrected\n- Missing Sanity Checks Code Corrected\n- No Events on State Changes Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "6.2 ERC20Permit.receiveWithSaltedPermit",
    "body": "Signature Can Be Front-Run\n\nDesign Medium Version 1 Code Corrected\n\nThe ZkBobPool permittable deposit relies on the ERC20Permit.receiveWithSaltedPermit\nfunction. However, the signature used in this function can be used in the\nERC20Permit.saltedPermit function as well. An attacker can intercept the deposit transaction,\nextract the signature and use it in the call to saltedPermit. As a result of this action, the permittable\ndeposit will fail due to the nonce already having been used. Thus, the attacker can front-run the\nsignatures and use them in unintended functions to cause a user's transactions to fail.\n\n\nCode corrected:\n\nThe saltedPermit function was removed. Hence, a permittable transaction can't be front-run with a\ncall that uses the same signature for another function.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "6.3 Admin Reentrancy in ERC20Recovery",
    "severity": "minor",
    "body": "Security Low Version 1 Code Corrected\n\nThe executeRecovery function in ERC20Recovery can only be called by the owner or the recovery\nadmin. When recovering the tokens, they are transferred to the recoveredFundsReceiver address. If\nthis address is a contract, the onTokenTransfer function is called. This call could be used to reenter\nthe executeRecovery function in order to double-claim the funds to recover. This would allow the\nrecovery admin or the owner to exceed the intended recoveryLimit.\n\nAs the recoveredFundsReceiver can only be set by the owner, and both the owner and recovery\nadmin are trusted addresses, the impact of this issue is limited.\n\nCode corrected:\n\nThe recoveryRequestExecutionTimestamp and recoveryRequestHash are now deleted before\nany external calls are made. Hence, if a reentrant call later calls executeRecovery again, there will be\nno stored timestamp or hash, so the funds can't be double-claimed anymore.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "6.4 Avoiding Recovery by Admin",
    "severity": "minor",
    "body": "Design Low Version 1 Specification Changed\n\nIf a user sees that their account is marked for recovery (using\nERC20Recovery.requestRecovery()), they can simply transfer funds to another account to stop\nthem from being recovered. It may also make sense from the perspective of trustworthiness to only allow\nrecovery of funds e.g. if the account is already frozen, or at least enforcing that an account must be\nfrozen in order to recover its funds.\n\nSpecification corrected:\n\nBOB Protocol responded:\n\n```\nRecovery functionality is intended to be used only on dormant or non-existing users, if the user is\nable to move his funds to a different address, his token should not be allowed for recovery.\nRecovering frozen is a different use-case, although it can be also executed through the same\nfunctionality.\n```\nWith the assumption, that the proper checks will be performed before account recovery, this issue is\nresolved.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "6.6 Missing Sanity Checks",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nMany state-changing operations do not include sanity checks to ensure incorrect values are not set.\nConsider adding checks to ensure these values aren't accidentally set incorrectly. This can happen e.g.\ndue to a bug in a front-end application resulting in empty values in calldata.\n\nThese operations include:\n\nERC20Blocklist:\n\n- updateBlocklister() does not check that _newBlocklister is not address(0).\n\nERC20Recovery:\n\n- setRecoveryAdmin() does not check that _recoveryAdmin is not address(0).\n- setRecoveredFundsReceiver() does not check that _recoveredFundsReceiver is not\n    address(0).\n\nClaimable:\n\n- setClaimingAdmin does not check that _claimingAdmin is not address(0).\n\nZkBobPool:\n\n- constructor() does not check any of the provided addresses.\n- initialize() does not check that _root is not 0.\n- setTokenSeller() does not check that _seller is not address(0).\n- setOperatorManager() does not check that _operatorManager is not address(0).\n\nBobVault:\n\n- constructor() does not check that _bobToken is not address(0).\n- setYieldAdmin() does not check that _yieldAdmin is not address(0).\n- setInvestAdmin() does not check that _investAdmin is not address(0).\n\n\nCode corrected:\n\nChecks were added where necessary. Explanation was added why certain cases do not need sanity\nchecks.\n\nBOB Protocol responded:\n\n```\nWe added a few sanity checks in places there we think they might be important:\n```\n- ZkBobPool: constructor(), initialize(), setOperatorManager()\n- BobVault: constructor()\n\n```\nIn other places, zero addresses are used for unsetting the specific privileges and rights:\n```\n- ERC20Blocklist: updateBlocklister() – zero address is used to limit the ability to block/unblock\n    accounts only by the governance.\n- ERC20Recovery: setRecoveryAdmin() – zero address is used to limit the ability to recover funds\n    only by the governance. setRecoveredFundsReceiver() – there is a check that\n    recoveredFundsReceiver is not zero in _remainingRecoveryLimit (link) so it is safe to not\n    introduce additional checks\n- Claimable: setClaimingAdmin() – zero address is used to limit the ability to claim tokens only by\n    the governance.\n- ZkBobPool: setTokenSeller() – zero address is used to disable the ability for users to swap small\n    amount of BOB tokens to MATIC during the withdrawal process.\n- BobVault: setYieldAdmin() - zero address is used to limit the ability to collect generated yield by\n    the governance; setInvestAdmin() – zero address is used to limit the ability invests tokens into\n    the yield provider only by the governance.\n\n```\nMoreover, these functions should only be called by the admin via governance process (e.g. from\nSafe UI), making real UI typos very unlikely to happen.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "6.7 No Events on State Changes",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nMany state-changing operations do not emit events. Consider emitting events for important state\nchanges.\n\nThese operations include:\n\nZkBobPool:\n\n- initialize()\n- setTokenSeller()\n- setOperatorManager()\n\nZkBobAccounting:\n\n- _setLimits()\n- _resetDailyLimits()\n- _setUsersTier()\n\nBobVault:\n\n- setYieldAdmin()\n\n\n- setInvestAdmin()\n\nMutableOperatorManager:\n\n- _setOperator()\n\nERC20Recovery:\n\n- setRecoveryAdmin()\n- setRecoveredFundsReceiver()\n- setRecoveryLimitPercent()\n- setRecoveryRequestTimelockPeriod()\n\nClaimable:\n\n- setClaimingAdmin()\n\nCode corrected:\n\nEvents were added to the following functions:\n\nZkBobPool:\n\n- setTokenSeller()\n- setOperatorManager()\n- withdrawFee()\n\nZkBobAccounting:\n\n- _setLimits()\n\nMutableOperatorManager:\n\n- _setOperator()\n\nThe remaining functions are either not expected to be called regularly, or it was deemed unimportant for\nthe functions to emit events.\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "7.2 ERC20Permit Deletes Existing Approvals",
    "body": "Note Version 1\n\nUsing any of the public functions in ERC20Permit will zero out any pre-existing approval a user may have\nhad from the signer. Hence, a user should use any existing approval from the signer before calling\npermit or its variations.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "7.6 Unused Return Data in YieldConnector",
    "body": "Note Version 1\n\nThe YieldConnector's _delegateFarmExtra function does not return anything, even though the\nfarmExtra function of the IYieldImplementation interface returns a bytes type.\n\nSimilarly, the claimTokens function of the Claimable contract does not check the return value of\nIERC20(_token).transfer(_to, balance). Hence, false could be returned (meaning the\ntransfer did not actually take place).\n\nCode corrected:\n\nBOB Protocol responded:\n\n```\nAcknowledged and added missing return statement from farmExtra() function. The\n_delegateFarmExtra() function is unused in the context of existing AAVE deployments, however, it\nmight be used for other lending markets integrations (e.g. Compound). Calls to\nIERC20(_token).transfer(_to, balance) in the Claimable contract are only intended to be executed\nwithin the manual governance process, thus actual transfer result does not imply any considerable\nimpact on the system.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/ChainSecurity_BOB_Protocol_zkBob_audit.pdf"
    }
  },
  {
    "title": "5.1 No Documentation",
    "severity": "minor",
    "body": "Security Low Version 1\n\nNo documentation is available for ERC20Pods. This abstract contract is intended to be used by third\nparties hence documentation is vital to avoid issues. For authors of pods it must be clearly documented\nwhat they have to take into account and what they can rely on, such as:\n\n- Failed calls to Pod.updateBalances() are ignored, consequently authors of pods must be aware\n    of the consequences for their pods\n- Amount of gas available\n- When exactly the token triggers Pod.updateBalances(): Upon non-zero token transfers and\n    when the pod is added/removed from an account having non-zero balance. Misunderstandings by a\n    developer of a Pod may lead to correctness issues.\n\nThe trust model should be clearly specified, including:\n\n- How exactly pods are trusted / untrusted\n- Whether only trusted parties can add/remove pods to/from an account. If this holds, the docs should\n    clearly state that a developer extending ERC20Pods must adhere to this\n\nFurthermore not all token holders, e.g. contracts can call addPod() themselves. The documentation\nmay elaborate on this topic, e.g., what can be assumed / what the limitations are.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.2 Consistency on Zero Amount Transfers",
    "severity": "minor",
    "body": "Design Low Version 1 Acknowledged\n\n\nThe ERC20 standard specifies Note Transfers of 0 values MUST be treated as normal t\nransfers and fire the Transfer event.. For consistency, it may make sense to inform the\nregistered pods about 0 balance actions and 0 amount transfers. If this behavior is desired the way it is, it\nshould be mentioned somewhere so that Pod developer are aware that 0 balance or 0 amount transfers\nare not notified to the Pod.\n\nAcknowledged:\n\n1inch acknowledged the issue and decided to leave the code as it is.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.3 Side Effects of _updateBalances()",
    "severity": "minor",
    "body": "Security Low Version 1 Risk Accepted\n\nWhile the gas check prevents direct reentrancy into the token on functions changing the balance,\n200_000 gas is enough to make some other state changes that could affect to-be-updated pods. Notably\nupon updating the first pod A, this contract may interact with another pod B which is to be updated later in\nthe sequence and hence does not yet know about these balance changes pod A currently executing\nalready is aware of. While we have not uncovered any direct issue, a badly designed or adversarial pod\ncould be problematic. No trust model nor specification covering this scenario is available.\n\nRisk accepted:\n\n1inch is aware of and accepts the risk.\n\nVersion 2 introduced a reentrancy guard. Note that this can be leveraged by a pod to detect such a\nscenario and revert. While the state of the reentrancy guard itself cannot be querried direcly, public\nfunctions balanceOf and podBalanceOf now feature the nonReentrant(View) modifier and will\nrevert if called in such a situation. Hence in the scenario described above pod B could call balanceOf()\nand be protected.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.4 Zero Address Consistency in AddressArray",
    "severity": "minor",
    "body": "Design Low Version 1 Acknowledged\n\nWhen querying an index that is out-of-bounds with AddressArray.at, the function does not revert and\nreturns address(0). Thus, it is not possible to distinguish between an address(0) that would\neffectively be part of the array, and an out-of-bounds access.\n\nAcknowledged:\n\n1inch is aware of the issue and states that in the current use case, no pod with address(0) can be\nadded. While this is true in the case of ERC20Pods, it can still be an issue for other contracts using the\nlibrary.\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 0\n```\n```\nLow-Severity Findings 3\n```\n- ERC20Pods podsLimit Sanitization Code Corrected\n- Missing Events Code Corrected\n- Operations Order on Pod Removal Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.1 ERC20Pods podsLimit Sanitization",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe podsLimit in the ERC20Pods's constructor is never sanitized. If podsLimit is zero, the\nfunctionality added by ERC20Pods cannot be used, so it would not make sense to allow setting\npodsLimit=0.\n\nCode corrected:\n\nThe constructor of the ERC20Pods contract now checks that podsLimit is not zero.\n\nNote that in Version 2 the constructor takes a second parameter podCallGasLimit_ which is not\nsanitized. Unsuitable values could make the ERC20Pods unusable.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.2 Missing Events",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nTypically, events help track the state of the smart contract. To be able to reconstruct the state offchain,\nevents should be emitted when users add and remove pods.\n\nCode corrected:\n\nTwo events PodAdded and PodRemoved have been added and are emitted whenever a pod is\nadded/removed.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.3 Operations Order on Pod Removal",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\n\nWhen a pod is removed with removePod, it is first removed from the internal address set, and then the\nbalances are updated. But when calling removeAllPods, the balances are updated before the pod is\nremoved from the address set. Thus, there are two different behaviors for the same action and the\npotential for inconsistencies arises.\n\nCode corrected:\n\nThe function removeAllPods now follows the order of removePod by first removing the pod from the\naddress set and then update the balances.\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.1 Failed Call to Pod Is Silent",
    "body": "Note Version 1\n\nERC20Pods._updateBalances() calls the pod with a fixed amount of gas. If this call fails, the\nexecution nonetheless continues normally in order to not block the ERC20. Users must be aware that a\nfailed call to a pod is silent and will not emit any event.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.2 Integrations May Break Due to Gas",
    "body": "Requirements\n\nNote Version 1\n\nA transfer of an ERC20Pods may require significantly more gas than the transfer of a normal ERC20.\nThis especially applies when sender and receiver are connected to multiple distinct pods. Moreover, the\ncurrent abstract contract ERC20Pods allows an user to register any arbitrary pod for his address.\n\nIn the worst case each of the pods uses the full 200'000 gas available. When sender and receiver have\ndistinct pods this amounts to 2 * podsLimit gas.\n\nIntegrations must take this into account in order to avoid running into problems such as, but not limited to:\n\nAn example could be a liquidation of a position where in an extreme case multiple different ERC20Pods\nwhere each sender/receiver is connected to several pods must be transferred. The liquidation may not be\npossible due to the gas requirement exceeding the block gas limit.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.3 Not Exactly _POD_CALL_GAS_LIMIT",
    "body": "Available\n\nNote Version 1\n\nA Pod cannot rely on having exactly 200'000 gas available upon being called. While it is taken into\naccount that a maximum of 63/64 of the remaining gas can be passed to the call, due to the overhead\nbetween the check and the call:\n\n```\nif lt(div(mul(gas(), 63), 64), _POD_CALL_GAS_LIMIT) {\nmstore(0, exception)\nrevert(0, 4)\n}\npop(call(_POD_CALL_GAS_LIMIT, pod, 0, ptr, 0x64, 0, 0))\n}\n```\nin a corner case scenario the call may receive slightly less gas.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.4 Order of Pods in AddressSet",
    "body": "Note Version 1\n\nUsers msut be aware that upon pod removal, the order in the pods in the AddressSet may change, so\ntwo calls to podAt with index X, with a call to removePod in-between, may not yield the same result.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.5 Unaffected Elements of the Output Memory",
    "body": "Array on AddressArray.get()\n\nNote Version 1\n\nWhen providing an output memory array to the function\nAddressArray.get(Data storage self, address[] memory output), users must be aware\nthat if length(self) < output.length(), only the length(self) first elements of output will be\noverwritten, leaving the remaining elements of output untouched.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-ERC20-pods-ChainSecurity.pdf"
    }
  },
  {
    "title": "5.1 Consistency on Zero Amount Transfers",
    "severity": "minor",
    "body": "Design Low Version 2\n\nThe function BasicDelegationPod._updateBalances does not trigger mint/burn/transfer of\ndelegation shares (an ERC20Pods token) on 0 amount. The ERC20 standard specifies Note Transfe\nrs of 0 values MUST be treated as normal transfers and fire the Transfer even\nt..\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 2\n```\n- Possible Frontrunning on Registration Code Corrected\n- Pod.updateBalances() Cannot Transfer ERC20Pods Code Corrected\n\n```\nMedium-Severity Findings 1\n```\n- Allowances Not Completely Disabled Code Corrected\n\n```\nLow-Severity Findings 3\n```\n- Broken C-E-I Pattern Code Corrected\n- Inconsistency and Zero Address Check on register() Code Corrected\n- No Event upon Registering Delegatee Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.2 Pod.updateBalances() Cannot Transfer",
    "body": "ERC20Pods\n\nDesign High Version 1 Code Corrected\n\nPod.updateBalances() cannot transfer (including mint or burn) tokens of another ERC20Pods (with\nat least one pod involved): Using the default implementation of ERC20Pods the call to\nupdateBalances() of a pod is executed with _POD_CALL_GAS_LIMIT amount of gas. Currently this\nvalue is hardcoded to 200_000. A transfer of an ERC20Pods within updateBalances() would trigger\n_updateBalances() of this ERC20Pods. The current call executing with this amount of gas cannot\nforward another 200_000 gas and hence the execution reverts.\n\n\n```\nfunction _updateBalances(address pod, address from, address to, uint256 amount) private {\nbytes4 selector = IPod.updateBalances.selector;\nbytes4 exception = InsufficientGas.selector;\n```\n```\nassembly { // solhint-disable-line no-inline-assembly\nlet ptr := mload(0x40)\nmstore(ptr, selector)\nmstore(add(ptr, 0x04), from)\nmstore(add(ptr, 0x24), to)\nmstore(add(ptr, 0x44), amount)\n```\n```\nif lt(div(mul(gas(), 63), 64), _POD_CALL_GAS_LIMIT) {\nmstore(0, exception)\nrevert(0, 4)\n}\npop(call(_POD_CALL_GAS_LIMIT, pod, 0, ptr, 0x64, 0, 0))\n}\n```\nThe design of RewardableDelegationPod however requires this and hence cannot work.\n\nWithin RewardableDelegationPod.updateBalances() the call to the DelegatedShare token\n(which is ERC20Pods, and the accounts are connected to at least the farm pod) is wrapped within\ntry/catch. Despite the function itself being annotated with\nbest effort of having consistent shares the accounting is totally off. A transfer of the\nunderlying ERC20Pod which triggers RewardableDelegationPod.updateBalances() will never\nsuccessfully execute registration[_delegate].burn(from, amount)/ registration[_del\negate].mint(from, amount). These calls only succeed when updateBalances() is called with\nsufficient gas, e.g. using DelegatedShare.addPod().\n\nCode corrected:\n\nThe root of the issue has been addressed in ERC20Pods. The amount of gas for each of the calls in\nERC20Pods._updateBalances() is no longer hardcoded in ERC20Pods but passed as constructor\nparameter. The ERC20Pods that is DelegatedShare has a fixed 100_000 gas for each of the\ncallbacks. When two ERC20Pods are stacked like in\nERC20Pods->RewardableDelegationPod->ERC20Pods``, developers must be careful to set the correct\namount of gas in each of them for the system to work.\n\nThe function RewardableDelegationPod.updateBalances has been updated to call\nmint()/burn() without try/catch blocks so that every call to DelegatedShare.mint()/burn()\nmust be successful.",
    "dataSource": {
      "name": "ChainSecurity/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/03/1inch-Smart-Contract-Audit-Delegation-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.1 Public Setter Functions Can Be Frontrun",
    "severity": "medium",
    "body": "Design Medium Version 1 Risk Accepted\n\nThe following functions can only be executed once and have no access controls:\n\n```\n1.FxBaseRootTunnel.setFxChildTunnel\n2.FxBaseChildTunnel.setFxRootTunnel\n3.FxRoot.setFxChild\n4.FxChild.setFxRoot\n```\n```\n5.FxERC20.initialize\n6.FxERC721.initialize\n7.FxERC1155.initialize\n```\nIf deployment and initialization is not done within one transaction it would be possible for a malicious\nactor to frontrun the deployer's call to the functions and instead call them with malicious values first. This\nwill cause the deployer's function call to revert.\n\nFxBaseRootTunnel and FxBaseChildTunnel are to be inherited by contracts in order to use the\nbridging functionality of the Fx Portal. This may lead to problems with their deployment. Implementors\nshould be aware of this behavior, mitigate this and ensure/verify that initialization is done correctly. If their\nsetTunnel functions are frontrun, the contract will need to be redeployed. This can be expensive in terms\nof gas.\n\nThe Wrapper contracts FxRoot and FxChild for the interaction with the StateSender have already\nbeen deployed and initialized correctly. If a new instance of one of these contracts is deployed, the\ndeployer must verify that the functions are called correctly. For the Token contracts\nFxERC20/ERC721/ERC115 used in the examples minimal proxy contracts are deployed the\ninitialize() function is called from contracts within the same transactions.\n\n\nRisk accepted:\n\nPolygon states:\n\n```\nIt is a known risk that initialization functions can be frontrun, but this\nis low-risk since there is no incentive for a malicious actor to do so.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "6.2 Use (Up to Date) Dependencies",
    "severity": "medium",
    "body": "Design Medium Version 1 Code Partially Corrected\n\nSeveral contracts present in lib or tokens are copy & pasted from third party repositories. An\nexception to this pattern is the SafeERC20 library which is imported from a dependency listed in the\npackage.json file. This pattern is generally preferable. Note that several of the copy & pasted\ndependencies are also from this OpenZeppelin contracts dependency, hence could simply be imported\nfrom there.\n\nPackage.json lists the dependencies and the requirements on the version, while\npackage-lock.json allows to fix specific version.\n\nThis allows to effortlessly update to newer versions of these contract which may include bug fixes. Note\nthat this must be done with due care as functionality could change. Once a new version has been\ndeemed suitably safe, the new version can be fixed in package-lock.json.\n\nMost copy & pasted contracts are old versions, furthermore the version of the OpenZeppelin dependency\nis outdated. Notably, the implementation of ERC721 contains several changes reloading state after\nbeforeTokenTransfer(), which may have updated this data.\n\nCode partially corrected:\n\nThe dependencies in package.json were changed to more recent versions. ERC20.sol and\nIERC20.sol were updated to OpenZeppelin v4.7.3.\n\nThe other copy & pasted contracts in lib have not been updated.\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- mapToken() Callable Only by Mappers Specification Changed\n\n```\nMedium-Severity Findings 2\n```\n- Description of toBoolean() Is Incorrect Specification Changed\n- FxMintableERC20RootTunnel connectedToken Initialized Incorrectly Code Corrected\n\n```\nLow-Severity Findings 8\n```\n- Codehash Variable Type Could Be Set to Immutable Code Corrected\n- FxMintableERC20ChildTunnel Has No withdrawTo Function Code Corrected\n- FxMintableERC20RootTunnel Events Missing Code Corrected\n- Outdated Compiler Version Code Corrected\n- Return Value of _checkBlockMembershipInCheckpoint() Code Corrected\n- SafeMath Library Is Redundant Code Corrected\n- Unused Variable in FxMintableERC20RootTunnel Code Corrected\n- _processMessageFromChild Comment Incorrect Specification Changed",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.1 mapToken() Callable Only by Mappers",
    "severity": "major",
    "body": "Correctness High Version 1 Specification Changed\n\nIn FxERC20RootTunnel and FxERC721RootTunnel, the mapToken function is annotated as follows:\n\n```\n/**\n* @notice Map a token to enable its movement via the PoS Portal, callable only by mappers\n* @param rootToken address of token on root chain\n*/\nfunction mapToken(address rootToken) public {\n```\nThe function however has no access control, anyone may map a token.\n\nThe same function in FxERC1155RootTunnel lacks a function description. It also has no access\ncontrol.\n\nSpecification changed:\n\nThe comment has been changed to:\n\n```\n//@notice Map a token to enable its movement via the PoS Portal, callable by anyone\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.3 FxMintableERC20RootTunnel",
    "severity": "info",
    "body": "connectedToken Initialized Incorrectly\n\nCorrectness Medium Version 1 Code Corrected\n\nIn the _deployRootToken function of FxMintableERC20RootTunnel, the rootToken's\n_connectedToken field is initialized as rootToken. This means the rootToken's _connectedToken\nwill be itself, not the childToken on the other chain.\n\nCode corrected:\n\nThe _connectedToken is now correctly initialized with the childToken.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.4 Codehash Variable Type Could Be Set to",
    "body": "Immutable\n\nDesign Low Version 1 Code Corrected\n\nIn the following contracts the variable childTokenTemplateCodeHash could be changed to an\nimmutable:\n\n```\n1.FxERC20RootTunnel.sol\n2.FxERC721RootTunnel.sol\n3.FxERC1155RootTunnel.sol\n```\nThis avoids unnessesary and expensive reads from storage, hence reduces the gas consumption.\n\n\nCode corrected:\n\nThese and more variables have been declared immutable.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.5 FxMintableERC20ChildTunnel Has No",
    "body": "withdrawTo Function\n\nDesign Low Version 1 Code Corrected\n\nThe FxMintableERC20ChildTunnel has no withdrawTo function, unlike the other example\ncontracts. Tokens can only be withdrawn to the same address on the RootChain as the calling address\non the ChildChain.\n\nThis may make it impossible for some smart contract wallets to bridge tokens, since the user may not be\nable to deploy the smart contract wallet at the same address on the other chain.\n\nCode corrected:\n\nA withdrawTo() function has been added, which takes a receiver argument. It calls an internal\nfunction _withdraw(), which is identical to the previous withdraw() function, except that it calls\n_sendMessageToRoot() with the receiver address instead of msg.sender.\n\nThe public withdraw() function's functionality is unchanged.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.6 FxMintableERC20RootTunnel Events Missing",
    "severity": "minor",
    "body": "Correctness Low Version 1 Code Corrected\n\nThe FxMintableERC20RootTunnel contract emits no events when tokens are deposited or\nwithdrawn, which is different behavior than all other example contracts.\n\nCode corrected:\n\nThe missing events have been added.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.9 SafeMath Library Is Redundant",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nAn old version of the SafeMath library (made for Solidity <0.8) is used in ERC20 and\nFxERC20MintableRootTunnel.\n\nThe main use of SafeMath was previously to revert on arithmetic overflow. As of Solidity 0.8, overflow\nchecks were introduced into the Solidity compiler.\n\nThis makes the use of SafeMath redundant.\n\nCode corrected:\n\nThe SafeMath library has been removed.\n\nERC20.sol and IERC20.sol have been updated to OpenZeppelin v4.7.3, which does not use\nSafeMath. The required IERC20MetaData.sol has also been added.\n\nFxERC20MintableRootTunnel no longer uses SafeMath.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "7.10 Unused Variable in",
    "body": "FxMintableERC20RootTunnel\n\nDesign Low Version 1 Code Corrected\n\nThe childTokenTemplateCodeHash variable in FxMintableERC20RootTunnel is declared but\nnever used.\n\nCode corrected:\n\n\nThe unused variable has been removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "8.1 FxERC20RootTunnel Cannot Map All ERC-",
    "body": "Tokens\n\nNote Version 1\n\nmapToken in FxERC20RootTunnel calls ERC20.decimals().\n\n```\n//name, symbol and decimals\nERC20 rootTokenContract = ERC20(rootToken);\nstring memory name = rootTokenContract.name();\nstring memory symbol = rootTokenContract.symbol();\nuint8 decimals = rootTokenContract.decimals();\n```\nIn the ERC-20 standard, decimals is optional.\n\nIf the rootToken does not have a decimals function, the call will revert and it will be impossible to map\nthis token.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/12/ChainSecurity_Polygon_Fx_Portal_audit.pdf"
    }
  },
  {
    "title": "6.3 Unused Import",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nMapleV1ToV2PoolMapper imports \"@openzeppelin/contracts/token/ERC20/ERC20.sol\"\nwhich is unused.\n\nCode corrected:\n\nThe import has been removed.\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Sulu-Extensions-VIII-Smart-Contract-audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-VIII-Smart-Contract-audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-VIII-Smart-Contract-audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "8.4 _safeTokenTransfer - Call to External",
    "body": "Address\n\nNote Version 1\n\nWhen the boolean parameter convertToETH is set to true, WETH is unwrapped into Ether. This Ether is\ntransferred to the recipient using a call, the gas amount passed is not restricted. At this point, the\nexecution may reach untrusted code.\n\n\nThe function name \"safeTokenTransfer\" is due to the usage of OpenZeppelins SafeERC20 library. One\nmust be careful to not misinterpret the function name and assume using this function is \"safe\" under all\ncircumstances.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_V2_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/11/ChainSecurity_Gearbox_Protocol_Gearbox_V2_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/11/ChainSecurity_Gearbox_Protocol_Gearbox_V2_audit.pdf"
    }
  },
  {
    "title": "6.1 Mismatch of Implementation With",
    "body": "Specification\n\nCorrectness Medium Version 1 Specification Changed\n\nThe specifications of the borrow function state:\n\n```\nIn this case the collateral is deducted from the 3rd party ``msg.sender`` address but\nthe ``_onBehalfOf`` address receives the loan and is registered as the loan owner\n(including the ability to repay and reclaim the pledged collateral).\n```\nHowever, the function takes the collateral from msg.sender and also sends the loan amount to\nmsg.sender in violation with the specifications:\n\n```\nIERC20Metadata(collCcyToken).safeTransferFrom(msg.sender, address(this), _sendAmount);\n...\nIERC20Metadata(loanCcyToken).safeTransfer(msg.sender, loanAmount);\n```\n\nSpecification changed\n\nThe specification in section 'Calling Functions on Behalf' of the gitbook has been revised to reflect the\ncode behavior:\n\n```\nIn this case the collateral is deducted from msg.sender and msg.sender also receives\nthe loan but the_onBehalfOf address is registered as the loan owner (including the\nability to repay and reclaim the pledged collateral). This allows wrapping and\nunwrapping of tokens through a peripheral contract.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf"
    }
  },
  {
    "title": "7.5 Locked Tokens",
    "body": "Note Version 1\n\nERC20 tokens could be accidentally/intentionally sent to the pool contracts. In that case the tokens will\nbe locked, with no way to recover them. Incidents\n(https://coincentral.com/erc223-proposed-erc20-upgrade/) in the past showed this is a real issue as there\nalways will be users sending tokens to the token contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_MYSO_Finance_Core_Protocol_V1_audit_221018.pdf"
    }
  },
  {
    "title": "5.8 BNTPool.renounceFunding Division by 0",
    "severity": "minor",
    "body": "Correctness Low Version 1 Risk Accepted\n\nIn PoolCollection._executeWithdrawal, if the protocol has to renounce BNT funding and this\nresults in the BNT staked balance being reset to 0, but the BNT trading liquidity is still greater than 0,\n_resetTradingLiquidity is called which tries to renounce BNT funding again. As the staked\nbalance has already been set to 0, this second call to BNTPool.renounceFunding will now revert due\nto a division by 0.\n\nConsider the following case:\n\n- User A deposits TKN liquidity into an empty pool.\n- Trading is enabled.\n- User B trades a certain amount of TKN for BNT.\n- User A now withdraws all his supplied TKN.\n- The withdrawal fails due to the mentioned problem.\n\nRisk accepted:\n\nThe client accepts the risk, stating the following:\n\n```\nThis is a rare case that we don’t expect to happen in practice, since trading can’t be enabled\nimmediately and usually involves many depositors. In any case, we will consider addressing this in\nthe future as well.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- Oracle Manipulation Code Corrected\n\n```\nMedium-Severity Findings 3\n```\n- BNT Burned Twice Code Corrected\n- Locked vBNT Code Corrected\n- Pool Denial of Service Code Corrected\n\n```\nLow-Severity Findings 18\n```\n- BNT Deposit Allows msg.value > 0 Code Corrected\n-\n    Specification Changed\n\n```\nConsistency Issues Between Implementation, Excel Demonstration and Documentation Regarding\nthe Withdrawal\n```\n- Different Programs Can Share the Same Reward Code Corrected\n- Emission of Events With Arbitrary Amounts Code Corrected\n- Impossible to Migrate ETH Position Code Corrected\n- Inconsistent Naming Code Corrected\n- Inconsistent Use of ERC20.transfer Code Corrected\n- Misleading Comment Code Corrected\n- Misleading Comment in PoolCollection.enableTrading Code Corrected\n- Problematic Loop Continuation During Pool Migration Code Corrected\n- Undocumented Behavior Code Corrected\n- Unused Imports / Variables Code Corrected\n- Wrong Function Name in BancorPortal Code Corrected\n- Wrong Interface Code Corrected\n- AutoCompoundingRewards Can Burn More Pool Tokens Than Expected Code Corrected\n- BNTPool.renounceFunding Fails on Insufficient BNT Pool Token Balance Code Corrected\n- ERC20Permit Handling Code Corrected\n- MathEx.reducedFraction Can Turn Denominator to 0 Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf"
    }
  },
  {
    "title": "6.11 Inconsistent Use of ERC20.transfer",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nIn some cases a normal transfer is used. Some of these occurrences have the comment:\n\n```\n// transfer the tokens to the provider (we aren't using safeTransfer, since the PoolToken is a fully\n// compliant ERC20 token contract)\np.poolToken.transfer(provider, poolTokenAmount)\n```\nBut the pool token is also transferred with a safe transfer in another case\n\n```\npoolToken.safeTransferFrom(provider, address(_pendingWithdrawals), poolTokenAmount)\n```\nThe assumption that all tokens behave as expected should be carefully evaluated against gas savings\nbetween a normal transfer and a safe transfer.\n\nCode corrected:\n\nBancorNetwork._initWithdrawal now transfers the pool tokens using a regular transferFrom\ncall. Since all pool tokens are PoolToken contracts, they revert on failure making it safe to use the\nregular transferFrom function.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf"
    }
  },
  {
    "title": "6.21 ERC20Permit Handling",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe permit function of ERC20Permit tokens is called expecting them to revert if the given signature is\nincorrect. While this is the correct behavior according to the EIP 2612 specification, numerous token\nprojects have shown that specifications are not always adhered to completely (e.g. the transfer\nfunction in USDT). Therefore, it might be possible that some token project exists that does not revert but\nrather returns a boolean value on calls to permit.\n\nCode corrected:\n\n``ERC20Permit` support has been completely removed from the project.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf"
    }
  },
  {
    "title": "7.8 No Recovery of Accidental Token Transfers",
    "body": "Possible\n\nNote Version 1\n\nIn case an ERC20 token other than the BNT or one of the base tokens is sent to the contract, then it\ncannot be recovered. Among other reasons, this might happen due to airdrops based on the base\ntokens.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf"
    }
  },
  {
    "title": "7.12 Unsupported Tokens",
    "body": "Note Version 1\n\nNot all ERC20 tokens can act as base tokens for Bancor v3 contracts. In particular, the following tokens\nare not supported:\n\n\n- Tokens that return metadata fields like name and symbol encoded as bytes32 instead of string\n    (e.g. MKR). PoolTokenFactory.createPoolToken will fail to create a pool token for these\n    tokens.\n- Tokens that take a fee on transfer (e.g. PAXG and possibly USDT). A deposit will use the full\n    amount to mint pool tokens while the contract has received a lower amount.\n- Tokens that have a rebasing mechanism (e.g. AAVE's aToken). User's staked balances will not be\n    updated accordingly.\n\nAdditionally, the following tokens could break the protocol in the future:\n\n- Tokens with blacklists (e.g. USDT, USDC).\n- Upgradeable tokens that add one of the mentioned mechanisms in the future.\n- Pausable tokens (e.g. BNB).",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Bancor_Bancor_v3_audit.pdf"
    }
  },
  {
    "title": "6.19 Sanity Check in on Flashloan",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe intention behind following check in OperationExecutor.onFlashloan() is unclear:\n\n```\nrequire(amount == flData.amount, \"loan-inconsistency\");\n```\nWhile checking the actual balance has its limitations (e.g. not clear if token balance originates from the\nflashloan or whether it has been there before already), why is the sanity check on the specified amounts\nbeing done but not on the actual balance?\n\nAfter the intermediate report, the check was changed to:\n\n```\nrequire(IERC20(asset).balanceOf(address(this)) == flData.amount, \"Flashloan inconsistency\");\n```\nThis is dangerous: Any additional balance of this token held by the OperationExecutor causes a revert of\nthis function. It should be clarified what should be checked and why this is checked.\n\nInitially the code checked whether the parameter amount the caller (the flashloan provider) passed\nmatches the expected amount. We questioned what's the intention behind this check and highlighted that\nit doesn't ascertain anything on the actual balance. Checking if at least the balance expected is present\nmight be an option, but it must be clear that this doesn't say how much tokens have been transferred\nfrom the flashloan provider (as the OperationExecutor may have had a non-zero token balance before as\nanyone could just transfer tokens).\n\nCode corrected:\n\nThe check was changed to:\n\n```\nrequire(IERC20(asset).balanceOf(address(this)) >= flData.amount, \"Flashloan inconsistency\");\n```\nThis does not allow to determine whether the token balance originates from the flashloan or if it was\nalready in the contract, but now an additional balance of this token held by the OperationExecutor will not\ncause a revert.\n\nClient adds:\n\n```\nIn the event that the lender is compromised and supplies a lesser amount then the\nOperation execution will fail unless another party has accidentally sent balance to\n```\n\n```\nthe Operation Executor at some earlier time. The only impacted party would be the person\nwho accidentally sent tokens to the Operation Executor, whose funds are lost anyway.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf"
    }
  },
  {
    "title": "6.20 Swap Slippage Saved Event Order",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nSwap._swap() emits the SlippageSaved event after a swap:\n\n```\nbalance = IERC20(toAsset).balanceOf(address(this));\nemit SlippageSaved(receiveAtLeast, balance);\nif (balance < receiveAtLeast) {\nrevert ReceivedLess(receiveAtLeast, balance);\n}\n```\nWhile after a revert occurs all state changes including any event logs are thrown away, it might be more\nappropriate to only emit the event after it has been ascertained that more than receiveAtLeast have\nbeen received.\n\nCode corrected:\n\nThe event is now emitted after the check.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Oazo_Apps_Limited_Modular_Proxy_Actions_audit.pdf"
    }
  },
  {
    "title": "5.1 CRV Not Locked When Used to Mint YCRV",
    "severity": "medium",
    "body": "Correctness Medium Version 1 Risk Accepted\n\nWhen YCRV is minted with the mint() function, CRV is not locked.\n\nIn yveCRV, CRV is locked upon minting. In YCRV.mint(...) it is not locked immediately, but a separate\ncall to StrategyProxy.lock() is needed.\n\n```\nassert ERC20(CRV).transferFrom(msg.sender, VOTER, amount) # dev: no allowance\nself._mint(_recipient, amount)\nlog Mint(msg.sender, _recipient, False, amount)\nreturn amount\n```\nNot locking the CRV immediately in the CRV voting escrow implies a mismatch between the total supply\nof YCRV and the effective voting power and total rewards of VOTER. It also imposes increased trust\nrequirements towards governance, which might sweep the not yet locked CRV from the VOTER.\n\nRisk accepted\n\nYearn states:\n\n```\nLocking CRV is gas intensive. Decision was made to have locking occur at\nsome periodic interval via external process rather than burden each user\nwith gas costs.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf"
    }
  },
  {
    "title": "5.2 Trades During ZapYCRV.zap Conversions",
    "severity": "minor",
    "body": "Security Low Version 1 Risk Accepted\n\nThe ZapYCRV.zap function can involve multiple Curve pools during the conversion.\n\nFirst, CRV -> LPYCRV conversions will involve up to 2 trades in LPYCRV pool:\n\n```\n1.Trade of all CRV to yCRV\n```\n```\n2.Trade of some yCRV to CRV, during the unbalanced deposit into the pool\n```\nCompared to trade of some CRV to yCRV and a balanced deposit, the 2 trades double pay the fees.\n\nSecond, in the case when CVXCRV is an input, these 2 trades are preceded by a trade on\nCVXCRVPOOL.\n\nPlease note, that due to number of pools and exchanges during the conversion process the min_out\nargument can be hard to specify precisely. In addition, imprecise min_out specified would allow 3rd\nparties to front run the zap.\n\nRisk accepted\n\nYearn states:\n\n```\nRealize that for some specific paths, this can be inefficient. However, hardcoding\npaths will lead to more contract complexity and overall gas consumption (including\nfor users who’s zap path touches neither of these tokens) which we view as\nundesirable. We agree that users can potentially lose more due to swap fees, but\nultimately most of those same fees get realized to the pool LPs, helping to repay\nthem over time.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 1\n```\n- LPYCRV Outputs Not Transferred to User Code Corrected\n\n```\nHigh-Severity Findings 1\n```\n- Incorrect relative_price When Input Is Not Legacy and Output Is LPYCRV Code Corrected\n\n```\nMedium-Severity Findings 1\n```\n- ZapYCRV _min_out LPYCRV Limit Code Corrected\n\n```\nLow-Severity Findings 2\n```\n- ERC20 Return Values Not Checked Code Corrected\n- ZapYCRV.zap Natspec Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf"
    }
  },
  {
    "title": "6.4 ERC20 Return Values Not Checked",
    "severity": "minor",
    "body": "Correctness Low Version 1 Code Corrected\n\nAccording to EIP-20, Callers MUST NOT assume that false is never returned. However, not all calls to\nERC20 assert that true is returned. ZapYCRV and yCRV do not check bool success values for calls to\nERC20.approve and ERC20.transfer. Even though in most cases the contracts are known in\nadvance and it is safe not to check this value, new features and codebase reuse can lead to potential\nproblems.\n\nIn function sweep in both contracts the return value of ERC20.transfer can be missing, if for example\nUSDT is used. In that case the call will fail.\n\nCode corrected\n\nAsserts have been added to the approve and transfer calls to make sure that true is returned.\n\nCompiler version has been increased to vyper 0.3.6 in order to use the external call keyword\nargument default_return_value=True, which ensures that transfer calls do not revert when\ncalling non EIP-20 compliant tokens such as USDT which do not return a boolean value.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf"
    }
  },
  {
    "title": "7.4 yCRV as an ERC20 Implementation",
    "body": "Note Version 1\n\nThere are 2 things we would like to note regarding the yCRV token.\n\n```\n1.The approve function has a known race condition attack vector described here\n```\n\n2.The transferFrom function does not emit Approval event. While this is compliant with\nspecification, one cannot reconstruct the state of user allowances based only on events, since\ntransferFrom does not emit any special events that show that approval was used.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/10/ChainSecurity_Yearn_yCRV_and_ZapYCRV_audit.pdf"
    }
  },
  {
    "title": "5.1 Inconsistent Decimals of LP Token",
    "severity": "minor",
    "body": "Correctness Low Version 5 Acknowledged\n\nThe function ERC20RootVault.deposit performs the following checks when new LP tokens are\nminted to a user:\n\n```\nrequire(lpAmount + balanceOf[msg.sender] <= params.tokenLimitPerAddress, ExceptionsLibrary.LIMIT_OVERFLOW);\nrequire(lpAmount + totalSupply <= params.tokenLimit, ExceptionsLibrary.LIMIT_OVERFLOW);\n```\nThe LP tokens distributed by root vaults do not have pre-defined number of decimals but depend on the\ntoken amounts of the first deposit, hence making difficult to set the params tokenLimitPerAddress\nand tokenLimit in advance.\n\nAcknowledged:\n\n\nMellow Finance acknowledges the issue and will take care to set the proper limits after initial LP shares\nare minted and the respective decimals are known:\n\n```\nWe don’t intend to stand limits in advance of the launch of the system, we rather want\nto stand them as MaxUint256 initially and then have a possibility to set meaningful values\nbased on the supply of lp tokens during the work of the system.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.2 Performance Fee in Specific Setups",
    "severity": "minor",
    "body": "Design Low Version 5 Acknowledged\n\nThe performance fee is charged in ERC20RootVault only if the price of LP tokens has increased in\nvalue, which is calculated in the statement:\n\n```\nuint256 lpPriceD18 = FullMath.mulDiv(tvlToken0, CommonLibrary.D18, baseSupply);\n```\nHowever, in specific setups where the token0 is of high value but has low decimals, while the token1 is\nof low value but with many decimals, the variable baseSupply would inherit the decimals of token1.\nTherefore, in such setups it is possible that the statement above returns lpPriceD18 equal to zero.\n\nAcknowledged:\n\nMellow Finance has decided to keep the code unchanged as they only will use only verified token\ncombinations that this issue does not occur. The response:\n\n```\nWe decided that this situation would not be possible when calculating the performance fee,\nsince we agreed to use only verified tokens, for which the difference between decimals\nwould be less than 18.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.3 Possible Optimization in AggregateVault",
    "severity": "minor",
    "body": "Design Low Version 5 Code Partially Corrected\n\nThe function AggregateVault._push performs the following actions:\n\n```\n1.Approves allowance with safeIncreaseAllowance for each token to destVault.\n```\n```\n2.Calls destVault.transferAndPush, which transfers tokenAmounts to the ERC20Vault.\n3.Resets approval to destVault for all tokens to 0.\n```\nGiven that the _push function moves tokens to the ERC20Vault and allowance in the end should be 0 ,\nthe function can be revised to be more efficient. For instance, safeIncreaseAllowance performs\nadditional operations and is useful when the existing allowance is not zero and should be considered.\nAlso, the function consumes in step 2 the allowance given earlier, hence the last for-loop might be\nomitted.\n\nCode partially correct:\n\nThe function AggregateVault._push is made more efficient by performing the external calls\nsafeIncreaseAllowance and safeApprove only for tokens that non-zero amounts are being\n\n\ntransferred (tokenAmounts[i] > 0). However, for the other tokens two external calls are performed\nfor updating the allowance.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.4 Possible Optimization on Deposits and",
    "body": "Withdrawals\n\nDesign Low Version 5 Acknowledged\n\nThe function ERC20RootVault.deposit can be optimized to be more gas efficient by transferring the\ntokens directly from the user to the ERC20Vault. Currently, the tokens are first transferred from the user\nto the root vault:\n\n```\nfor (uint256 i = 0; i < tokens.length; ++i) {\n...\nIERC20(tokens[i]).safeTransferFrom(msg.sender, address(this), normalizedAmounts[i]);\n}\n```\nand then, in AggregateVault._push tokens are transferred again:\n\n```\nfor (uint256 i = 0; i < _vaultTokens.length; i++) {\nIERC20(_vaultTokens[i]).safeIncreaseAllowance(address(destVault), tokenAmounts[i]);\n}\n```\nSimilarly, the function ERC20RootVault.withdraw can be made more efficient if the tokens are\ntransferred directly from the sub-vaults to the user instead of transferring to the root vault first and then to\nthe user.\n\nAcknowledged:\n\nClient acknowledges the optimization possibility but prefers to keep the code unchanged:\n\n```\nThe main idea behind this behavior is for the root vault to be responsible for pushing\ntokens onto different vaults. We consider the current design to be clearer with\npushing with the ```AggregateVault._push``` method.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.5 Redundant Calculation of LP Amounts",
    "severity": "minor",
    "body": "Design Low Version 5 Acknowledged\n\nThe function ERC20RootVault.deposit calculates the LP amount that is rewarded to the user two\ntimes:\n\n```\n{\n...\n(preLpAmount, isSignificantTvl) = _getLpAmount(maxTvl, tokenAmounts, supply);\nfor (uint256 i = 0; i < tokens.length; ++i) {\nnormalizedAmounts[i] = _getNormalizedAmount(...);\n...\n}\n}\nactualTokenAmounts = _push(normalizedAmounts, vaultOptions);\n(uint256 lpAmount, ) = _getLpAmount(maxTvl, actualTokenAmounts, supply);\n```\n\nInitially, preLpAmount is calculated based on the tokenAmounts, then normalizedAmounts are\ncomputed. Considering that _push moves tokens to the ERC20Vault, the returned\nactualTokenAmounts is equal to normalizedAmounts. Hence, recomputing lpAmount is\nredundant.\n\nAcknowledged:\n\nClient acknowledges the redundant calculation of LP amount but prefers to keep the code unchanged as\nin the future the behavior of ERC20Vault might change, i.e., the returned actualTokenAmounts might\nnot be equal to normalizedAmounts.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.6 Broad Access Control for Functions",
    "severity": "minor",
    "body": "Design Low Version 4 Acknowledged\n\nThe functions addDepositorsToAllowlist and removeDepositorsFromAllowlist in\nERC20RootVault restrict the access control with function _requireAtLeastStrategy. However,\nneither MStrategy nor LStrategy call these functions. Similarly, multiple functions in VaultGovernance\nuse the same access control, although they are not called by the strategies.\n\nAcknowledged:\n\nMellow Finance is aware that these functions are not called by smart contracts implementing the\nstrategies, but they can be called by an EOA in case it manages the vault system. Client replied:\n\n```\nThe vault system can be managed not by strategy, but by some account. In such a\ncase this account should have the possibility to edit `depositorsAllowList`.\nThese 2 functions exist for this reason.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.7 Redundant Check for baseSupply",
    "severity": "minor",
    "body": "Design Low Version 4 Acknowledged\n\nThe function ERC20RootVault._chargePerformanceFees performs a check of baseSupply is\nequal to 0, and returns if this is the case:\n\n```\nif ((performanceFee == 0) || (baseSupply == 0)) {\nreturn;\n}\n```\nHowever, this check is redundant because _chargeFees performs the same check and returns before\ncalling _chargePerformanceFees.\n\nAcknowledged:\n\nClient acknowledged the redundant check but has decided to keep it as it enhances the readability of the\ncode.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.12 UniV3Vault Pulls More Tokens Than",
    "body": "Requested\n\nCorrectness Low Version 1 Acknowledged\n\nUniV3Vault._pullUniV3Nft first calculates the amount of tokens to pull, then decreases the liquidity\ninside the Uniswap position and then collects the tokens. When the earnings have not been collected\nbefore, the last step additionally collects the earnings, returning more tokens than intended.\n\nThe function should take the tokens owed into consideration when calculating the amount to pull.\n\nAcknowledged\n\nMellow Finance acknowledged the issue and replied that the strategy maintainer can call the\ncollectEarnings function to collect all the fees.\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 5\n```\n- Mismatch of Specification With Uniswap V3 Oracle Code Corrected\n- Chainlink Oracle Returns Empty Prices Code Corrected\n- Incorrect LP Token Calculation in ERC20RootVault Code Corrected\n- Missing Access Control in UniV3Oracle Code Corrected\n- UniV3Oracle Returns Reverse Prices for Token Pairs Code Corrected\n\n```\nHigh-Severity Findings 14\n```\n- Incorrect TVL Conversion Code Corrected\n- Adding up Total Value Locked on Different Tokens Code Corrected\n- Calling _liquidityDelta Incorrectly Code Corrected\n- Calling _liquidityDelta With Incorrect Inputs Code Corrected\n- Incorrect Observation Index in _getAverageTick Code Corrected\n- Incorrect Parameters on externalCall Code Corrected\n- Insufficient Testing Code Corrected\n- Opposite Vaults Are Swapped Code Corrected\n- Possibility to Exit Positions of Any Address Code Corrected\n- Possible DOS From First Depositor Code Corrected\n- Setting Wrong State Variable Code Corrected\n- Wrong Formula in _rebalanceUniV3Liquidity Code Corrected\n- Wrong TVL Calculation in ERC20RootVault Code Corrected\n- liquidity Gets Overwritten in the Loop Code Corrected\n\n```\nMedium-Severity Findings 17\n```\n- Wrong State Variable Updated Code Corrected\n- Inconsistent Access Control for Rebalance in LStrategy Specification Changed\n- Inconsistent Sanity Check on First Deposit's Amounts Code Corrected\n- Safety Level of Returned Prices Can Silently Downgrade Specification Changed\n- Unfair Distribution of LP Shares in ERC20RootVault Code Corrected\n- Conflicting Specifications for MStrategy Specification Changed\n- Implementation Differs From Specification on _targetTokenRatioD Code Corrected\n- Incorrect Access of Addresses in EnumerableSet Code Corrected\n- Missing Checks for Dust Amounts When Rebalancing Pools Code Corrected\n- Missing Delay Restriction in BaseValidator Code Corrected\n\n\n- Missing Sanity Checks in signOrder Code Corrected\n- No Slippage Protection in Multiple Contracts Code Corrected\n- Possible Underflow in UniV3Oracle.price Code Corrected\n- Rebalance in LStrategy Can Leave Tokens in the Vault to Be Closed Code Corrected\n- Subvault Tokens Are Not Checked in AggregateVault Code Corrected\n- Transferring Tokens Only to lowerVault Code Corrected\n- Use of Libraries Code Corrected\n\nLow-Severity Findings 41\n\n- Missing Sanity Checks for intervalWidthInTicks Code Corrected\n- Possible Attack by First Depositor Specification Changed\n- Possible Optimization on _chargePerformanceFees Code Corrected\n- Possible Violation of the Minimum Token Amounts After the First Deposit Code Corrected\n- Misleading Function Name and Natspec Code Corrected\n- Mismatch of Specifications for StrategyParams Code Corrected\n- Missing Sanity Check for maxSlippageD in MStrategy Code Corrected\n- Missing Sanity Checks for oracleSafetyMask Code Corrected\n- Possible Struct Optimization in Strategies Code Corrected\n- Redundant Comparisons Code Corrected\n- Redundant Storage Read in ERC20Vault._pull Code Corrected\n- Variables Can Be Declared as Constant Code Corrected\n- Incorrect Specification for reclaimTokens Specification Changed\n- Missing Natspec Description for minDeviation Code Corrected\n- Casting of maxTickDeviation Code Corrected\n- Check Requirements First Code Corrected\n- Duplicate Code _permissionIdsToMask Code Corrected\n- Duplicate Storage Read in Deposit Code Corrected\n- Inconsistent Specifications Specification Changed\n- Inefficient Array Shrinking Code Corrected\n- Inefficient State Variable Packing Code Corrected\n- Misleading Naming of Variables in UniV3Oracle Code Corrected\n- Missing Sanity Check in MStrategy.createStrategy Code Corrected\n- Missing Sanity Checks for Params Code Corrected\n- Misspelled Variable Names Code Corrected\n- Possible Struct Optimization Code Corrected\n- Rebalance in MStrategy Is Inconsistent Code Corrected\n- Specification for minDeviation Not Enforced Code Corrected\n- Storing Redundant Data in Storage Code Corrected\n- Unnecessary Approval to Vault Registry Code Corrected\n\n\n- Unused Constant in ERC20Validator Code Corrected\n- Unused Event DeployedVault Code Corrected\n- Unused Function LStrategy._priceX96FromTick Code Corrected\n- Unused Imports Code Corrected\n- Wrong Check of Minimum Token Amounts in ERC20RootVault.withdraw Code Corrected\n- Wrong Specification for YearnVault.tvl Specification Changed\n- ContractRegistry DOS Code Corrected\n- ERC20Vault._pull Forces Push of Wrong Amount of Tokens Code Corrected\n- IntegrationVault._root Does Not Check the NFT of the Root Vault Code Corrected\n- VaultGovernance.commitInternalParams Does Not Delete Staged Parameters Code Corrected\n- registry.ownerOf Is Called Twice in IntegrationVault.pull Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.3 Incorrect LP Token Calculation in",
    "body": "ERC20RootVault\n\nCorrectness Critical Version 1 Code Corrected\n\nERC20RootVault._getLpAmount incorrectly calculates the minimum of given token amounts. An\nattacker can issue more LP tokens than he is entitled to and can then exchange them back for additional\ntokens.\n\nThe following code incorrectly resets the MIN calculation for as many iterations as tokenLpAmount is\nequal to 0:\n\n```\nfor (uint256 i = 0; i < tvlsLength; ++i) {\nif ((amounts[i] == 0) || (tvl_[i] == 0)) {\ncontinue;\n}\n```\n```\nuint256 tokenLpAmount = FullMath.mulDiv(amounts[i], supply, tvl_[i]);\nif ((tokenLpAmount < lpAmount) || (lpAmount == 0)) {\nlpAmount = tokenLpAmount;\n```\n\n### }\n\n### }\n\nIf tokenLpAmount == 0 in the first iteration, lpAmount will be set to 0. If tokenLpAmount > 0 in the\nnext iteration, lpAmount will be set to tokenLpAmount although it is larger than the already set value.\n\nIn a later step, ERC20RootVault._getNormalizedAmount normalizes the sent token amounts to the\ncalculated lpAmount. This function however does not increase the normalized amount to a value greater\nthan the sent one. An attacker can therefore exploit this by calling deposit with all token amounts but\nthe last one being set to 0 and then calling withdraw with the LP tokens that have just been minted to\nobtain his initial investment plus an amount of all other tokens in the Vault equal to the current ratio of\ntokens.\n\nCode corrected:\n\nThe function _getLpAmount has been refactored to set the lpAmount to the minimum of\ntokenLpAmount calculated on each iteration of the for loop. The flag isLpAmountUpdated is set to\ntrue on the first iteration that a non-zero value is assigned to lpAmount.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.9 Calling _liquidityDelta With Incorrect",
    "severity": "info",
    "body": "Inputs\n\nCorrectness High Version 1 Code Corrected\n\nThe function rebalanceERC20UniV3Vaults in LStrategy calls _liquidityDelta as follows:\n\n```\n(capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(\nerc20VaultCapital,\nerc20VaultCapital + lowerVaultCapital + upperVaultCapital,\nratioParams.erc20UniV3CapitalRatioD,\n```\n\n```\nratioParams.minErc20UniV3CapitalRatioDeviationD\n);\n```\nNote that, the first parameter is included in the sum used as the second parameter. However, the\nfunction _liquidityDelta also performs the addition on the code below, hence computing\ntargetLowerLiquidity incorrectly:\n\n```\nuint256 targetLowerLiquidity = FullMath.mulDiv(\ntargetLiquidityRatioD,\nlowerLiquidity + upperLiquidity,\nDENOMINATOR\n);\n```\nCode corrected:\n\nIn rebalanceERC20UniV3Vaults the calculation does not add erc20VaultCapital anymore.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.14 Possibility to Exit Positions of Any Address",
    "severity": "major",
    "body": "Security High Version 1 Code Corrected\n\nIn ERC20RootVault.withdraw, LP tokens are burned in a call to _burn from the address that is\nspecified in the to parameter. Neither _burn nor any other statement in withdraw performs access\ncontrol checks to verify if the msg.sender is allowed to burn the tokens of the given address. Thus, any\nuser can burn LP tokens of a given address and transfer the underlying tokens to that address.\n\nFinally, an incorrect event is emitted with msg.sender.\n\nCode corrected:\n\nThe issues have been resolved in the updated code Version 2. The function withdraw now burns only\nthe LP tokens of the msg.sender, while transfers the underlying tokens to the address to specified by\nthe caller.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.15 Possible DOS From First Depositor",
    "severity": "major",
    "body": "Security High Version 1 Code Corrected\n\nThe first user that calls deposit in ERC20RootVault can choose freely any amount (including zero) for\neach vault token, while the LP shares are set to the largest amount by the following loop in\n_getLpAmount:\n\n```\nfor (uint256 i = 0; i < tvl_.length; ++i) {\nif (amounts[i] > lpAmount) {\nlpAmount = amounts[i];\n}\n}\n```\nHowever, if the first user (on initialization or whenever totalSupply is zero) chooses to deposit only\none token (e.g., token[0]) it makes impossible for other users to deposit other tokens (e.g., token[1])\nas the totalSupply is not zero anymore, and _getNormalizedAmount considers the existing TVL:\n\n\n```\n// normalize amount\nuint256 res = FullMath.mulDiv(tvl_, lpAmount, supply); // if tvl_ == 0, res = 0\n```\nThe intended use of the function might be that the first deposit is done by a trusted account, but this is not\nenforced.\n\nCode corrected:\n\nA new constant FIRST_DEPOSIT_LIMIT is introduced and a require checks that each token amount is\nabove this limit with tokenAmounts[i] > FIRST_DEPOSIT_LIMIT.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.18 Wrong TVL Calculation in ERC20RootVault",
    "severity": "major",
    "body": "Correctness High Version 1 Code Corrected\n\nERC20RootVault._getTvlToken0 calculates the TVL of the Vault denominated in the token at\nposition 0 of an array of tokens. It iterates over all the tokens in the array, but only ever compares token\nwith index 0 to token with index 1. It should, however, compare token with index 0 to the token with the\ncurrent iteration's index. The function is only used in _calculatePerformanceFees.\n\n```\nfor (uint256 i = 1; i < tvls.length; i++) {\n(uint256[] memory prices, ) = oracle.price(tokens[0], tokens[1], 0x28);\n```\nCode corrected:\n\nThe issue has been resolved as the correct index is now used when querying the price of tokens inside\nthe loop.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.20 Wrong State Variable Updated",
    "severity": "medium",
    "body": "Design Medium Version 8 Code Corrected\n\nThe function LStrategy.rebalanceUniV3Vaults updates the wrong state variable when storing the\ntimestamp of the ongoing rebalance:\n\n```\nrequire(\nblock.timestamp >= lastRebalanceUniV3VaultsTimestamp + otherParams.secondsBetweenRebalances,\nExceptionsLibrary.TIMESTAMP\n);\nlastRebalanceERC20UniV3VaultsTimestamp = block.timestamp;\n```\nDue to this error the throttling mechanism does not work as expected for the function rebalancing the two\nuniswap vaults. Furthermore, this also affects the throttling mechanism of the function\nrebalanceERC20UniV3Vaults.\n\nCode corrected:\n\nThe issue has been fixed and the correct state variable is updated in rebalanceUniV3Vaults:\n\n```\nlastRebalanceUniV3VaultsTimestamp = block.timestamp;\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.21 Inconsistent Access Control for Rebalance in",
    "body": "LStrategy\n\nDesign Medium Version 4 Specification Changed\n\nThe function LStrategy.rebalanceERC20UniV3Vaults restricts the access to only accounts with\noperator or admin roles. However, functions deposit and withdraw in the ERC20RootVault do not\nhave any access restriction (unless the vault is private). The root vault has the operator role in\nLStrategy and for any deposit or withdraw operation, the vault triggers the rebalance function in\nLStrategy, hence circumventing the access control of the rebalance function.\n\nSpecification changed:\n\nMellow Finance has decided to remove the callback feature that triggered the rebalance in LStrategy.\nNow, the rebalance functions rebalanceERC20UniV3Vaults and rebalanceUniV3Vaults can be\ncalled only by whitelisted addresses with either admin or operator role. Note that, the callback feature\nis still present in ERC20RootVault in case future strategies will support the callback feature.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.22 Inconsistent Sanity Check on First Deposit's",
    "body": "Amounts\n\nDesign Medium Version 4 Code Corrected\n\nThe function ERC20RootVault.deposit runs the following loop for the first deposit (whenever\ntotalSupply is 0 ) to check that all amounts are above a threshold FIRST_DEPOSIT_LIMIT\n(hard-coded to 10000 ):\n\n```\nif (totalSupply == 0) {\nfor (uint256 i = 0; i < tokens.length; ++i) {\nrequire(tokenAmounts[i] > FIRST_DEPOSIT_LIMIT, ExceptionsLibrary.LIMIT_UNDERFLOW);\n}\n}\n```\nThe contract uses another set of thresholds per token _pullExistentials which are initialized as:\n10**(token.decimals() / 2). Hence for tokens with more than 8 decimals, there is a gap between\nthe two thresholds FIRST_DEPOSIT_LIMIT and _pullExistentials. If the first deposit includes an\namount for a token in this gap, the contract does not allow new deposits for the token from other users as\nthe respective TVL will be always below the threshold _pullExistentials. This behavior is enforced\nin _getLpAmount:\n\n```\nfor (uint256 i = 0; i < tvlsLength; ++i) {\nif (tvl_[i] < pullExistentials[i]) {\ncontinue;\n}\n...\n}\n```\nand in the function _getNormalizedAmount:\n\n```\nif (tvl_ < existentialsAmount) {\n// use zero-normalization when all tvls are dust-like\nreturn 0;\n}\n```\nCode corrected:\n\nMellow Finance now requires that the amount in the first deposit is 10 times the _pullExistentials.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.24 Unfair Distribution of LP Shares in",
    "body": "ERC20RootVault\n\nDesign Medium Version 3 Code Corrected\n\nThe ERC20RootVault charges the management, protocol and performance fees by minting new LP\nshares, hence inflating the total supply. The function _chargeFees is triggered on every deposit (and\nwithdraw) action, hence the total supply of LP shares after a deposit increases more than the amount of\nLP shares awarded to the depositor. In this way, a second deposit of the same token amounts after the\nfees have been charged, receives more LP shares than the first one.\n\nFor example, assume that the ERC20RootVault has been initialized and a first user deposits 10\nTokenA and 10 TokenB (assuming 0 decimals for simplicity) and receives 10 LP shares. As the fees will\nbe charged on deposit, let's suppose another 1 LP share will be minted, hence in total there are 11 LP\nshares minted after the deposit. If a second user deposits the same amounts 10 TokenA and 10\nTokenB, the function _getLpAmount will award 11 LP shares to the user although the same amounts\nwere deposited.\n\nCode corrected:\n\n\nThe issue has been addressed by modifying the functions deposit to charge fees first and then\ncompute the LP shares awarded to the user according to the new LP supply.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.31 No Slippage Protection in Multiple Contracts",
    "severity": "medium",
    "body": "Security Medium Version 1 Code Corrected\n\npush and pull functions in UniV3Vault take options arguments that contain the minimum amount of\ntokens for slippage protection.\n\n\npush and pull functions in MellowVault take an options argument that contains the minimum amount\nof LP tokens for slippage protection.\n\nIn the following cases, these options are not used:\n\n- ERC20RootVault.deposit calls AggregateVault._push without options, which could result in\n    a call to _push of one of the described\n    Vault``s without slippage protection if the first ``subVault of the\n    ERC20RootVault is one of the described Vault s. With the current contract setup, this is not\n    possible though.\n- ERC20RootVault.withdraw calls AggregateVault._pull without options, which could result\n    in a call to _pull of one of the described ``Vault``s without slippage protection.\n- MStrategy.manualPull calls pull of an arbitrary Vault without options, which could result in a\n    call to _pull of one of the described ``Vault``s without slippage protection.\n- MStrategy._rebalancePools calls pull of an arbitrary Vault without options, which could\n    result in a call to _pull of one of the described ``Vault``s without slippage protection.\n- MStrategy._swapToTarget calls pull of an arbitrary Vault without options, which could result\n    in a call to _pull of one of the described ``Vault``s without slippage protection.\n\nCode corrected:\n\nA new parameter with option for slippage protection was introduced.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.39 Possible Optimization on",
    "body": "_chargePerformanceFees\n\nDesign Low Version 5 Code Corrected\n\nThe function _chargePerformanceFees in ERC20RootVault mints LP tokens to the treasury\naddress as follows:\n\n```\nuint256 toMint;\nif (hwmsD18 > 0) {\ntoMint = FullMath.mulDiv(baseSupply, lpPriceD18 - hwmsD18, hwmsD18);\ntoMint = FullMath.mulDiv(toMint, performanceFee, CommonLibrary.DENOMINATOR);\n}\nlpPriceHighWaterMarkD18 = lpPriceD18;\n_mint(treasury, toMint);\n```\nThe function would be more gas efficient if the minting is executed only for non-zero values, hence only\nminting when the if-condition is satisfied.\n\nCode corrected:\n\nIn the updated code, the statement _mint(...) is moved inside the if-block, hence minting only\nnon-zero amounts.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.40 Possible Violation of the Minimum Token",
    "body": "Amounts After the First Deposit\n\nDesign Low Version 5 Code Corrected\n\nThe function ERC20RootVault.deposit checks on the first deposit that all token amounts are larger\nthan a minimum value 10 * _pullExistentials[i]. If the TVL for a token goes below the\nthreshold, users cannot make deposits for that token. However, the first depositor can circumvent the\nrestriction for the minimum token amounts by performing an withdrawal after the deposit.\n\nCode corrected:\n\nThe issue presented above is not present anymore in the updated code base as the first deposit always\nmints LP shares to address(0).",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.47 Redundant Storage Read in",
    "body": "ERC20Vault._pull\n\nDesign Low Version 4 Code Corrected\n\n_vaultTokens is a state variable that is read multiple times in the _pull function even though it is\nstored in memory at the beginning of the function in tokens.\n\n\nCode corrected:\n\nThe function has been revised to avoid storage reads for _vaultTokens, instead the value stored in\nmemory tokens is now used.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.48 Variables Can Be Declared as Constant",
    "severity": "minor",
    "body": "Design Low Version 4 Code Corrected\n\nThe variable MAX_ESTIMATED_AAVE_APY in AaveVaultGovernance is declared as immutable and\nassigned to a constant in constructor. Similarly, MAX_PROTOCOL_FEE, MAX_MANAGEMENT_FEE and\nMAX_PERFORMANCE_FEE in ERC20RootVaultGovernance can be declared as constants.\n\nCode corrected:\n\nAll immutable variables listed above are converted to constants.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.54 Duplicate Storage Read in Deposit",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nIn ERC20RootVault.deposit the variable totalSupply is read for the check if it is 0 and later again\nto be loaded into memory.\n\nCode corrected:\n\nThe redundant storage read is eliminated in the updated code and the value stored in memory supply is\nused instead.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.57 Inefficient State Variable Packing",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nlastFeeCharge and totalWithdrawnAmountsTimestamp in ERC20RootVault are declared as\nuint256. Both are timestamps; hence, it might be more efficient to pack them as uint64. This only\nmakes sense if they are used and loaded together, which would be possible in the current code base.\nSimilarly, other structs in other contracts can be more storage-efficient by packing variables together.\n\nCode corrected:\n\nBoth variables lastFeeCharge and totalWithdrawnAmountsTimestamp have been declared as\nuint64 in the updated code.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.61 Misspelled Variable Names",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nFunction deposit in ERC20RootVault declares a variable with misspelled name:\ndelayedStaretgyParams.\n\nStruct ratioParams in MStrategy declares a variable with misspelled name: tickNeiborhood.\n\nCode corrected:\n\nBoth variable names have been corrected in the updated code.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.64 Specification for minDeviation Not",
    "body": "Enforced\n\nCorrectness Low Version 1 Code Corrected\n\nThe function rebalanceERC20UniV3Vaults in LStrategy calls the function _liquidityDelta and\nprovides the minimum required deviation for a rebalance to be performed. _liquidityDelta checks\nthe current deviation and if it is lower than the required minimum, it returns 0. However, the calling\nfunction does not check the return value, hence continues the execution of the function although no\ntokens will be moved.\n\nCode corrected:\n\nThe check below for the return value of the function _liquidityDelta has been added. Now the\nfunction returns immediately if capitalDelta is equal to 0 due to current deviation being smaller than\nthe minimum required deviation:\n\n\n```\n(capitalDelta, isNegativeCapitalDelta) = _liquidityDelta(...);\nif (capitalDelta == 0) {\nreturn (pulledAmounts, false);\n}\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.67 Unused Constant in ERC20Validator",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nERC20Validator declares the following constant, but it is not used:\n\n```\nbytes4 public constant EXCHANGE_SELECTOR = 0x3df02124;\n```\nCode corrected:\n\n\nThe constant was removed from the contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.70 Unused Imports",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThroughout the code base we found many unused imports. Due to the number of unused imports, the\nfollowing list is non-exhaustive and list only examples:\n\n- MellowOracle\n\n```\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"\nimport \"../libraries/CommonLibrary.sol\";\n```\n- UniV2Oracle\n    import \"../libraries/ExceptionsLibrary.sol\"\n- UniV3Oracle\n\n```\nimport \"../libraries/ExceptionsLibrary.sol\"\n```\n- LStrategy\n    import \"../interfaces/IVaultRegistry.sol\"\n    import \"../interfaces/utils/IContractMeta.sol\"\n- MStrategy\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n```\n- CowswapValidator\n\n\n```\nimport \"../libraries/CommonLibrary.sol\"\nimport \"../libraries/PermissionIdsLibrary.sol\"\n```\n- CurveValidator\n    import \"../libraries/CommonLibrary.sol\"\n    import \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"\n\n```\nimport \"../interfaces/validators/IValidator.sol\";\n```\n- ERC20Validator\n    import \"../libraries/CommonLibrary.sol\"\n- UniV2Validator and UniV3Validator\n    import \"../interfaces/validators/IValidator.sol\";\n\n```\nimport \"../libraries/CommonLibrary.sol\"\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\"\n```\n- AaveVault\n    import \"../interfaces/vaults/IVault.sol\"\n- AggregateVault\n\n```\nimport \"../interfaces/vaults/IAggregateVault.sol\";\nimport \"../libraries/PermissionIdsLibrary.sol\"\n```\n- ERC20RootVault\n    import \"../interfaces/utils/IContractMeta.sol\"\n\nCode partially corrected:\n\nThe unused imports have been removed from the respective contracts for all examples listed above,\nexcept for the SafeERC20 import in the MStrategy.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.71 Wrong Check of Minimum Token Amounts in",
    "body": "ERC20RootVault.withdraw\n\nCorrectness Low Version 1 Code Corrected\n\nERC20RootVault.withdraw compares the token amounts a user wants to receive at minimum with\nthe calculated token amounts, but not the token amounts that are actually returned after pulling from\nunderlying Vault s. This could potentially result in the user receiving less tokens than anticipated.\n\nCode corrected:\n\nThe actual token amounts pulled from vaults are now validated against the minimum amounts provided\nby the user: `` require(actualTokenAmounts[i] >= minTokenAmounts[i],...);``",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.74 ERC20Vault._pull Forces Push of Wrong",
    "body": "Amount of Tokens\n\nCorrectness Low Version 1 Code Corrected\n\nIn ERC20Vault._pull, if tokens are not pulled to the ERC20RootVault, the receiving Vault is forced\nto push the received tokens. The token amounts to be pushed are set in actualTokenAmounts, but\nthis variable is never used. Instead tokenAmounts is used.\n\nCode corrected:\n\nThe code has been corrected to push into the integration vault the amounts as stored in\nactualTokenAmounts.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "6.75 IntegrationVault._root Does Not Check",
    "body": "the NFT of the Root Vault\n\nCorrectness Low Version 1 Code Corrected\n\nIntegrationVault._root tries to verify the initialization of a given Vault and its corresponding\nERC20RootVault with the following code:\n\n```\nrequire(thisNft + thisOwnerNft != 0, ExceptionsLibrary.INIT);\n```\nIf thisNft is set (greater than 0) and thisOwnerNft equals 0, no revert will happen. _root is called in\npull only. pull already checks that the argument thisNft given to _root is not equal to 0 which\nrenders the require useless.\n\nCode corrected:\n\nThe statement was changed and checks each variable separately if it is zero in\n(thisNft != 0) && (thisOwnerNft != 0).",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.3 Deposits Can Be Blocked by Updating",
    "body": "StrategyParams\n\nNote Version 1\n\nThe function ERC20RootVaultGovernance.setStrategyParams does not perform any sanity check\nfor the new parameters being set, hence if tokenLimitPerAddress or tokenLimit is set to zero, the\nfunctionality to deposit is blocked. The sanity checks are not enforced intentionally as the admin might\nuse these parameters to block deposits into a root vault by updating these parameters.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.9 Locked Token or ETH",
    "body": "Note Version 1\n\nERC20 tokens could be accidentally/intentionally sent to any contract. In such cases the tokens will be\nlocked. Only externalCall for intergration vaults offers some functionality to recover funds.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.10 No Checks for Address to on ERC20Token",
    "body": "Transfer\n\nNote Version 1\n\nThe functions transfer and transferFrom in ERC20Token do not perform any sanity check for the\naddress to, hence making it possible to burn tokens by sending them to address 0x0.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.14 Performance Fee Capped",
    "body": "Note Version 5\n\nERC20RootVault._chargePerformanceFees only charges performance fees for the strategy if the\nprice of LP tokens has reached a new high score. When prices have fallen, the fees are still not charged\neven when prices climb again until this all-time high has been reached again.\n\nAdditionally, if all liquidity providers withdraw their funds and the totalSupply is zero, or all token TVLs\nare less than _pullExistentials, the previous high score lpPriceHighWaterMarkD18 is not\nreset, hence performance fees might not be collected as expected.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.17 Special Behavior in ERC20Token",
    "body": "Note Version 1\n\nThe function transferFrom has a special behavior when allowance==type(uint256).max, as the\nallowance is never reduced when these transfers occur. This special behavior should be properly\ndocumented as users should be aware of it.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "7.23 LStrategy Needs Tokens to Create Uniswap",
    "body": "Positions\n\nNote Version 1\n\nThe function _mintNewNft assumes that the strategy contract has enough balance to open new\nUniswap positions as needed, otherwise new Uniswap NFTs cannot be minted:\n\n```\nIERC20(tokens[0]).safeApprove(address(positionManager), minToken0ForOpening);\nIERC20(tokens[1]).safeApprove(address(positionManager), minToken1ForOpening);\n(newNft, , , ) = positionManager.mint(\nINonfungiblePositionManager.MintParams({\ntoken0: tokens[0],\ntoken1: tokens[1],\nfee: poolFee,\ntickLower: lowerTick,\ntickUpper: upperTick,\namount0Desired: minToken0ForOpening, // required balance\namount1Desired: minToken1ForOpening, // required balance\namount0Min: 0,\namount1Min: 0,\nrecipient: address(this),\ndeadline: deadline\n})\n);\n```\n\nMellow Finance is aware of this requirement and states they will take care that enough funds are\navailable at any point in time. Additionally, a check was added to ensure that the amount of token needed\nin the contract is very low (less than 10**9) to mitigate that money is lost because of the deactivated\nslippage protection in the function above.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/08/ChainSecurity_Mellow_Finance_Mellow_Vaults_audit.pdf"
    }
  },
  {
    "title": "5.1 Solv's BUYER_PAY Fee Pay Type Is",
    "body": "Unsupported\n\nCorrectness Low Version 1 Code Partially Corrected Risk Accepted\n\nWhen buying vouchers from the marketplace, fees are paid. Note that Solv has two fee pay types such\nthat either the buyer or the seller pays fees. If the buyer pays, the fee is added to the amount transferred\nfrom the buyer. Note that Solv's internal function _buy() will transfer transferInAmount from the\nbuyer which is defined as amount_.add(fee_).\n\nThe external position for the buyer side does not consider that which leads to the following\nconsequences:\n\n```\n1.Action BuySaleByAmount is not supported if the fee type is BUYER_PAY as the approval made will\nbe insufficient.\n2.Action BuySaleByUnits is not supported if the fee type is BUYER_PAY as the funds sent from the\nvault will not be sufficient to perform the action.\n```\n```\nwith the exception that if some unreconcilled funds are available to the external position, the funds\ncould be sufficient to perform the action.\n```\nCode partially corrected:\n\n```\n1.Not corrected: Note that buying by amount on Solv will not transfer in the passed in amount but the\npassed in amount plus fees. However, BuyByAmount does not consider fees. See the code of\nSolvConvertibleMarket.sol file here\nhttps://etherscan.io/address/0x29935f54a45f5955ad7bc9d5416f746c3d1b9d69 on line 502.\n```\n```\nif (vars.feePayType == FeePayType.BUYER_PAY) {\nvars.transferInAmount = amount_.add(fee_);\n...}\n...\n```\n\n```\nERC20TransferHelper.doTransferIn(\nsale_.currency,\nbuyer_,\nvars.transferInAmount\n);\n```\n```\nUltimately, insufficient funds could be moved and the approval given to Solv could be insufficient.\n2.Code corrected: The code has been adapted such that the fee is in included in the transferred in\namount.\n```\nNote that the fee computation made for the BuyByUnits action could be off. There is a special case\nwhere the voucher's underlying could be also the currency. In such situations the fee is computed\ndifferently and is based on repoFeeRate instead of the market's feeRate.\n\nRisk accepted:\n\nAvantgarde Finance states the following:\n\n```\nthe Solv team says that they will upgrade to the version of `SolvConvertibleMarket` that is in their GitHub repo (b207d5e), which fixes this issue(buyer fee is deducted from `amount`, and there is no longer a `repoFeeRate`). The Enzyme Council will assure that the upgrade has occurred before\nadding the external position type. Even if no upgrade were to occur, the worst case is that `BuySaleByAmount` will revert when there is a buyer fee,\nwhich does not result in value loss for the fund.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- Solv Issuer Double Accounting Code Corrected\n\n```\nMedium-Severity Findings 5\n```\n- Full Balance Is Pushed on Reconciliation Code Corrected\n- Offer ID and Voucher Mismatch Code Corrected\n- Solv Finance: No Support for Raw ETH as Currency Code Corrected\n- Solv Issuer Ignores Possibly Withdrawable Voucher Slots Code Corrected\n- getManagedAssets for Solv Buyer Side Reverts if Maturity Not Reached Specification Changed\n\n```\nLow-Severity Findings 2\n```\n- Incomplete NatSpec for ManualValueOracleLib.init() Code Corrected\n- assetsToReceive Not Containing Assets Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.4 Solv Finance: No Support for Raw ETH as",
    "body": "Currency\n\nDesign Medium Version 1 Code Corrected\n\nRaw ETH is not supported as a currency for the Solv convertible vouchers. This is problematic because\nSolv supports ETH through the doTransferOut function in the ERC20TransferHelper library, which\nuses a special constant address ETH_ADDRESS for such raw currency transfers. Given the lack of sanity\nchecks for the assets in a voucher, it could be possible that such a voucher becomes unredeemable (e.g.\nclaim action while fund currency is ETH).\n\nCode corrected:\n\nThe function __validateNotNativeToken was added to verify that the asset's address is not equal to\nthe special value NATIVE_TOKEN_ADDRESS.",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Sulu-Extensions-V-Smart-Contract-audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.4 CometInterface Not Implemented by the",
    "body": "Contracts\n\nCorrectness Medium Version 1 Code Corrected\n\nThe contracts Comet and CometExt contracts do not extend the CometInterface. This can lead to\nerrors during development and integration by third parties as the interface does not match up with the\nimplementations. One such error is that the contracts do not implement an accrue function even though\nit is defined in the CometInterface:\n\n```\nabstract contract CometInterface is CometCore, ERC20 {\n...\nfunction accrue() virtual external;\n```\n\nCode corrected:\n\nCometInterface was split into CometMainInterface and CometExtInterface. Comet now\nimplements CometMainInterface, and CometExt now implements CometExtInterface.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf"
    }
  },
  {
    "title": "6.9 No Recovery of Accidental Token Transfers",
    "body": "Possible\n\nDesign Low Version 1 Code Corrected\n\nIn case an ERC-20 token other than the base tokens or collateral tokens is sent to the contract, then it\ncannot be recovered. Among other reasons, this might happen due to airdrops based on the base tokens\nor collateral tokens.\n\nCode corrected:\n\nA new function approveThis has been introduced to allow the governance to approve any ERC20 token\nto any address.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf"
    }
  },
  {
    "title": "6.11 Possible Gas Savings",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\n- The function _getPackedAsset calls the decimals function of the asset ERC20 contract and\n    checks if it equals the provided decimals variable in AssetConfig. Since the external call to\n    asset is done anyways, there is no need to provide the decimals in the config and perform this\n    check.\n- The function supplyCollateral calls getAddressInfoByAddress and updateAssetsIn\n    which calls getAddressInfoByAddress for the same address again.\n- The function absorbInternal calls isLiquidatable and then proceeds to perform a very\n    similar computation (including the same calls to the price oracles) again.\n- The function isBorrowCollateralized is expected to be commonly called for contracts with a\n    non-negative base balance, e.g., for address(this) in buyCollateral. In those cases,\n    isBorrowCollateralized can return true as soon as presentValue is non-negative. Then,\n    the call to the price oracle can be skipped.\n\nCode corrected:\n\n- Not corrected: The additional decimals value in the supplied config is used as sanity check to\n    determine if the caller actually knows the decimals of the asset being configured.\n- Corrected: updateAssetsIn now takes AssetInfo as argument and does not load asset infos\n    itself anymore.\n\n\n- Not corrected: Compound claims that the compiler already optimizes the functions.\n- Corrected: isBorrowCollateralized now checks if the user's present value is greater than or\n    equal to zero before performing any calculations.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf"
    }
  },
  {
    "title": "7.1 Event Reordering Possible",
    "body": "Note Version 1\n\ndoTransferIn and doTransferOut are always called before events are emitted. If the respective\nERC20 tokens that are called implement callbacks to the sender or receiver, events could possibly be\nreordered due to reentrancy. While this is not problematic for the contract itself, this can introduce errors\nin third-party applications that make certain assumptions about the emitted events.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf"
    }
  },
  {
    "title": "7.5 Supported Tokens",
    "body": "Note Version 1\n\nNot all ERC20 tokens can act as base and collateral tokens for Comet contracts. In particular, the\nfollowing tokens are not supported:\n\n- Tokens with more than 18 decimals\n- Tokens with less than 6 decimals, e.g., GUSD\n- Tokens with transfer fees\n- Tokens where the balance can change without a transfer, these include:\n    - Interest bearing tokens that increase balances\n    - Deflationary tokens that decrease balances\n    - Rebasing tokens\n- Tokens with a missing return value on transfer or transferFrom (e.g., USDT)\n- Tokens that require certain receiver functions to be implemented in contracts, e.g., ERC223\n- Tokens with rapidly increasing/positively manipulatable prices (cannot be used as base token)\n- Tokens with rapidly decreasing/negatively manipulatable prices (cannot be used as collateral token)\n- Tokens with multiple entry points for which more than one entry point has been added to the\n    contract's collateral assets.\n\nAdditionally the following tokens can break the protocol depending on their use:\n\n- Tokens with blacklisting in case a Comet contract is blacklisted\n- Pausable tokens when paused\n- Upgradable tokens that later introduce one of the problematic features",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/07/ChainSecurity_Compound_Comet_audit_May-30th-2022-1.pdf"
    }
  },
  {
    "title": "6.9 Inconsistent Error Message",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\n\nThe error codes in modifier onlyTreasury in BaseAgTokenSideChain.sol and\nfunction setTreasury in BaseOracleChainlinkMulti.sol are inconsistent with the respective\ndescriptions in errorMessages.json.\n\nFurthermore, most of the contracts use numbers as error messages, and the file errorMessages.json\nmaps each error code to a meaningful description. However, in BaseReactor the following messages\nare used:\n\n```\nrequire((assets = _convertToAssets(shares, usedAssets + looseAssets, 0)) != 0, \"ZERO_ASSETS\");\nrequire(currentAllowance >= shares, \"ERC20: transfer amount exceeds allowance\");\n```\nCode corrected:\n\nThe error messages have been revised on the whole codebase and a new approach is used:\n\n```\nif(!condition) revert CustomErrorMessage();\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Angle_Borrowing_Module_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Angle_Angle_Borrowing_Module_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Angle_Angle_Borrowing_Module_audit.pdf"
    }
  },
  {
    "title": "8.5 Tokens With Transfer Fees",
    "body": "Note Version 1\n\nMangrove is supposed to handle the exchange of ERC20 tokens. As shown in the snippet below, the\nsystem expects to send to the maker the same amount (sor.gives) it received from the taker.\nHowever, in the case of the tokens with transfer fees this trade will fail since the amount received and\nforwarded by Mangrove will be different than the one requested due to the fees. By providing additional\nbalance of this token to the contract ahead of the transaction, a party may make the transfer to succeed\nnevertheless. This may be done by either the maker or the taker. The other party then receives less\ntokens then expected, as the transfer fee will be deducted.\n\n```\nif (transferTokenFrom(sor.quote, taker, address(this), sor.gives)) {\nif (\ntransferToken(\nsor.quote,\n$$(offerDetail_maker(\"sor.offerDetail\")),\nsor.gives\n)\n) {\n```\n```\n...\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Giry_Mangrove_audit_220511.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/03/ChainSecurity_Giry_Mangrove_audit_220511.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/03/ChainSecurity_Giry_Mangrove_audit_220511.pdf"
    }
  },
  {
    "title": "6.5 LendAndStake Stakes the Full Balance",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nLendAndStake is an action wrapping the lending and the staking action. First, it lends an amount of\nliquidity assets to the Maple pool. Next, it stakes LP tokens to the rewards contract to get some extra\nrewards:\n\n```\nfunction __lendAndStakeAction(bytes memory _actionArgs) private {\n(\naddress pool,\naddress rewardsContract,\nuint256 liquidityAssetAmount\n) = __decodeLendAndStakeActionArgs(_actionArgs);\n__lend(IMaplePool(pool).liquidityAsset(), pool, liquidityAssetAmount);\n__stake(rewardsContract, pool, ERC20(pool).balanceOf(address(this)));\n}\n```\nThe argument passed to the internal __stake function is the full balance of the pool token. Note that it is\nalso possible to lend the underlying without staking. Consider now the following scenario:\n\n```",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Sulu-Extensions-IV-Smart-Contract-audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/Enzyme-Sulu-Extensions-IV-Smart-Contract-audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/Enzyme-Sulu-Extensions-IV-Smart-Contract-audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "7.5 View Functions Reentrancy",
    "severity": "medium",
    "body": "Security Medium Version 1 Code Corrected\n\nSome view functions don't use the _viewlock_ modifier. In case of reentrancy due to ERC20 token\ncalls (e.g. ERC777), these getters can return unreliable data. This may break the integration with other\ncontracts and systems that rely on these getters. Such getter functions are:\n\n\n- getAmountOutGivenInMMM\n\nPlease note, this list might be incomplete. Any function of a contract that does external call need to be\nlock or viewlock protected, if other external contract might rely on the data from this contract, such as\nspot prices, weights, etc.\n\nCode corrected:\n\nView locks have been added to all view functions in the Pool.sol contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf"
    }
  },
  {
    "title": "8.2 ERC20 Compatibility",
    "body": "Note Version 1\n\nThe _pull/_pushUnderlying functions of the Pool expect transferFrom and transfer to always\nreturn a boolean. However, some tokens, for example USDT, do not follow this pattern and are thus\nincompatible with the system. OpenZeppelin has a SafeERC20 library, which helps with such tokens.\n\nIn addition, the usage of ERC20 tokens with fees, rebalancing tokens, or tokens with reentrancies can be\nproblematic to integrate. Swaap Labs needs to carefully consider what tokens can be supported by the\nPool.\n\nThe _pull/_pushUnderlying functions have been modified to use the SafeERC20 library for token\ntransfer.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Swaap_Labs_Swaap_Core_V1_audit_May-10th-2022.pdf"
    }
  },
  {
    "title": "6.1 Incorrect Index Used to Access",
    "body": "depositorsIndex\n\nCorrectness High Version 3 Code Corrected\n\nIn the function addDepositor of ClaimRewards , values of depositorsIndex are set using\ndepositor addresses as indexes.\n\n```\ndepositorsIndex[_depositor] = depositorsCount;\n```\nIn claimAndLock this array is accessed twice using token addresses as indexes.\n\n```\nif (depositor != address(0) && lockStatus.locked[depositorsIndex[token]]) {\nIERC20(token).approve(depositor, balance);\n```\n\n```\nif (lockStatus.staked[depositorsIndex[token]]) {\nIDepositor(depositor).deposit(balance, false, true, msg.sender);\n} else {\nIDepositor(depositor).deposit(balance, false, false, msg.sender);\n}\n```\nGiven that there are no contract defining both a token and a depositor in the codebase, it would most\nlikely lead depositorsIndex[token] to always evaluate to 0 and hence use the first element of\nlockStatus.staked and lockStatus.locked as decisions for each token.\n\nCode corrected\n\nThe variable depositor is now used to address depositorsIndex in claimAndLock.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.2 Possible to Lock Users' Funds Into veSDT",
    "severity": "medium",
    "body": "Design Medium Version 3 Code Corrected\n\nUsers that lock their tokens into the voting escrow contract need to approve an allowance to veSDT and\nthen call deposit_for or deposit_for_from to transfer the tokens. However, if a user approves to\nthe veSDT an amount that is larger than the intended amount of tokens to be locked, or max uint for\nsimplicity, the user's tokens are exposed to arbitrary locking. In such cases the function deposit_for\nallows anyone to lock more of user's tokens into the contract without their clear consent. This is possible\nbecause the function deposit_for calls the internal function _deposit_for without passing the\nmsg.sender as a parameter:\n\n```\ndef deposit_for(_addr: address, _value: uint256):\n...\nself._deposit_for(_addr, _value, 0, self.locked[_addr], DEPOSIT_FOR_TYPE)\n```\nThe internal function transfers the tokens from _addr if enough allowance exists, while the caller only\npays the gas costs:\n\n```\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128):\n...\nif _value != 0:\nassert ERC20(self.token).transferFrom(_addr, self, _value)\n```\nCode corrected\n\nStakeDAO corrected the issue by adding the new parameter _from to _deposit_from and using it\ninstead of _addr for the ERC20 transfer. Whenever _deposit_from is called, msg.sender is passed\nas an argument so that _from is always equal to it. Anyone is still able to call deposit_for or\ndeposit_for_from for someone else, but it is now the caller's tokens that are deposited.\n\n```\ndef _deposit_for(_addr: address, _value: uint256, unlock_time: uint256, locked_balance: LockedBalance, type: int128, _from: address):\n...\nif _value != 0:\nassert ERC20(self.token).transferFrom(_from, self, _value)\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.6 Inconsistent Specification: initialize",
    "severity": "minor",
    "body": "Correctness Low Version 3 Code Corrected\n\nThe NatSpec description of veSDT's initialize function describe token_addr as being the address\nof the ERC20ANGLE contract while the contract is a voting escrow for the SDT token.\n\nCode corrected\n\nStakeDAO corrected the NatSpec description by replacing ERC20ANGLE by ERC20SDT.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.7 Possible to Optimize the Check on Distributor",
    "body": "of tokenReward\n\nDesign Low Version 3 Code Corrected\n\nThe function BaseAccumulator._notifyReward checks if the distributor of _tokenReward is not\naddress(0), then it performs the two external calls as shown below:\n\n```\nif (ILiquidityGauge(gauge).reward_data(_tokenReward).distributor != address(0)) {\nIERC20(_tokenReward).approve(gauge, _amount);\nILiquidityGauge(gauge).deposit_reward_token(_tokenReward, _amount);\n...\n}\n```\nThe function call deposit_reward_token succeeds only if the accumulator is the distributor for the\n_tokenReward, otherwise it reverts. Hence, the function could be optimized by directly checking if the\ndistributor of the _tokenReward is the accumulator.\n\nCode corrected\n\nThe condition checks immediately if the address is the accumulator.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.13 Unused Imports: FxsDepositor",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe file FxsDepositor.sol (Version 2 Depositor contract) has the following unused import:\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n```\nCode corrected\n\nThe unused libraries listed above have been removed from the updated code.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.15 Unused Imports: sdFXSToken",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe file sdFXSToken.sol (Version 2 sdToken) has the following unused imports:\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n```\n\n```\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n```\nCode corrected\n\nThe unused libraries listed above have been removed from the updated code.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "7.6 Possible Reentrancy in lockToken for Special",
    "body": "Tokens\n\nNote Version 3\n\nThe function Depositor.lockToken performs a mint operation and afterwards emits an event and\nupdates the state variable incentiveToken:\n\n```\nif (incentiveToken > 0) {\nITokenMinter(minter).mint(msg.sender, incentiveToken);\nemit IncentiveReceived(msg.sender, incentiveToken);\nincentiveToken = 0;\n}\n```\nIn the current code base, minter token is always the sdToken which extends the ERC20 standard and\ndoes not provide any callback functionality to the receiver, hence the code above is not vulnerable to\nreentrancy attacks. However, if in the future versions of the code the minter token is supposed to\nsupport callbacks, e.g., implement ERC777 standard and the mint operation provides an opportunity for\nreentrancy, the above function would be exploitable.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "7.7 Reward Distribution Should Be Called",
    "body": "Periodically for All Gauges\n\nNote Version 3\n\nThe function SdtDistributor.distributeMulti works correctly only if it is called periodically (at\nleast once a day) for all the gauges, otherwise the following two issues arise:\n\n```\n1.Failing to call distributeMulti for a gauge on a given day means that the gauge does not\nreceive its share of rewards for the respective day and the funds are locked in the contract.\nOnly the governance can recover these funds via recoverERC20 function.\n2.On the time period that overlaps with the weekly event of updating votes for gauges, there is a\ntime window for a malicious user to manipulate the rewards distributed to gauges. For example,\nif a gauge receives a higher weight for the following week, it is profitable for a malicious user to\ncall the function distributeMulti when the new weight is applied, and vice-versa. This\nmakes the accounting of rewards in SdtDistributor incorrect and potentially can prevent\nlegit gauges from receives any reward.\n```\nAs stated in the System Overview, StakeDAO should run a bot that guarantees the function is called\nperiodically and correctly for all gauges to prevent the issues above.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "7.10 safeApprove Usage",
    "body": "Note Version 1\n\nThe contract FxsDepositor (Depositor in Version 2) uses safeApprove to update the allowance\ngiven to the gauge. As explained in the specifications of the function, safeApprove is deprecated.\n\n### /**\n\n```\n* @dev Deprecated. This function has issues similar to the ones found in\n* {IERC20-approve}, and its usage is discouraged.\n*\n* Whenever possible, use {safeIncreaseAllowance} and\n```\n\n* {safeDecreaseAllowance} instead.\n*/",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_StakeDAO_StakeDAO-Frax-veSDT_audit_220427.pdf"
    }
  },
  {
    "title": "6.9 Use Safe Calls",
    "severity": "minor",
    "body": "Correctness Low Version 1 Code Corrected\n\nAutomationExecutor exposes swap and withdraw functions. These functions, interact with ERC\ncontracts by calling ERC20.approve and ERC20.transfer. However, these calls will fail, should a\nuser try to interact with a USDT contract. For example, a user sends accidentally USDT to the\nAutomationExecutor, the amount will remain stuck there since any withdrawal by the owner will fail.\n\nCode corrected:\n\nSafeERC20 library is now used. ERC20.approve has been replaced with\nSafeERC20.safeIncreaseAllowance and ERC20.transfer has been replaced with\nSafeERC20.safeTransfer.",
    "dataSource": {
      "name": "ChainSecurity/20220330-ChainSecurity_Oazo_Apps_Limited_Automation_Audit_Report.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/20220330-ChainSecurity_Oazo_Apps_Limited_Automation_Audit_Report.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/20220330-ChainSecurity_Oazo_Apps_Limited_Automation_Audit_Report.pdf"
    }
  },
  {
    "title": "5.1 Inefficient Transfer Hook",
    "severity": "minor",
    "body": "Design Low Version 1 Risk Accepted\n\nThe internal function ERC20Farmable.beforeTokenTransfer is called before any transfer logic is\nexecuted. Assuming that user A is farming on n and user B is farming on m farms without any overlap in\nthe sets, then,\n\n- m+n addresses are loaded from storage at the very beginning,\n- m+n external calls are made,\n- m+n storage writes to corrections,\n- and more reads and writes.\n\nFurthermore, m and n are not limited. A token transfer could end up being very expensive without the\nuser noticing. Hence, token transfers could easily fail by running out of gas.\n\nRisk accepted:\n\n1inch accepts the risk.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "5.3 Lack of Events",
    "severity": "minor",
    "body": "Design Low Version 1 Code Partially Corrected\n\nTypically, events help track the state of the smart contract. Some functions, such as startFarming,\nemit events while others do not emit any event. Some examples lacking event emissions are:\n\n- ERC20Farmable.farm()\n- ERC20Farmable.claim() and FarmingPool.claim()\n- ERC20Farmable.exit()\n- Public checkpointing functions\n- BaseFarm.setDistributor()\n\nCode partially corrected:\n\nAn event has been added only for setDistributor().\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- Gas Griefing Code Corrected\n\n```\nMedium-Severity Findings 0\n```\n```\nLow-Severity Findings 7\n```\n- Commented Code Code Corrected\n- Farms Rely on Token to Checkpoint Code Corrected\n- Gas Inefficiencies Code Corrected\n- Ineffective period Check Code Corrected\n- Introduction of Batched Operations Code Corrected\n- Usage as a Library Code Corrected\n- farmingCheckpoint() Has No Functionality Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.1 Gas Griefing",
    "severity": "major",
    "body": "Security High Version 1 Code Corrected\n\nERC20Farmable calls farm contracts in every call to farmedPerToken() to query information with\nIFarm.farmedSinceCheckpointScaled() on how many rewards have been released so far. Even\nthough that call is handled with a try/catch block to prevent the target contract from reverting\nmaliciously, it is still possible that the farm consumes all gas.\n\n```\n1.A malicious farm honeypots users into joining.\n2.The malicious farm contract is upgraded through an upgradeability pattern.\n```\n```\n3.Every call to farmedSinceCheckpointScaled() consumes all gas.\n```\nNow, following is not possible:\n\n- any ERC20Farmable transfer from an affected user\n- any ERC20Farmable transfer to an affected user\n- exiting the malicious farm\n- Claiming from the malicious farm\n\nUltimately, tokens will be locked for affected users.\n\nCode corrected:\n\n\nThe call to IFarm.famedSinceCheckpointScaled() now has a gas limit. If the gas limit of 200000 is\nexceeded, the failure is handled by behaving equivalently to a revert in the farm contract.\n\nAdditionally, the static-call was wrapped inside an assembly block to prevent the return data bomb issue\nin the Solidity compiler (documented here: https://github.com/ethereum/solidity/issues/12306).",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.2 Commented Code",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nERC20Farmable._getFarmedSinceCheckpointscaled contains commented code. Removing the\ncode could help keep the code cleaner such that it is easier to understand.\n\nCode corrected:\n\nCommented out code has been replaced by calls to on onError().",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.3 Farms Rely on Token to Checkpoint",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nFarm._updateFarmingState() calls checkpoint() of an external ERC20Farmable contract. Then,\nthe ERC20Farmable contract calls Farm.farmingCheckpoint(). However, a malicious\nERC20Farmable implementation could purposefully leave out the call to\nFarm.farmingCheckpoint(). Hence, the farm checkpoints could remain without updates.\n\nCode corrected:\n\nfarmingCheckpoint has been removed from the farm contracts. Hence, there is no need to call it.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.6 Introduction of Batched Operations",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nAssume a user participates in 10 farms for a farmable token. To claim all rewards the user needs to call\nclaim() multiple times. Gas consumption could be reduced by allowing batched operations for\nERC20Farmable.\n\nCode corrected:\n\nFollowing batched operations have been introduced:\n\n- claimAll: claims on all farms\n- quitAll: quits all farms",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.7 Usage as a Library",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nERC20Farmable is intended to be used as a library for farmable ERC-20 tokens. As such, some\nfunctions may require to be overridden so their functionality can be enhanced. However, no function in\nthe supplied codebase has a virtual modifier, and so child contracts cannot override any method,\nmeaning code that inherits from ERC20Farmable cannot extend its core functionality.\n\nOn the other hand, for some functions it could make sense to disallow overriding. An example could be\nfarmedPerToken() which specifies the distribution among token holders. Allowing developers to\nmodify its behaviour could lead to subtle issues that may not be caught during testing.\n\nAssuming there is a use-case of changing the semantics of computing the farmed amount, code would\nrequire changes in several functions. First, farmed() would require changes. Second, claim() would\nrequire changes as it calls UserAccounting.farmed() instead of farmed. Hence, wrapping\nfunctionality from libraries in the abstract ERC20Farmable and using the wrapper functions internally\ncould ease the overriding process and prevent errors.\n\n\nFurthermore, it could be that some functions should not be callable by any child contracts, and there are\ncertain state variables that should not be set in child contracts. For example, farmTotalSupply is a\npublic variable, querying that value is helpful for users interacting with the contract. However,\ndevelopers could unknowingly interleave writes to that variable in between updates to it in the internal\ncallflow which would lead to inconsistent state. In that case, it could be helpful to have a public getter\nwhile restricting writes in child contracts.\n\nTo summarize, 1inch provides a library for staking. Since documentation is also part of writing an\napplication library, it would be helpful to explicitly document the overridability and the visibility of functions\nand variables, as well as their intended use.\n\nCode corrected:\n\nThe code has been adapted and functions have been marked as virtual.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "7.1 Calls to Farms",
    "body": "Note Version 1\n\nNote that the system interacts with untrusted farms and untrusted contracts.\n\nChanges implemented or functionality in contracts inheriting from ERC20Farmable should ensure that\nthere is no possibility of re-entering the ERC20Farmable contract when interacting with untrusted\ncontracts since that could lead to possible unwanted modifications of farming state for other farms.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "7.2 farmedSinceCheckpointScaled() Decimals",
    "body": "Note Version 1\n\nNote that farms may run into issues if a Farm's farmedSinceCheckpointScaled() does not return a\nvalue that is in the base of 10**(18 + rewardToken.decimals()):\n\n- Assume the call to farmedSinceCheckpointScaled() returns a value in the base of 10**x.\n- Then, the call to farmedPerToken will return something in the base of\n    10**(x-ERC20Farmable.decimals()) which implies that corrections is in base of 10**x.\n- In farmed, the subtraction arguments will be both in base 10**x. However, the result of the division\n    will be in the base of 10**(x-18).\n\nUsing Farm of 1inch, will ensure that x==18+rewardToken.decimals(). However, if that is not the\ncase, errors could occur.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_1inch_Farming_audit_220329.pdf"
    }
  },
  {
    "title": "6.2 Rebasing aToken Balance",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nATokens are rebasing tokens. This means that the balance an account holds changes in time and, thus,\nbetween the time a transaction is submitted and mined. In the current implementation, there is no way to\nremove the full amount of the collateral by querying the balance the external position holds during the\nexecution of the transaction. This could result in dust remaining in the external position.\n\n\nCode corrected:\n\nBy specifying the maximum integer as the amount, the full aToken balance will be withdrawn:\n\n```\nuint256 collateralBalance = ERC20(aTokens[i]).balanceOf(address(this));\n```\n```\nif (amounts[i] == type(uint256).max) {\namounts[i] = collateralBalance;\n}\n```\n```\n// If the full collateral of an asset is removed, it can be removed from collateral assets\nif (amounts[i] == collateralBalance) {\ncollateralAssets.removeStorageItem(aTokens[i]);\nemit CollateralAssetRemoved(aTokens[i]);\n}\n```",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Extensions-III-Smart-Contract-Audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Extensions-III-Smart-Contract-Audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/01/Enzyme-Extensions-III-Smart-Contract-Audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "3.100 reward tokens are harvested. The total and the user integral are updated accordingly. The",
    "body": "amount to transfer to the attacking contract is 50 reward tokens. However, the claimable amount is\nset to 0 in storage due to the transfer. Note, that lastCheckpointBalance is not updated.\n4.The transfer starts and modifies the balance to 50 and then calls the attacking contracts\nhook.\n```\n```\n1.The attacking contract reenters the wrapper contract in the reentereable transfer()\nfunction inherited from ERC20.\n2.___checkpoint is called. Harvesting Convex has no effect but now\n__updateHarvest is called.\n```\n```\n3.The last checkpointed balance (still 0) and the current balance (now 50) are queried. The\ndifference implies more rewards.\n4.Now, the integrals are updated and so is the claimable amount is now set to 25 for the\nattacking contract. The checkpointed balance is now set to 150.\n```\n```\n5.The execution returns and nothing happens since the checkpointed balance is equal to the\nbalance. No event is emitted.\n6.The attacking contract claims his claimable amount. Totally, the attacking contract has claimed 75\ninstead of 50 reward tokens.\n```\nUltimately, accounting issues occur since there are less rewards available than expected. Also, some\nuser will potentially not be able to withdraw their LP tokens due to impossible transfers.\n\n\nEven though we specify reward tokens to be regular ERC-20 tokens, it could be possible that, since the\nfuture is unforeseeable, ERC-777 tokens could be added as rewards, which would open up such attack\nvectors. Hence, the underlying issue is that the Checks-Effect-Interaction design pattern is not followed.\n\nCode corrected:\n\nThe nonReentrant modifier was added to _transfer. Hence, all entrypoints that perform\ncheckpointing are protected from reentrancy. Additionally, all checkpointing variables were made\nprivate. Hence, more derived contracts are protected from reentrancy attack vectors modifying\ncheckpointing state.",
    "dataSource": {
      "name": "ChainSecurity/Enzyme-Sulu-Extensions-II-Smart-Contract-Audit-by-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/03/Enzyme-Sulu-Extensions-II-Smart-Contract-Audit-by-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/03/Enzyme-Sulu-Extensions-II-Smart-Contract-Audit-by-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.3 Governance Differences",
    "severity": "minor",
    "body": "Design Low Version 1 Acknowledged\n\nThe Angle distributor and the liquidity gauge both support only one governor. That diverges from the\nother contracts' capability of having multiple governors. That change of the governance system in the\nnew module is undocumented.\n\nAcknowledged:\n\nAngle replied:\n\n```\nThese differences are due to the change of paradigm of governance where we will\nuse snapshot voting implemented by a multisig instead of true on-chain governance.\nNote that technically, the `AngleDistributor` could support multiple governors.\n```\n```\nAnother reason is that most Curve contracts we have forked support only one governor.\nThe `LiquidityGauge` forked from Curve had only one governor, we therefore decided to\nkeep it. The same will go for the other contracts of the protocol.\n```\n```\nMost contracts of the protocol were coded to support multiple governors. One will\nhowever be used in practice however.\n```\n\nNote that also only one governor is supported in the surplus contracts (following the same reasoning).\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 1\n```\n- Ineffective Protection Against Sandwich Attacks, Missing Slippage Protection Code Corrected\n\n```\nMedium-Severity Findings 4\n```\n- Potentially Stuck Funds After Collateral Removal Code Corrected\n- Race Condition on Loss Code Corrected\n- Reverting on setGaugeKilled() Code Corrected\n- recoverERC20 Does Not Account for the New interestsAccumulated Code Corrected\n\n```\nLow-Severity Findings 9\n```\n- (Missing) Checks on Path Code Corrected\n- Commented Code Code Corrected\n- Confusing Naming Code Corrected\n- Documentation Mismatches Specification Changed\n- Gas Optimizations Code Corrected\n- Guardian Powers Code Corrected\n- Outdated Compiler Version Code Corrected\n- burn in Surplus Converters Not Paused Code Corrected\n- is_killed Remains Unused Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf"
    }
  },
  {
    "title": "7.2 Potentially Stuck Funds After Collateral",
    "body": "Removal\n\nDesign Medium Version 1 Code Corrected\n\nTokens of the underlying may be stuck in the SurplusConverterSanTokens contract should a collateral be\nremoved from the StableMaster contract. buyback() will no longer work after the collateral has been\ndeactivated in the StableMaster and it's no longer possible to exit the underlying held by the\nSurplusConverterSanToken contract. Should a collateral be removed, it's important to shut down the\ncorresponding SurplusConverterSanTokens contract first.\n\nCode corrected:\n\nA function recoverERC20, callable only by a governor, has been implemented in the parent contract\nBaseSurplusConverter to enable withdrawing funds from all the converters.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf"
    }
  },
  {
    "title": "7.5 recoverERC20 Does Not Account for the New",
    "severity": "info",
    "body": "interestsAccumulated\n\nCorrectness Medium Version 1 Code Corrected\n\nFunction recoverERC20 of the PoolManager allows the Governor to recover ERC20 tokens held by this\ncontract. Any amount of arbitrary ERR20 tokens held by the contract can be exited, however for the\ntoken of the pool there are some restrictions in order to prevent the Governor to pull funds belonging to\nthe protocol. Due to onchain constraints there are some limitations however and this can only be seen as\nsanity check. The HA claims are not included as it's not feasible to calculate this amount.\n\nThe new functionality introduces interestsAccumulated which contains the amount of tokens\nreserved as surplus and which can be exited using the pullSurplus() function, however the check in\nrecoverERC20() has not been updated to account for them.\n\nCode corrected:\n\ninterestsAccumulated is now considered in the computations of recoverERC20().\n\n7.6 (Missing) Checks on Path\n\nDesign Low Version 1 Code Corrected\n\nFunction addToken of the SurplusConverterUniV2Sushi contract which can only be called by the trusted\nGuardian role checks the given path:\n\n```\nrequire(pathLength >= 2 && path[pathLength - 1]\n== address(rewardToken) && path[0] == token, \"111\");\n```\nThe corresponding function of the SurplusConverterUniV3 contract doesn't do any check on the path.\n\n\nCode corrected:\n\nSurplusConverterUniV3 now also implements sanity checks for the path.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf"
    }
  },
  {
    "title": "7.7 Commented Code",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nIn the surplus converter for UniswapV2 / Sushiswap, the buyback function has the following commented\ncode:\n\n```\n// uint256 amount = IERC20(token).balanceOf(address(this));\n```\nFor clarity this code could be removed.\n\nHowever, the balance could be used to create a sanity check for a successful swap. Both, the\nUniswapV2/Sushiswap and the UniswapV3 SurplusConverter contracts do not revert early if the\ncontract's balance is smaller than the specified buyback amount.\n\nCode corrected:\n\nThe commented code has been removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_Angle_Staking_and_Surplus_audit.pdf"
    }
  },
  {
    "title": "6.1 Incorrect Arguments in",
    "body": "checkCollateralChange\n\nCorrectness High Version 2 Code Corrected\n\n\nIn YearnV2.withdraw(uint256, address, uint256), the checkCollateralChange is called\nwith wrong arguments. Particularly, the following snippet is used:\n\n```\ncreditFilter.checkCollateralChange(\ncreditAccount,\ntoken,\nyVault,\nbalanceInBefore.sub(IERC20(yVault).balanceOf(creditAccount)),\nbalanceOutBefore.add(IERC20(token).balanceOf(creditAccount))\n);\n```\nNote that token is the tokenOut in this particular case, we convert yVault tokens to the underlyings\nand yVault is the tokenIn. This error later results in querying the oracles with wrong balances.\n\nCode Corrected:\n\nThe arguments are now passed correctly to checkCollateralChange.\n\n*While the final round of the review was ongoing Gearbox Protocol informed us of an issue in the new\nimplementations of the adapters. The adapters were calculating the delta of the incorrectly and hence\nwere passing wrong parameters to `checkCollateralChange`. The issue has been fixed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf"
    }
  },
  {
    "title": "6.4 DoS of LeverageActions",
    "severity": "medium",
    "body": "Design Medium Version 4 Code Corrected\n\nLeveragedActions can be blocked completely or for specific collaterals only in different ways:\n\n```\n1.When opening an account the credit manager will check if onBehalfOf already has an\naccount. In case a malicious user has already transferred the ownership of a credit account to\nthe LeverageActions contract then the CreditManager will fail to open a new one:\n```\n```\nfunction openCreditAccount(\n...\nrequire(\n!hasOpenedCreditAccount(onBehalfOf) && onBehalfOf != address(0),\nErrors.CM_ZERO_ADDRESS_OR_USER_HAVE_ALREADY_OPEN_CREDIT_ACCOUNT\n); // T:[CM-3]\n...\n```\n```\n2.Although this is more a theoretical attack, assume a credit manager which prohibits the user to\ninvest more that A amount of tokens. A malicious user sends to the the contract A + 1 tokens.\nWhen the contract will try to open a leveraged position it will do so using the total balance of the\ntoken it holds. If this amount is greater than the allowed one the account opening will block.\nThe snippets which dictate the above behavior are the following:\n```\n```\nLeverageActions:\n```\n```\nfunction _openLong(LongParameters calldata longParams, uint256 referralCode){\n```\n\n```\n...\nuint256 amount = IERC20(collateral).balanceOf(address(this)); // M:[LA-1]\n...\n}\n```\n```\nCreditManager:\n```\n```\nfunction openCreditAccount(\n...\nrequire(\namount >= minAmount &&\namount <= maxAmount &&\nleverageFactor > 0 &&\nleverageFactor <= maxLeverageFactor,\nErrors.CM_INCORRECT_PARAMS\n); // T:[CM-2]\n...\n}\n```\nCode corrected:\n\nFor the case #1, an allowance system was implemented for the transfer of credit account. In order to get\na credit account transferred, the receiver needs to pre-approve the sender of the credit account. Hence\none can no longer transfer a credit account to the LeveragedAction contract and the issue no longer\nexists.\n\nTo mitigate case #2 the LeveragedActions contract now uses the actual balance difference.\n\n*Moreover, Gearbox Protocol pointed out a third way to use the attack described above. Specifically, a\nuser can open an account on behalf of the LeverageAccount contract which would result in a\nDenial-of-Service for the LeverageAction contract. The issue has been resolved by also restricting the\naddress on behalf of which the credit account is opened.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf"
    }
  },
  {
    "title": "6.13 Use of transfer",
    "severity": "minor",
    "body": "Design Low Version 4 Code Corrected\n\n_returnTokenOrUnwrapWETH uses transfer instead of safeTransfer for transferring tokens. This\ncall will fail for tokens which do not adhere to the ERC20 interface e.g., USDT.\n\nCode corrected:\n\nThe code was changed to use safeTransfer.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf"
    }
  },
  {
    "title": "6.17 Redundant Multiplication",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nIn PoolService.removeLiquidity a part of the amount requested by the user is sent back to them\ndetermined by withdrawMultiplier and an amount determined by the withdrawFee is sent to the\ntreasury. By construction we know that\nwithdrawMultiplier + withdrawFee == PERCENTAGE_FACTOR. These two amounts should add\nup to underlyingTokensAmount. Hence, there is no need to perform two safe multiplications with both\nwithdrawFee and withdrawMultiplier and the following multiplication is redundant:\n\n\n```\nIERC20(underlyingToken).safeTransfer(\n...\nunderlyingTokensAmount.percentMul(withdrawFee)\n); // T:[PS-3, 34]\n```\nCode Corrected:\n\nThe issue has been resolved. In the current implementation, only one multiplication takes place. The\namount sent to the treasury is now calculated by subtracting amountSent from\nunderlyingTokensAmount.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Gearbox_Protocol_Gearbox_audit_Dec-13th-2021.pdf"
    }
  },
  {
    "title": "6.8 Function Pool.burnRTokens Potential",
    "body": "Reentrancy\n\nDesign Low Version 1 Code Corrected\n\nCertain ERC20 tokens perform callback on token transfers. For example, ERC777. Performing _burn\nafter transfers is then can be recognized as a reentrancy pattern. While the burnRTokens and other\nPool contract functions have reentrancy lock protection, there is possibility, that external contracts called\nduring the transfer callback, might misinterpret the State of the Pool contract. For example, the\nreinvestL / totalSupply ratio will be off during this callback.\n\n```\nif (tokenQty > 0) token0.safeTransfer(msg.sender, tokenQty);\ntokenQty = QtyDeltaMath.getQty1FromBurnRTokens(sqrtP, deltaL);\nif (tokenQty > 0) token1.safeTransfer(msg.sender, tokenQty);\n```\n```\n_burn(msg.sender, _qty);\n```\nCode corrected:\n\nThe transfers have been moved to the very end of the function.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Kyber_Network_KyberSwap_Elastic_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/06/ChainSecurity_Kyber_Network_KyberSwap_Elastic_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/06/ChainSecurity_Kyber_Network_KyberSwap_Elastic_audit.pdf"
    }
  },
  {
    "title": "7.1 Compatibility With Different Tokens",
    "body": "Note Version 1\n\nIn the future, new tokens might be added. When markets for those are created, issues can appear. In this\nnon-exhaustive list, we highlight some of those issues:\n\n- On-demand Balance Modification + Callback:\n\n```\nDifferent token types (inflationary, deflationary, or rebasing) can have balances which change\nwithout a Transfer occurring. For some of these tokens there is a permissionless trigger to update\neveryone's balances. Tokens with such a permissionless trigger and a callback on transfer should\nnot be added for the following reason. While receiving the callback of mint() the depositor could\ntrigger the balance adjustment and thereby increase the ERC20 balance of the market without\nmaking a deposit.\n```\n- Blacklist, Freezable, Seizable:\n    Tokens where some addresses can be blacklisted, certain funds can be frozen or some funds can\n    be seized/burnt, need to be added with great consideration. A blacklisted market would stop working\n    properly. A (partially) frozen market would not function correctly (as the underlying fungibility\n    assumption is violated). Finally, seizing could lead to sudden drops in the exchange rate.\n- Transfer Fees:\n    In principle the protocol supports tokens with transfer fees. However, if a user borrows a certain\n    amount of tokens with transfer fees, it will be almost impossible to completely repay that borrow.\n    This is because the existing feature of providing -1 as the amount wouldn't work due to the transfer\n    fees. Hence, a small borrow residue will most likely remain.\n    When borrowing tokens with transfer fees, the requested amount will not be received. Similarly,\n    when reducing the reserve of a token with transfer fees, there will be unexpected losses.\n- Tokens with potential for sudden increase in value:\n    If a token whose value can suddenly increase by a significant amount, can be borrowed, then\n    attacks due to extremely bad positions are possible. Such tokens include UniswapV2 and Curve\n    pool tokens, but also DPI tokens. Extreme care has to be taken, when adding such tokens to the\n    protocol as they will most likely lead to an attack.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Compound_cToken_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Compound_cToken_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/12/ChainSecurity_Compound_cToken_audit.pdf"
    }
  },
  {
    "title": "7.7 System Compatibility With External Tokens",
    "body": "Note Version 1\n\nWhile systems contracts operate properly with good behaving ERC20 tokens, some odd tokens can\ncause potential problems in the system. For example, the BorrowingCore getting collateral with\ncollateral.transferFrom(msg.sender, address(this), _amount) and _amount is\nretained for accounting. This behavior does not tolerate tokens with fees. If a collateral is a token that\nallows fees upon transfer, the real amount received by the BorrowingCore will be less than _amount and\nthe system could end up undercollateralized without noticing it. Similarly, the rounding errors in QVault\ntransfers can lead to smaller received values on the BorrowingCore side. Thus, QVault cannot be used\nas a collateral inside BorrowingCore without code adjustments. In addition, on Ethereum some tokens\ndon't always return values on transfer/transferFrom or approvals. Some tokens have unusual number of\ndecimals (too big or too small). Allowing the system to manipulate any external token should be done\nwith a great care.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Q_Blockchain_System_contracts_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/11/ChainSecurity_Q_Blockchain_System_contracts_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/11/ChainSecurity_Q_Blockchain_System_contracts_audit.pdf"
    }
  },
  {
    "title": "6.1 Incorrect Balance Check for Vault",
    "severity": "medium",
    "body": "Correctness Medium Version 1 Code Corrected\n\nChecking whether the MultiplyProxyActions contract holds enough funds has been modified to:\n\n```\nrequire(\ncdpData.requiredDebt.add(cdpData.depositDai) >= IERC20(DAI).balanceOf(address(this)),\n\"requested and received amounts mismatch\"\n);\n```\nThe check should ensure that the MultiplyProxyActions contract holds enough Dai for the operation on\nthe vault. Thus, if less DAI than needed is available the code should revert while a surplus of DAI could\nbe tolerated. However, the change proceeds with the execution if the balance is lower than the amount\nneeded while it reverts if there is a surplus of DAI.\n\nCode corrected:\n\nThe condition has been changed to <=.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_FMM_extension_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Oazo_Apps_Limited_Multiply_FMM_extension_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Oazo_Apps_Limited_Multiply_FMM_extension_audit.pdf"
    }
  },
  {
    "title": "6.1 redeemSharesForSpecificAssets Fails For",
    "body": "Derivatives\n\nCorrectness Medium Version 1 Code Corrected\n\nIn Sulu, users are allowed to redeem specific assets. According to the documentation:\n\n```\nThe redeemer specifies one or multiple of the VaultProxy's ERC20 holdings along with the relative\nvalues of each to receive (for a total of 100%).\n```\nHowever, if an ERC20 token which represents a derivative is specified as a payout asset then the\nredemption will fail. The call in __payoutSpecifiedAssetPercentages fails for non primitive assets\ndue to the require statement shown below in the calcCanonicalAssetValue of the\nvalueInterpreter:\n\n```\npayoutAmounts_[i] = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\ndenominationAssetCopy,\n_owedGav.mul(_payoutAssetPercentages[i]).div(ONE_HUNDRED_PERCENT),\n_payoutAssets[i]\n);\n```\n```\nfunction calcCanonicalAssetValue(\n...\n```\n```\nrequire(\nisSupportedPrimitiveAsset(_quoteAsset),\n\"calcCanonicalAssetValue: Unsupported _quoteAsset\"\n);\n```\n```\n...\n```\nNote that simply removing the requirement is not enough since the ValueInterpreter can only handle\nconversions to primitive assets due to the implicit requirement that the quote asset has a Chainlink price\nfeed.\n\n\nCode Corrected:\n\nValueInterpreter.calcCanonicalAssetValue now supports the conversion from a primative\nasset to a derivative asset. This is done by calculating the price of the derivative asset against the\nprimative one and the inverting.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Avantgarde_Finance_Enzyme_Protocol_v4_Sulu_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Enzyme_Protocol_v4_Sulu_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Avantgarde_Finance_Enzyme_Protocol_v4_Sulu_audit.pdf"
    }
  },
  {
    "title": "6.22 Return Value in safeTransfer",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe function safeTransfer() in the library Transfers checks if an ERC20 token transfer completed\nsuccessfully, otherwise the function reverts. Currently, the function returns a boolean value but it is never\nchecked in the caller functions.\n\nCode corrected\n\nThe return value in safeTransfer() has been removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf"
    }
  },
  {
    "title": "7.2 Limited Supported Token Pairs",
    "body": "Note Version 1\n\nPrimitiveFactory contract deploys a unique PrimitiveEngine contract for a pair of ERC20 tokens. The\nfunction deploy() takes as arguments the addresses of the two ERC20 tokens and assumes that\nthey are implemented correctly and behave as expected. The function deploy checks only if the\nprovided addresses of the risky token and the stable one are not the same and that they are different\nfrom address(0).\n\nTechnically, it is possible to deploy a PrimitiveEngine with any arbitrary pair of tokens, such as:\ncompromised/malicious tokens, two risky tokens, two stable tokens, or with switched addresses for the\nrisky and stable tokens. Therefore, the filtering of the bad or malicious engines and their respective pools\nshould happen on the application level (outside the audited smart contracts) in order to protect users\nfrom interacting with incorrect engines.\n\nWe explicitly mention that the contract ONLY works with standard ERC20 tokens that do not have any\nunusual behavior like inflation, deflation, locking, fees, two addresses etc. Users needs to carefully\nevaluate if the pool's token fulfill the requirements!\n\nA check in the factory before deploying the engine might at least prevent accidentally adding a token with\nunsupported decimals.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Primitive-Finance-Core-Engine_Smart-Contract-Audit_October-11th-2021.pdf"
    }
  },
  {
    "title": "7.1 Burning AgTokens in BondingCurve Does Not",
    "body": "Update stocksUsers\n\nCorrectness High Version 2 Code Corrected\n\nThe BondingCurve contract allows users to buy tokens (most likely Angle tokens). To receive tokens from\nthe BondingCurve, AgTokens get burned according to the bonding curve price. This may significantly\nreduce the amount of AgTokens minted and improve the protocol health. However, no stocksUsers\nvariable is updated. Several issues may arise regarding such accounting issues. For example, the\ncoverage ratio of the protocol may be much higher than the one indicated and the system create bad\ndebt through that mismatch.\n\nNote that regular burn operations also do not update the stocksUsers variable.\n\nCode corrected:\n\nWhen buying tokens the AgTokens are transferred to the bonding curve contract and not burned.\nGovernance can make use of functions BondingCurve.recoverERC20 and\n\n\nAgToken.burnNoRedeem which calls StableMaster.updateStocksUsers to transfer AgTokens to\nitself and burn them while updating the stocks users for a specified pool manager.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf"
    }
  },
  {
    "title": "7.16 Non 18 Decimals Protocol Tokens",
    "severity": "medium",
    "body": "Correctness Medium Version 1 Specification Changed\n\nThe documentation states:\n\n```\nDecimals\n```\n```\nTo be consistent with the BASE chosen when computing numbers, it has been decided that all\nthe ERC20 tokens created by the Angle protocol would involve 18 decimals.\n```\n```\nAlthough this is not specified anywhere in the code, this means that the base for agTokens\nand sanTokens is 18.\n```\nThe decimal of the sanToken however is set equal to the decimal of the underlying collateral. For\ncollaterals with decimals different than 18, the sanTokens decimal will not be equal to 18.\n\n```\nfunction initialize(\nstring memory name_,\nstring memory symbol_,\naddress poolManager\n) public initializer {\n__ERC20Permit_init(name_);\n__ERC20_init(name_, symbol_);\nstableMaster = IPoolManager(poolManager).stableMaster();\ndecimal = IERC20MetadataUpgradeable(IPoolManager(poolManager).token()).decimals();\n}\n```\n\nSpecification changed:\n\nThe developer documentation will be changed to accurately reflect this.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf"
    }
  },
  {
    "title": "7.36 Inconsistencies Between Staking Contract",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThere are two types of staking contracts. The StakingRewards and the perpetual managers. They have\nsimilar functionality and their staking mechanism should be similar. However, inconsistencies in their\nimplementations can be found.\n\nSome of the inconsistencies are:\n\n- Difference in setNewRewardsDistributor(): The perpetual manager checks whether a new\n    reward distributor contract has the same reward token as itself. StakingRewards does not do that.\n- Difference in emitting events: In the above function the two contracts emit different events.\n- Recovered event is not emitted in recoverERC20() in PerpetualManager but in StakingRewards.\n\nCode corrected:\n\nThe same events are now emitted and the RewardsDistributor, the only contract allowed to call the\nstaking contracts' setNewRewardsDistributor(), checks whether the new rewards distributor has\nthe same reward token as itself.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Angle_Angle_Protocol_Smart-Contract-Audit.pdf"
    }
  },
  {
    "title": "6.8 Double Getters",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nFor each public variable, a getter is automatically generated. However, several contracts implement\nadditional getter functions for public variables which leads to more code and, hence, higher deployment\ncost.\n\nSome examples of double getters are:\n\n- partnerRevenueShare and getPartnerPermit in PermittedPartners.sol\n- nftPermits and getNFTPermit in PermittedNFTs.sol\n- erc20Permits and getERC20Permit in PermittedNFTs.sol\n\nSimilar examples can be also found in other contracts such as DirectLoanCoordinator, NftfiHub and\nothers. Removing double getters may reduce deployment cost.\n\nCode corrected:\n\nThe double getters have been removed by setting the public variables to private.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_NFTfi_NFTfi_Marketplace_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_NFTfi_NFTfi_Marketplace_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/01/ChainSecurity_NFTfi_NFTfi_Marketplace_audit.pdf"
    }
  },
  {
    "title": "7.4 Supported Tokens",
    "body": "Note Version 1\n\nThere is are variety of different token implementations on the Ethereum blockchain. Using tokens with\nunusual behavior will lead to unexpected changes of the curve or put the smart contracts into a bad state.\nIn particular, the following token types will not work:\n\n- rebasing tokens, where balances can change without transfers. These tokens will lead to incorrect\n    accounting.\n- tokens with transfer fees. These tokens will lead to incorrect accounting.\n- tokens with incorrect ERC20 implementations.\n- tokens with more than 18 decimals\n- tokens with more than one address",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Curve-Finance-_-Tricrypto_smart-contract-audit_-September-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Curve-Finance-_-Tricrypto_smart-contract-audit_-September-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Curve-Finance-_-Tricrypto_smart-contract-audit_-September-2021.pdf"
    }
  },
  {
    "title": "6.4 Redundant Imports",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe SafeERC20.sol library is imported twice in line 10 and 11.\n\nCode corrected\n\nThe redundant import is removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf"
    }
  },
  {
    "title": "6.5 Token Transfers Inconsistent",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nThe HoprChannels contract has inconsistent use of SafeERC20 functions. Since the token is known\nHoprToken contract that cannot be changed after the deployment, the use of SafeERC20 functions is\nredundant and introduces the unnecessary gas expenses.\n\n```\ntoken.transfer(msg.sender, channel.balance);\ntoken.safeTransfer(msg.sender, amount);\ntoken.safeTransferFrom(msg.sender, address(this), amount1 + amount2);\n```\nCode corrected\n\ntransfer is now used consistently.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_HOPRNet_Payment_Channel_audit.pdf"
    }
  },
  {
    "title": "6.1 Reentrancies",
    "severity": "medium",
    "body": "Security Medium Version 1 Code Corrected\n\n```\n1.During the execution of remove_liquidity and remove_liquidity_imbalance multiple asset\ntransfers are made. One of these assets is ETH, while the others are ERC-20 tokens. The transfer\nof ETH can lead to the following reentrancy. Through the transfer of ETH, the execution might\nreenter the contract and call donate_admin_fees. Note that this requires owner privileges. Inside\ndonate_admin_fees, the internal balances mapping for the ERC-20 tokens will be updated as\nfollows:\n```\n```\nself.balances[i] = ERC20(coin).balanceOf(self)\n```\n```\nThis assignment is incorrect in this context as the contract still holds the tokens that are about to be\ntransferred due to the removed liquidity. Hence, after the transaction is complete:\nself.balances[i] > ERC20(coin).balanceOf(self). This breaks an important invariant in\nthe contract.\n2.During the call to withdraw_admin_fees an ETH transfer takes place. The transfer of ETH can\nlead to the following reentrancy. Through the transfer of ETH, the execution might reenter the\ncontract and call donate_admin_fees. Note that this requires owner privileges, but these were\nalready needed for withdraw_admin_fees. As a result, the admin fees for some of the coins will\nbe donated while the admin fees for other coins will be withdrawn, leading to a state that is only\nreachable through a reentrancy.\n3.Certain admin functions have no reentrancy protection. Hence, they can be called in a reentrancy\nfrom any of the functions that transfers ETH. However, for those reentrancies the only effects are\nincorrectly ordered events. As an example, a NewFee event could be emitted in between multiple\nevents belonging to a remove_liquidity call.\n```\nCode corrected: Additional Reentrancy Guards were added. These now also cover the functions\ndonate_admin_fees and apply_new_fee among others.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Curve_Finance_Curve_ETH_sETH_Smart-contract-audit_September-27th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Curve_Finance_Curve_ETH_sETH_Smart-contract-audit_September-27th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Curve_Finance_Curve_ETH_sETH_Smart-contract-audit_September-27th-2021.pdf"
    }
  },
  {
    "title": "6.1 IERC20 Incompatible With Tether",
    "severity": "medium",
    "body": "Design Medium Version 1 Risk Accepted\n\nUSDT, one of the collaterals, is not fully ERC20 compliant, notably some features lack the mandatory\nreturn value to comply with the standard.\n\nIn MultiplyProxyActions the interface IERC20 is used to interact with the token contracts. In the\ninterface definition a return value is expected for e.g., the approve and the transfer functions. Hence\nthe Solidity compiler generates bytecode that expects a return value and reverts if there is none.\n\nRisk accepted:\n\nOazo Apps Limited replied:\n\n\n```\nCurrently, Tether is not used as collateral in Maker Protocol.\nIn case Tether is onboarded to Maker Protocol,\nthe multiply feature will be disabled for it.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "6.7 Event Issues",
    "severity": "minor",
    "body": "Design Low Version 1 Code Partially Corrected Acknowledged\n\nThere are several issues regarding events:\n\n```\n1.The callback function executeOperation in MultiplyProxyActions.sol contains the logic for using\nthe flash loan. It emits the event FLData, logging how much was borrowed and how much is to be\nreturned to Aave. It is emitted as follows:\n```\n```\nemit FLData(IERC20(DAI).balanceOf(address(this)),borrowedDaiAmount);\n```\n```\nWhile borrowedDaiAmount actually specifies the value that must be returned to Aave, the balance\nof the MultiplyProxyAction contract may not be the amount that was borrowed since the method\nincreaseMultipleDepositDai may also increase the balance.\n```\n```\n2.Event FLData in MultiplyProxyActions.sol indexes the amount borrowed and the amount to be\nreturned. While in general indexing events is useful, there is no direct use of indexing this event and,\nthus, the cost of emitting this event could be reduced.\n3.Event AssetSwap in Exchange.sol is unindexed. It could be helpful to index the assets associated\nwith this event.\n```\n```\n4.Event FeePaid in Exchange.sol does not log the beneficiary. This issue is related to issue\nfeeRecepient of AddressRegistry and how it is resolved. If the receiver of the fee is not fixed for the\ncontract, then logging the beneficiary could be useful since the beneficiary of the fee may change.\n```\nCode partially corrected:\n\n\n```\n1.Corrected: The event does not emit the balance anymore. Now, the difference between the balance\nand depositDai is emitted.\n2.Corrected: FLData is now unindexed.\n3.Corrected: assetIn and assetOut are indexed.\n4.Not corrected: FeePaid now logs the beneficiary. Since the feeBeneficiary is public and cannot\nbe changed, it is not necessary to log the beneficary. Gas costs could be reduced.\n```\nHowever, Oazo Apps Limited responded to that last point as follows:\n\n```\nSuch approach allows us to immediately find fee beneficiary for every future instance of exchange;\nit results in a minor gas inefficiency.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "7.4 Incorrect Decimals When Handling Collateral",
    "severity": "medium",
    "body": "Correctness Medium Version 1 Code Corrected\n\nThe functions _closeWithdrawCollateralSkipFL and _closeWithdrawCollateral receive\nmultiple inputs including the ink of the relevant urn. The ink value has previously been queried from the\nvat. The ink value is then used as follows:\n\n```\nrequire(\nIERC20(exchangeData.fromTokenAddress).approve(address(exchange), ink),\n\"MPA / Could not approve Exchange for Token\"\n);\n```\nThe ink value, however, has been adjusted to 18 decimals and hence will be incorrect here for all tokens\nthat do not have 18 decimals.\n\nNote that for the functions _closeWithdrawCollateral and _closeWithdrawDai the ink value is\nalso incorrectly passed to wipeAndFeeGem.\n\nCode corrected:\n\nThe updated implementation now passes cdpData.borrowCollateral instead of ink when calling\n_closeWithdrawCollateralSkipFL and _closeWithdrawCollateral. Inside the called function\nthis parameter is called ink. Althrough this solution technically works, it is not ideal:\n\n- Note that both functions already take the struct cdpData as parameter, so passing\n    cdpData.borrowCollateral separately is redundant.\n- The call to token.approve() remains unchanged. The exchange is approved to transfer the\n    amount ink (which now is cdpData.borrowCollateral) however the amount the exchange will\n    transfer is exchange.fromTokenAmount.\n\nRisk accepted:\n\nRefactoring / improvements are planned after the MVP.\n\n\nAn additional problem for collaterals with non 18 decimals has been uncovered in\n_closeWithdrawCollateralSkipFL() after the draft report: wipeAndFreeGem() expects the\ncollateral amount in the unit of the collateral token and converts it to the 18 decimal representation.\nHowever in _closeWithdrawCollateralSkipFL this conversion is already done before the second\ncall to wipeAndFreeGem(), hence the conversion will happen twice and result in an incorrect value for\ncollaterals with less than 18 decimals. This has been correct by removing the conversion before the call\nto wipeAndFreeGem().",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "7.11 skipFL Case in Flashloan Callback",
    "severity": "minor",
    "body": "Design Low Version 2 Code Corrected\n\nFunction executeOperation is the callback for the Aave flashloan. It is not intended to be used if\nflashloans are not utilized.\n\nThe following code snipped can be found at the end of the function:\n\n```\nif (cdpData.skipFL == false) {\nIERC20(assets[0]).approve(\naddress(getAaveLendingPool(addressRegistry.aaveLendingPoolProvider)),\nborrowedDaiAmount\n);\n}\n```\nCode corrected:\n\nThe code was removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "7.13 No Check on Amount Received From Flash",
    "severity": "minor",
    "body": "Loan\n\nCorrectness Low Version 1 Code Corrected\n\nThe documentation specifies following check on the amount received from the flash loan:\n\n```\nWe check in our smart contract whether the delivered amount matches our expected amounts. If not\nenough funds are delivered we revert the transaction with the message: “FL malfunction”.\n```\nHowever, this check is not made. Moreover, that could allow a malicious Aave to send less funds than\nrequested. Performing an increase operation with personal DAI besides the flashloan may lead to Aave\nbeing paid more if the front-end does not set parameters such that this transaction would revert. In any\ncase, there is a mismatch between documentation and implementation.\n\nA require statement has been added to check whether sufficient funds have been received:\n\n```\nrequire(\ncdpData.requiredDebt == IERC20(DAI).balanceOf(address(this)),\n\"requested and received amounts mismatch\"\n);\n```\nHowever note that this require statement now breaks increaseMultipleDepositDai() for the case\nwhen a flashloan is used: The DAI amount to deposit has already been transferred onwards to\nMultiplyActionsProxy, this amount will be included in the in the DAI balance and hence the balance\nwill not equal the flashlaon amount. The transaction will revert.\n\nCode corrected:\n\nThe check has been changed to:\n\n```\nrequire(\ncdpData.requiredDebt.add(cdpData.depositDai) <= IERC20(DAI).balanceOf(address(this)),\n\"requested and received amounts mismatch\"\n);\n```\nFor the final version of the code the strict requirement for equality has been weakened to allow for\nsurplus DAI balance at the contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "7.18 transferFrom Used Instead of transfer",
    "body": "Note Version 1 Code Corrected\n\nIn function _collectFee of Exchange.sol, IERC20(asset).transferFrom(address(this), fe\neBeneficiaryAddress, feeToTransfer) could be simplified to\n\n\nIERC20(asset).transfer(feeBeneficiaryAddress, feeToTransfer). transfer() could\nbe safer to use if, at any point in the future, Oazo decides to accept other tokens than DAI for fees, even\nthough this is currently not the case nor is it planned for the future. For example, that call would revert if\nasset was USDT which reverts if the contract has not approved itself in such a scenario.\n\nCode corrected:\n\nThe code was changed to use safeTransfer().\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. Hence, the\nmentioned topics serve to clarify or support the report, but do not require a modification inside the project.\nInstead, they should raise awareness in order to improve the overall understanding for users and\ndevelopers.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/09/ChainSecurity_Oazo_Apps_Limited_Multiply_Smart-Contract-audit_-September-7th-2021.pdf"
    }
  },
  {
    "title": "6.1 doTransfers Does Not Hanlde",
    "body": "LibFeeSide.FeeSide.NONE\n\nDesign High Version 1 Code Corrected\n\ndoTransfers performs the transfer of assets after choosing which is the feeable side. However,\ngetFeeSide can return the value LibFeeSide.FeeSide.NONE in the case none of the assets are ETH\nor ERC20 or ERC1155. This value is not handled by the function doTransfers which results to the\ntransfer not being performed.\n\nCode corrected:\n\ndoTransfers was changed to handle LibFeeSide.FeeSide.NONE.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf"
    }
  },
  {
    "title": "6.2 Function safeGetPartialAmountFloor",
    "body": "Precision Problems\n\nCorrectness Medium Version 1 Specification Changed\n\nThe function safeGetPartialAmountFloor( uint256 numerator, uint256 denominator,\nuint256 target) defined in LibMath contract effectively computes the\nnumerator * target / denominator and reverts on too much divergence from the correct value.\nDue to the different nature of tokens ( ETH, ERC20, ERC721, etc.) and different decimals on them, the\nactual values sent to this function can be of different orders. In cases when the denominator is greater\n\n\nthan the numerator * target the 0 will be returned. This can lead to situations when the orders\ncannot be matched. For example order \"Buy 30 for 600X\" cannot be matched with order \"Sell X for 10\",\nbecause the fillRight function that relies on safeGetPartialAmountFloor will return (10, 0)\nvalue that later will fail the check in matchAndTransfer function.\n\nThe safeGetPartialAmountFloor function is used in following places:\n\n- Function fillLeft in LibFill contract.\n- Function fillRight in LibFill contract.\n- Function calculateRemaining in LibOrder contract. In this case, big, close to filling values may\n    fail.\n\nSpecification corrected:\n\nNow the specification correctly communicates the behavior of the contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf"
    }
  },
  {
    "title": "7.3 Incentives for Front-Running",
    "body": "Note Version 1\n\nIn case when 2 assets that can pay fees are exchanged, the order of arguments in matchOrders\nfunction might matter. Moreover it determines the price and thus the amounts exchanged between the\ntwo parties. There might be third parties that are incentivised to front-run the transactions in order to\ndetermine the position of the orders for their own interest. The users should be aware of such events. In\naddition, once the transactions are visible in the mining pool, any other parties can try to frontrun the\nmatch, to profit from matching with lower fees or good price.\n\nIllustration of order importance:\n\nLet A and B be an ERC20 and ERC1157 token respectively. Accoring to the contract logic currently\nimplemented, the feeable token is A. Assume two orders O1:(10A, 20B) and O2:(50B,11A) Executing\nmatchOrder(O1, O2) yields fillResult(10A, 20B) (fillLeft will be called). On the other hand,\nexecuting matchOrder(O2, O1) yields fillResult(20B, 220/50A) (fillRight will be called).\nAssuming a fee of 10% then in the first case we have 0.1 * 10A and the second 0.1* 220/50 A",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf"
    }
  },
  {
    "title": "7.4 Orders Can Pay No Fees",
    "body": "Note Version 1\n\nBefore transfering the assets to the corresponding parties the fee side is chosen. The side is chosen to\nbe the one that offers ETH or ERC20 or ERC1155. If there is no such types in make and take assets of the\norder, the fees won't be deducted.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf"
    }
  },
  {
    "title": "7.5 Reentrancy Risk",
    "body": "Note Version 1\n\nIn the matchOrders can occur calls to other contacts and addresses. For example, during the native\nether transfer or during the transfer of tokens that allow user hooks e.g. ERC777 (extension of ERC20).\nWhile we haven't identified a direct way, how this can be abused. But risk of reentrancy is nullified when\na non-reentrant lock is used, for a price of small gas cost increase.\n\nIn addition, following transfers of ether will send all the gas to the callee, allowing it to execute any other\ncontract with no restrains.\n\n```\n(bool success,) = to.call{ value: value }(\"\");\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/10/ChainSecurity_Smart-contract-audit_Rarible_June-25th-2021.pdf"
    }
  },
  {
    "title": "5.5 Incompatible Tokens",
    "severity": "minor",
    "body": "Design Low Version 1 Risk Accepted\n\nThe following token types are incompatible with Omnibridge:\n\n- Rebasing tokens: If the balance of a token can change while it is stored inside the mediator contract,\n    then basic assumptions no longer hold. Hence, such tokens as Ampleforth should not be bridged as\n    the bridging might not be reversible.\n- Special transfer fees: This report already contains issues regarding \"regular transfer fees\", where\n    upon transfer of X tokens, X-F tokens are transferred, while F tokens are paid to the fee receiver. In\n    case of transfer fees, where upon transfer of X tokens, X+F tokens are subtracted from the senders\n    balance and X tokens arrive at the receiver, the Omnibridge contracts will fail as they do not account\n    for such fees.\n- Malicious tokens: Obviously, any malicious token contracts that do not follow sensible guidelines so\n    that for example, balances can be arbitrarily can freely manipulated, cannot be bridged in a\n    meaningful manner.\n\nUsers should be warned not to bridge such tokens.\n\nRisk accepted:\n\nPOA Network manually reviewed the most important tokens to ensure their compatibility and will monitor\nthe bridge and the bridged tokens. Furthermore, appropriate warnings will be added inside the UI.\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 6\n```\n- Decimals in bridgeSpecificActionsOnTokenTransfer Are Not Used Code Corrected\n- ERC20 Function Calls Ignore Return Values Code Corrected\n- No Canonical Definition of Calldata for onTokenTransfer Code Corrected\n- Safe Transfers Are Not Used for All Token Transfers Code Corrected\n- Transferred Values in Case of Relaying Tokens With Fees Code Corrected\n-\n    Code Corrected\n\n```\nOmnibridgeFeeManager Fee Distribution Reverts in Case of Tokens With Transfer Fees\n```\n```\nLow-Severity Findings 5\n```\n- Code Simplification Possible Specification Changed\n- Name Collision Among Bridged Tokens With Different Origins Code Corrected\n- Reentrancy Into AMB Code Corrected\n- Restriction to Static Call Code Corrected\n- Superfluous Loads From Storage Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf"
    }
  },
  {
    "title": "6.2 ERC20 Function Calls Ignore Return Values",
    "severity": "medium",
    "body": "Design Medium Version 1 Code Corrected\n\nThe ERC20 specification states:\n\n```\nCallers MUST handle false from returns (bool success). Callers MUST NOT assume that false is never returned!\n```\nIn some calls to the ERC20 tokens those return values are ignored:\n\n- IBurnableMintableERC677Token(_token).mint(address(manager), fee) in\n    _distributeFee function.\n- IBurnableMintableERC677Token(_token).transfer(address(manager), fee) in\n    _distributeFee function.\n- IBurnableMintableERC677Token(_bridgedToken).mint(address(this), 1) in\n    setCustomTokenAddressPair function.\n- _getMinterFor(_token).mint(_recipient, _value) in _releaseTokens function.\n\nIn most cases that happens during the calls to non-native Tokens that were deployed via the factory. But\ndue to the setCustomTokenAddressPair function the non-native contracts can have any behavior\nand the return values need to be checked explicitly.\n\nCode corrected:\n\nAll calls to transfer and mint function now check the return values.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf"
    }
  },
  {
    "title": "6.4 Safe Transfers Are Not Used for All Token",
    "body": "Transfers\n\nDesign Medium Version 1 Code Corrected\n\nFor some transfers of ERC20 Tokens the SafeERC20 functions are not used. This includes:\n\n- The function _distributeFee in OmnibridgeFeeManagerConnector contract.\n- The function distributeFee in OmnibridgeFeeManager contract.\n\nThe first case only appears for non-native tokens at the Home side of the bridge, which in most cases\nshould be ERC677 deployed by Factory. But due to the setCustomTokenAddressPair function, there\nare possible conditions when any other token can be called with this transfer.\n\nCode corrected:\n\nAll calls to the transfer function were replaced by a safe wrapper.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2021/04/ChainSecurity_POANetwork_OmniBridge_FinalReport.pdf"
    }
  },
  {
    "title": "5.1 Obsolete Storage Writes During Pool",
    "body": "Deployment\n\nDesign Medium Version 2\n\nAfter the intermediate report, the following functions have been added to DMMPool:\n\n```\nfunction name() public override view returns (string memory) {\nIERC20Metadata _token0 = IERC20Metadata(address(token0));\nIERC20Metadata _token1 = IERC20Metadata(address(token1));\nreturn string(abi.encodePacked(\"KyberDMM LP \", _token0.symbol(), \"-\", _token1.symbol()));\n}\n```\n```\nfunction symbol() public override view returns (string memory) {\nIERC20Metadata _token0 = IERC20Metadata(address(token0));\nIERC20Metadata _token1 = IERC20Metadata(address(token1));\nreturn string(abi.encodePacked(\"DMM-LP \", _token0.symbol(), \"-\", _token1.symbol()));\n}\n```\nThe pool storage still contains the old name and symbol variables which are set during execution of the\nconstructor. Due to the new functions, the new name and symbol will be returned while the storage\nvariables are now obsolete.\n\n```\nconstructor() public ERC20Permit(\"KyberDMM LP\", \"DMM-LP\", \"1\") VolumeTrendRecorder(0) {\n```\nThese unnessesary storage writes makes the deployment of new pools more expensive than necessary.\nIn particular 100,000 gas (roughly 20 USD at the time of writing) could be saved during each pool\ndeployment.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Kyber_Network_KyberSwap_Classic_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/06/ChainSecurity_Kyber_Network_KyberSwap_Classic_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/06/ChainSecurity_Kyber_Network_KyberSwap_Classic_audit.pdf"
    }
  },
  {
    "title": "6.8 Function Pool.burnRTokens Potential",
    "body": "Reentrancy\n\nDesign Low Version 1 Code Corrected\n\nCertain ERC20 tokens perform callback on token transfers. For example, ERC777. Performing _burn\nafter transfers is then can be recognized as a reentrancy pattern. While the burnRTokens and other\nPool contract functions have reentrancy lock protection, there is possibility, that external contracts called\nduring the transfer callback, might misinterpret the State of the Pool contract. For example, the\nreinvestL / totalSupply ratio will be off during this callback.\n\n```\nif (tokenQty > 0) token0.safeTransfer(msg.sender, tokenQty);\ntokenQty = QtyDeltaMath.getQty1FromBurnRTokens(sqrtP, deltaL);\nif (tokenQty > 0) token1.safeTransfer(msg.sender, tokenQty);\n```\n```\n_burn(msg.sender, _qty);\n```\nCode corrected:\n\nThe transfers have been moved to the very end of the function.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Kyber_Network_KyberSwap_Elastic_Legacy_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/05/ChainSecurity_Kyber_Network_KyberSwap_Elastic_Legacy_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/05/ChainSecurity_Kyber_Network_KyberSwap_Elastic_Legacy_audit.pdf"
    }
  },
  {
    "title": "5.1 Unchecked Return Value of transferFrom",
    "body": "```\nSecurity Low Version 1 Risk Accepted\nCS-MKPSML-\n```\nIn DssLitePsm, the return value of transferFrom() is not checked. It relies on the token to revert if the\ntransfer fails which is given for the intended gem token (USDC). Generally however, according to the\nERC20 specification upon a failed transfer the token may revert or simply returns false. In case the\ngem token's implementation returns false on a failed transferFrom() instead of reverting, DssLitePsm\nwill still treat it as a success and proceed.\n\nRisk accepted:\n\nMaker states:\n\n```\nWe do not plan to support ERC-20 tokens that do not revert on a failed transfer.\nWe might want to support tokens that do not return true on succeeded transfers.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 0\n```\n```\nLow-Severity Findings 3\n```\n- Incorrect Ilk Class Code Corrected\n- Uninitialized Vow in DssLitePsmInit Code Corrected\n- Inaccurate Specification Specification Changed",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Maker_PSM_Lite_audit-1-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Maker_PSM_Lite_audit-1-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Maker_PSM_Lite_audit-1-1.pdf"
    }
  },
  {
    "title": "6.33 Shadowed Variables",
    "body": "```\nInformational Version 1 Code Corrected\nCS-CCP-038\n```\nThe LpToken constructor's arguments name and symbol shadow the storage variables of the ERC20\ncontract.\n\nCode corrected:\n\nThe variable names have been changed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Conic_Conic_Protocol_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2024/01/ChainSecurity_Conic_Conic_Protocol_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2024/01/ChainSecurity_Conic_Conic_Protocol_audit.pdf"
    }
  },
  {
    "title": "5.1 CurrentSupply Can Be Underestimated",
    "body": "```\nDesign Low Version 1 Risk Accepted\nCS-SPRKCAP-\n```\nCapAutomator computes the new SupplyCap based on the current supply, the gap, and the max. The\ncurrent supply is estimated based on the scaled aToken total supply, the cached amount that should be\naccrued to treasury, and the last updated liquidity index.\n\n```\nuint256 currentSupply = (\nIScaledBalanceToken(reserveData.aTokenAddress).scaledTotalSupply()\n+ uint256(reserveData.accruedToTreasury)\n).rayMul(reserveData.liquidityIndex)\n/ 10 ** ERC20(reserveData.aTokenAddress).decimals();\n```\nThe liquidityIndex could be underestimated if it hasn't been updated up to now (interest has not\nbeen accrued for the period between reserveLastUpdateTimestamp and block.timestamp).\n\nIn addition, decimals have been removed for currentSupply to align with gap and cap, while this\nrounds currentSupply down.\n\nAs a result, currentSupply could be underestimated and influence the new cap computation\n(_calculateNewCap()).\n\nRisk accepted:\n\nMakerDAO states:\n\n```\nWe acknowledge and accept the fact that the current total value of the pool can\nbe assumed slightly inaccurately.\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2024/02/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2024/02/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf"
    }
  },
  {
    "title": "8.2 Token Unit, Decimals and Integer Division",
    "body": "Note Version 1\n\nIn CapAutomator, the new cap is determined by currentValue, gap and max. These value are in \"full\ntokens\", token amounts without decimals.\n\n```\nuint256 newCap = _min(currentValue + capConfig.gap, max);\n```\nThe currentValue is computed as currentSupply in _updateSupplyCap():\n\n```\nuint256 currentSupply = (\nIScaledBalanceToken(reserveData.aTokenAddress).scaledTotalSupply() +\nuint256(reserveData.accruedToTreasury)\n).rayMul(reserveData.liquidityIndex)\n/ 10 ** ERC20(reserveData.aTokenAddress).decimals();\n```\nand it is computed as currentBorrow in _updateBorrowCap():\n\n```\nuint256 currentBorrow = ERC20(reserveData.variableDebtTokenAddress).totalSupply()\n/ 10 ** ERC20(reserveData.variableDebtTokenAddress).decimals();\n```\nIn both cases currentValue is rounded down when removing the decimals.\n\nDue to this, the difference between the new cap and the actual current value could be below the gap\neven though the max has not been reached.\n\n\nIn practice, these minor rounding effects are typically negligible. Nonetheless, they can result in the\nfollowing consequences:\n\n- If gap is 0, the new cap could be set lower than the current amount. For instance, if gap is 0, cap is\n    10, and the actual current supply is 9.99. The calculation of currentSupply would result in 9 due\n    to integer division. Consequently, the update would set the cap to 9, which is less than the actual\n    current supply.\n- Users should not expect to fully utilize the gap amount (expanded to its decimal representation) after\n    triggering exec(). There may be less space due to rounding and hence this action might fail.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2024/02/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2024/02/ChainSecurity_MakerDAO_Sparklend_Cap_Automator_audit.pdf"
    }
  },
  {
    "title": "9.6 Supported Tokens",
    "body": "Note Version 1\n\n- The system only supports standard ERC20 tokens without special behaviors, especially tokens with\n    callbacks (ERC777) which would allow arbitrary code execution. More explicitly, tokens with two\n    entry points should also be avoided. It is important to stress, especially in the absence of a\n    withdrawal manager, that a reentrant token could allow read-only reentrancy attacks since the state\n    of the credit account is not properly finalized and the full collateral check hasn't been performed.\n- The LP token of the Pool should not be allowed as collateral in the system.\n- Added tokens should be reviewed regarding gas consumption. For example, the function\n    UnsafeERC20._unsafeCall allows the callee to return a memory pointer that, if far in memory,\n    would incur a huge gas cost for memory allocation.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Core_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Core_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Core_audit-2.pdf"
    }
  },
  {
    "title": "5.2 Unused Imports",
    "body": "```\nDesign Low Version 2 Code Partially Corrected\nCS-DPV1-\n```\nSeveral contracts in the codebase import libraries or contracts that remain unused. We present a\nnon-exhaustive list below:\n\nManager.sol\n\n```\nimport { IERC20 } from \"@oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"@oz/utils/math/SafeCast.sol\";\nimport { IManagerState } from \"./interfaces/IManagerState.sol\";\n```\nArena.sol\n\n```\nimport { IBattleActions, IBattleMintBurn } from\n\"core/interfaces/battle/IBattleActions.sol\";\n```\nBattle.sol\n\n```\nimport { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { IBattleState } from \"core/interfaces/battle/IBattleState.sol\";\nimport { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\";\nimport { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { IArenaState } from \"core/interfaces/IArena.sol\";\nimport { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";\n```\nCode partially corrected:\n\nSome of the unused imports have been removed, while other are still present. For example:\n\nManager.sol\n\n```\nimport { IManagerState } from \"./interfaces/IManagerState.sol\";\n```\nBattle.sol\n\n```\nimport { IBattleBase } from \"core/interfaces/battle/IBattleActions.sol\";\nimport { IBattleInit } from \"core/interfaces/battle/IBattleInit.sol\";\nimport { IBattleMintBurn } from \"core/interfaces/battle/IBattleActions.sol\";\n```\n\n```\nimport { IArenaState } from \"core/interfaces/IArena.sol\";\nimport { DiverSqrtPriceMath } from \"core/libs/DiverSqrtPriceMath.sol\";\n```\nPlease note that the aforementioned list is non-exhaustive and there might still exist some other unused\nimports in the codebase.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf"
    }
  },
  {
    "title": "6.17 Indistinguishable Spear and Shield Tokens",
    "body": "```\nInformational Version 1 Code Corrected\nCS-DPV1-022\n```\nArena deploys a set of ERC20 tokens named spear and shield for each battle created. These ERC20\ntokens have the same name (Spear/Shield) and symbol (SPEAR/SHIELD) for all battles, hence\npossibly confusing for users to distinguish them.\n\n\nCode corrected:\n\nThe function Arena.createBattle has been revised to deploy STokens with distinguishable name\nand symbol by appending the battle number after their name and symbol (Spear-X/Shield-X):\n\n```\nstring memory indexString = Strings.toString(battleList.length);\naddress spear = address(new SToken(string.concat(\"Spear\", indexString),\nstring.concat(\"SPEAR\", indexString), decimals, battle));\naddress shield = address(new SToken(string.concat(\"Shield\", indexString),\nstring.concat(\"SHIELD\", indexString), decimals, battle));\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf"
    }
  },
  {
    "title": "8.7 Users Should Validate Collateral Tokens",
    "body": "Note Version 2\n\nIf Arena.isPermissionless is set, users can deploy battles with arbitrary tokens as collateral.\nHowever, the smart contracts in scope of this review work as expected only with standard ERC20 tokens\nthat do not implement special features such as transfer hooks, rebasing, or transfer fees. See Section\nRoles and Trust Model for more details.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_Tenet_Technology_Ltd_Divergence_Protocol_v1c_audit-2.pdf"
    }
  },
  {
    "title": "7.1 Permit Does Not Specify Price and Lasts",
    "body": "Forever\n\n```\nInformational Version 1 Acknowledged\nCS-MGVC-\n```\nIn MgvOfferTakingWithPermit, an allowance can be given to another address, allowing it to make orders\non an address's behalf.\n\nThis allowance lets the spender take orders at any price. No maxTick is specified. Essentially, it is an\nallowance to execute a market order at any price. The impact is limited, as Mangrove only allows taking\nthe best order on the order book. However, if orders are removed from the book inbetween the allowance\nbeing given and the order execution, the trade may have a much worse execution price than expected.\n\nThe _allowance given lasts forever. The spender could execute marketOrderFor at a much later\ntime, when the price is totally different.\n\nThe usage here is different than in Uniswap, from which the permit() function was adapted. In\nUniswap, the permit is used instead of an ERC20 approval. The user will still need to call the swap()\nfunction themselves. Here, the _allowance is much more powerful. It allows a trade to happen without\nthe user making a transaction at all.\n\nAs a result, allowances should only be given by users if the full allowance is expected to be used within a\nshort time. Otherwise, trades may be executed at unintended prices. Unused or partially used allowances\nshould be retracted.\n\nAcknowledged:\n\nMangrove Association (ADDMA) clarified that this is intended behavior:\n\n```\nThis is on purpose. Additional restrictions can be set up by the authorized\ncontract itself, but the main purpose is to have a general delegation\nmechanism that works e.g. for cold wallets that want to allow the hot wallet\nsome uses (such as trading on Mangrove) but not arbitrary token transfers.\n```\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf"
    }
  },
  {
    "title": "8.5 Tokens That Revert on Zero-Transfer Not",
    "body": "Supported\n\nNote Version 1\n\nERC20-like tokens that revert when transfer() is called with amount == 0 are not supported. If such\na token was used, any Offer that gives that token could be cleaned by specifying takerWants == 0,\nwhich would incorrectly blame the Maker.\n\nReverting on zero-transfer does not correctly comply with the ERC20 standard. However, there are\ntokens in use that have this functionality. Governance should check the token's ERC20-compliance\nbefore activating a market using it.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_Core_audit.pdf"
    }
  },
  {
    "title": "6.2 Front-running the Redeem",
    "body": "```\nSecurity High Version 1 Code Corrected\nCS-GEARV3INTGRTNS-\n```\nWhen redeeming a token with permit, a user specifies the receiver of the redeemed assets and submits a\nsignature which is verified as follows:\n\n```\ntry IERC20Permit(tokenOut()).permit(owner, address(this), tokenOutAmount, deadline, v, r, s) {} catch {} // U:[ZB-5]\n```\nNote that the signature verified is not connected to the msg.sender. Thus, an attacker who observes\nthe mempool can front-run and submit the same signature. Since the receiver is freely set, an attacker\ncan redeem the assets of a user.\n\n\nThe issue was reported by the client during the review after an independent assessment of the\ncodebase.\n\nCode corrected:\n\nIn the current implementation, only a signature belonging to the msg.sender can be verified.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Integrations_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Integrations_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Gearbox_Protocol_Gearbox_V3_Integrations_audit.pdf"
    }
  },
  {
    "title": "6.3 Empty/inexistent Storage Slots Can Not Be",
    "body": "Proven\n\n```\nCorrectness High Version 1 Code Corrected\nCS-HRDS-\n```\n```\nVersion 5\n```\nUnused / non-existing storage slots of an account default to a value of 0x0. These slots cannot be\nproven successfully as the mpt.verify() fails or starting from of the code, mpt.verify()\nreturns an empty list which cannot be successfully RLP-decoded.\n\nThis e.g. prevents proving zero balance of an ERC20 token.\n\nCode corrected:\n\nProving unset slots / slots with a value of zero is now possible. The change introduced in Version 5\nrelated to non inclusion proofs allows to prove non-existence of a key in a trie.\nevm_facts_registry.get_storage() has been updated to handle the case of a successful non\ninclusion verification.\n\nNote that the code doesn't allow to prove any storage slot for non-existing accounts. Similarly for\naccounts without storage the storage root is initialized to the keccak of 0x80 -\n0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421. No storage\nslots can be proven for these accounts.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Herodotus_Herodotus_on_Starknet_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Herodotus_Herodotus_on_Starknet_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Herodotus_Herodotus_on_Starknet_audit-2.pdf"
    }
  },
  {
    "title": "6.5 Double Entry Point Protection Can Be",
    "severity": "info",
    "body": "Insufficient\n\n```\nCorrectness Medium Version 3 Specification Changed\nCS-ZCHF-036\n```\nIn Position, the withdraw function looks as follows:\n\n```\nfunction withdraw(address token, address target, uint256 amount) external onlyOwner {\nif (token == address(collateral)) {\nwithdrawCollateral(target, amount);\n} else {\nuint256 balance = _collateralBalance();\nIERC20(token).transfer(target, amount);\nrequire(balance == _collateralBalance()); // guard against double-entry-point tokens\n}\n}\n```\nThe comment states that this should protect from double-entry-point tokens. That is, a token that\nsupports multiple addresses through which transfers can happen.\n\nHowever, it could be possible that the double-entry-point token has a transfer hook that calls the target\naddress. In this case, there could be a reentrant call to adjust(), which deposits an equal amount of\ntokens as are being withdrawn. The second require statement would pass, even though there was a\ndouble-entry-point token used to incorrectly withdraw collateral.\n\n\nIf there is a pre-transfer hook, the attacker could deposit and mint tokens using reentrancy, then withdraw\ncollateral using the second entry-point (that is not considered to be the collateral address) after the\nreentrant call returns, circumventing the _checkCollateral check that usually happens upon\nwithdrawing collateral. This could leave the position undercollateralized, leading to losses for the system.\n\nConsider the following example:\n\n```\n1.A position has a collateral that has a pre-transfer hook to the receiver and has two entry points.\n1000 collateral tokens are deposited. Each token has a value of 1 ZCHF. 1000 ZCHF are already\nminted.\n2.The position owner calls withdraw(), using the address of the token's second entry point (which\nis not the collateral address). The _collateralBalance of 1000 is saved and the transfer call\nhappens. Now, the pre-transfer hook is executed and gives execution control to the attacker.\n3.The attacker calls adjust(2000,2000,1). 1000 additional collateral are deposited, then\nmint() is called to mint an additional 1000 ZCHF. There are 2000 collateral tokens, so the\ncollateral check in mint() passes.\n4.The adjust() call returns, then the pre-transfer hook returns.\n```\n```\n5.The transfer of the second entry-point of the collateral happens.\n6.Now, the saved _collateralBalance of 1000 is compared to the current\n_collateralBalance, which is also 1000 , as that additional amount was deposited. The check\npasses.\n7.Now, there are 2000 ZCHF minted against a position with 1000 ZCHF worth of collateral.\n```\nThe undercollateralized minting can only happen if there is a collateral that has a double-entry-point AND\na pre-transfer hook that calls the recipient (ERC-777 tokens are not an example, they only call the\nrecipient after a transfer, not before). This combination of traits does not seem to appear in commonly\nused tokens.\n\nSpecification changed:\n\nFrankencoin has decided to revise the criteria of acceptable tokens that can be used as collateral. More\nspecifically, tokens that implement transfer hooks (such as ERC-777) should not be used as collateral\nand governance should deny any position with such collateral tokens.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Frankencoin_Frankencoin_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Frankencoin_Frankencoin_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Frankencoin_Frankencoin_audit.pdf"
    }
  },
  {
    "title": "6.20 Missing Implementation of Described",
    "body": "Functions\n\n```\nCorrectness Low Version 1 Specification Changed\nCS-ZCHF-014\n```\nThe comment in the contract ERC20 states that functions decreaseAllowance and\nincreaseAllowance are implemented:\n\n```\n* Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n* functions have been added to mitigate the well-known issues around setting\n* allowances. See `IERC20.approve`.\n```\nHowever, none of the above functions have been implemented by the contract. The frontrunning attack\nagainst approve() is therefore still applicable as it always overwrites the current value without checking\nif the allowance has been consumed or not.\n\nSpecification changed:\n\nThe comment has been removed.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Frankencoin_Frankencoin_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Frankencoin_Frankencoin_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/11/ChainSecurity_Frankencoin_Frankencoin_audit.pdf"
    }
  },
  {
    "title": "6.1 ERC-20 Missing Return Value",
    "body": "```\nDesign Low Version 1 Specification Changed\nCS-MDAC-\n```\nArrangerConduit handles ERC-20 transfers in the following way:\n\n```\nrequire(\nERC20Like(asset).transfer(destination, amount),\n\"ArrangerConduit/transfer-failed\"\n);\n```\nThis assumes that all ERC-20 contracts that can be called return a boolean value in their transfer()\nand transferFrom() functions. This is however not the case. Popular tokens like USDT are not\nreturning any value in the mentioned functions. If it were to happen that the arranger sends such tokens\nto the contract, the tokens would be locked and require an update of the contract.\n\nSpecification changed:\n\nTransfers are now performed without checking the return values of ERC20 tokens at all. MakerDAO\nassures that only tokens that revert on failure are used as assets in the contract.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_MakerDAO_ArrangerConduit_audit-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/10/ChainSecurity_MakerDAO_ArrangerConduit_audit-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/10/ChainSecurity_MakerDAO_ArrangerConduit_audit-1.pdf"
    }
  },
  {
    "title": "5.1 Read-only Reentrancy",
    "body": "```\nDesign Low Version 1 Acknowledged\nCS-SpoolV2-\n```\nIt can be possible to construct examples where certain properties of the SV mismatch reality. For\nexample, during reallocations, a temporary devaluation of SVTs occurs due to SSTs being released. Due\nto reentrancy possibilities, certain values retrieved could be inaccurate (e.g. SV valuation).\n\nAcknowledged:\n\nWhile the read-only reentrancy does directly affect on the protocol, it could affect third parties. Spool\nreplied:\n\n```\nThe mentioned view functions are not intended to be used while the\nreallocation is in progress.\n```\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 1\n```\n- Lack of Access Control in recoverPendingDeposits() Code Corrected\n\n```\nHigh-Severity Findings 7\n```\n- DOS Synchronization by Dividing With Zero Redeemed Shares Code Corrected\n- DOS on Deposit Synchronization Code Corrected\n- Donation Attack on SST Minting Code Corrected\n- Donation Attack on SVT Minting Code Corrected\n- Flushing Into Ongoing DHW Leading to Loss of Funds Code Corrected\n- No Deposit Due to Reentrancy Into redeemFast() Code Corrected\n- Wrong Slippage Parameter in Curve Deposit Code Corrected\n\n```\nMedium-Severity Findings 5\n```\n- Curve LP Token Value Calculation Can Be Manipulated Code Corrected\n- Deposits to Vault With Only Ghost Strategies Possible Code Corrected\n- Ghost Strategy Disables Functionality Code Corrected\n- Inconsistent Compound Strategy Value Code Corrected\n- Strategy Value Manipulation Code Corrected\n\n```\nLow-Severity Findings 19\n```\n- Distribution to Ghost Strategy Code Corrected\n- Lack of Access Control for Setting Extra Rewards Code Corrected\n- Wrong Error IdleStrategy.beforeRedeemalCheck() Code Corrected\n- Access Control Not Central to Access Control Contract Specification Changed\n- Asset Decimal in Price Feed Code Corrected\n- Bad Event Emissions Code Corrected\n- Broken Conditions on Whether Deposits Have Occurred Code Corrected\n- Deposit Deviation Can Be Higher Than Expected Code Corrected\n- Inconsistent Handling of Funds on Strategy Removal Code Corrected\n- Misleading Constant Name Code Corrected\n- Missing Access Control in Swapper Code Corrected\n- Missing Event Fields Code Corrected\n- No Sanity Checks on Slippage Type Code Corrected\n- Precision Loss in Notional Finance Strategy Code Corrected\n- Redemption Executor Code Corrected\n\n\n- State Inconsistencies Possible Code Corrected\n- Unused Functions Code Corrected\n- Unused Variable Code Corrected\n- Validation of Specification Code Corrected\n\n```\nInformational Findings 9\n```\n- Reverts Due to Management Fee Code Corrected\n- Simplifying Performance Fees Code Corrected\n- Strategy Removal for an SV Possible That Does Not Use It Code Corrected\n- Errors in NatSpec Specification Changed\n- Distinct Array Lengths Code Corrected\n- Gas Optimizations Code Corrected\n- Nameless ERC20 Code Corrected\n- NFT IDs Code Corrected\n- Tokens Can Be Enabled Twice Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf"
    }
  },
  {
    "title": "6.18 Asset Decimal in Price Feed",
    "body": "```\nDesign Low Version 1 Code Corrected\nCS-SpoolV2-013\n```\nThe asset decimals are given as an input parameter in setAsset(). Although being cheaper than\ndirectly querying ERC20.decimals(), it is more prone to errors. Fetching the asset decimals through\nthe ERC20 interface could reduce such risks.\n\nCode corrected:\n\nERC20.decimals() is now called to fetch the underlying asset decimals.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf"
    }
  },
  {
    "title": "6.37 Nameless ERC20",
    "body": "```\nInformational Version 1 Code Corrected\nCS-SpoolV2-033\n```\nThe SVT ERC-20 does not have a name. Specifying a name may help third-party front-ends (e.g.\nEtherscan) to display useful information to users for a better user experience.\n\nCode corrected:\n\nThe SVT now has a name and symbol for its ERC-20. Additionally, the ERC-1155 has a URI now.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/07/ChainSecurity_Spool_Spool_V2_audit-2.pdf"
    }
  },
  {
    "title": "7.6 safeApprove Can Revert",
    "body": "```\nInformational Version 1\nCS-GEARV21-005\n```\nTheoretically, IERC20.safeApprove() can revert in WstETHGateway._checkAllowance() and\nWaToken.depositUnderlying() because the safeApprove() function requires either the current\nallowance or the value to be 0.\n\n- In WstETHGateway, the allowance for the WstETH token is set to type(uint256).max at contract\n    deployment, and is decreased each time WstETHGateway.addLiquidity() is called. Also, each\n    time WstETHGateway.addLiquidity() is called, the allowance check is performed, so if the\n    allowance is strictly smaller than the amount. But the maximum allowance is such a big number that\n    this will never happen in practice.\n- In WstETHGateway.removeLiquidity() and WaToken.depositUnderlying() set the\n    allowance for Gearbox's and Aave's lending pool to the exact amount that should be pulled from the\n    contract. The pools are trusted to pull the exact specified amount and not less to set the allowance\n    back to 0. If one of the pool was to be updated and pulls less than the specified amount,\n    WstETHGateway.removeLiquidity() and WaToken.depositUnderlying() would revert.\n\n\n\nWe leverage this section to highlight further findings that are not necessarily issues. The mentioned\ntopics serve to clarify or support the report, but do not require an immediate modification inside the\nproject. Instead, they should raise awareness in order to improve the overall understanding.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Gearbox_Protocol_Gearbox_V2_1_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Gearbox_Protocol_Gearbox_V2_1_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Gearbox_Protocol_Gearbox_V2_1_audit.pdf"
    }
  },
  {
    "title": "6.2 Race Condition on Team Allowance",
    "body": "```\nDesign Low Version 1 Specification Changed\nCS-YRNDSCNT-\n```\nIf the management calls set_team_allowances a second time during the same month while a team\nhas some allowance left, similar to the well-documented issue with the ERC20 approve function, it is\npossible for a team to front-run the transaction to spend its remaining allowance before the management\nset its allowance to the new amount.\n\nSpecification changed\n\nYearn highlighted the trust assumption that the team is a fully trusted party. Misbehaving will lead to\ndisqualification from participating in the program.\n\n\n\nWe utilize this section to point out informational findings that are less severe than issues. These\ninformational issues allow us to point out more theoretical findings. Their explanation hopefully improves\nthe overall understanding of the project's security. Furthermore, we point out findings which are unrelated\nto security.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_yDiscount_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Yearn_yDiscount_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Yearn_yDiscount_audit.pdf"
    }
  },
  {
    "title": "6.26 Superfluous Interface Definitions",
    "body": "```\nDesign Low Version 1 Code Corrected\nCS-CRVUSD-028\n```\n- In Stableswap Factory.convert_fees\n\nThe following interface definitions were not needed and removed:\n\n- In Controller LLAMMA.get_y_up is unused.\n- In Stablecoin the Controller.admin interface is unused.\n- In AMM the ERC20's balanceOf function is unused.\n- The AggMonetaryPolicy and AggregateStablePrice contracts implement the ERC20\n    interface but do not use it.\n- AggregateStablePrice does not use the balances definition of Stableswap\n- PegKeeper does not use StableAggregator.stablecoin and CurvePool.lp_token an\n    ERC20.balanceOf\n- In Controller LLAMMA.get_base_price and ERC20.totaSupply\n- In ControllerFactory ERC20.transferFrom\n\nCode corrected\n\nCurve removed most of the unused definitions.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Curve_Curve_Stablecoin_audit-1.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Curve_Curve_Stablecoin_audit-1.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Curve_Curve_Stablecoin_audit-1.pdf"
    }
  },
  {
    "title": "8.8 Supported Tokens",
    "body": "Note Version 1\n\nThe system only supports standard ERC20 tokens without special behaviors, especially tokens with\ncallbacks (ERC777) which would allow arbitrary code execution. More explicitly, tokens with two entry\npoints should also be avoided.\n\nTokens with fees or any rebasing mechanism aren't supported.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_yldr_com_yldr_com_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_yldr_com_yldr_com_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_yldr_com_yldr_com_audit.pdf"
    }
  },
  {
    "title": "7.1 Ability to Modify name & symbol",
    "body": "Note Version 1\nVersion 2 introduces functionality for the priviledge role to update the token parameter name and symbol.\nNote that is unusual for ERC20 tokens and must be done with care. Some downstream applications or\nsmart contracts may not be designed to accommodate such changes.\n\nConsider these illustrative examples:\n\n- Upon deployment the name of Curve pools is set using the traded token names.\n- The representative token deployed by third-party bridges to other chains is often based on the\n    original token's name and symbol.",
    "dataSource": {
      "name": "ChainSecurity/Smart-Contract-Audit-_Maker_EndGame_Toolkit_Maker-DAO-audit-_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/05/Smart-Contract-Audit-_Maker_EndGame_Toolkit_Maker-DAO-audit-_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/05/Smart-Contract-Audit-_Maker_EndGame_Toolkit_Maker-DAO-audit-_-ChainSecurity.pdf"
    }
  },
  {
    "title": "8.2 Relevant Concerns of TrueFi Carbon Smart",
    "body": "Contract Audit Report\n\nNote Version 1\n\nThis audit report covers Fluorine which is dependent on some logic of another product of TrueFi: Carbon.\nSince both projects share similarities, the following points, which have been covered in the Carbon audit\nreport, are also valid for Fluorine.\n\nThe report can be found at https://chainsecurity.com/wp-content/uploads/2023/07/TrueFi_Carbon_-Smar\nt-Contract-Audit-_-ChainSecurity.pdf (snapshot).\n\n- 5.2 DoS for Start\n- 5.3 Loan Default Frontrunning\n- 5.4 Fee Transfer DoS\n- 7.1 Ambiguous Deficit Data in Closed State\n- 7.2 Compounding Interest Computed in Arbitrary Intervals\n- 7.3 Fee Accrual in Closed State\n- 7.4 Fee Accrual on Yield\n- 7.5 Manager Fee Accrual\n- 7.7 Skewed Interest Distribution\n- 7.8 Use of Non-standard ERC20 Tokens\n\nPlease note, that the Carbon equivalent to StructuredAssetVault is called\nStructuredPortfolio.\n\nPlease also note, that a \"loan default\" in some of these issues is equivalent to a call to\nStructuredAssetVault.updateState() with a value that decreases the outstanding assets of the\nvault.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_TrueFi_Fluorine_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_TrueFi_Fluorine_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/12/ChainSecurity_TrueFi_Fluorine_audit.pdf"
    }
  },
  {
    "title": "7.8 Use of Non-standard ERC20 Tokens",
    "body": "Note Version 1\n\nManagers (and users) should be aware that using a non-standard ERC20 token as the underlying can be\ndangerous for the system. Non-standard ERC20 tokens include but are not limited to the following\nbehaviors:\n\nTokens With Reentrancies:\n\nIf a portfolio is set up with an underlying token that is reentrant (e.g., ERC-777), various possibilities of\nreentrancy attacks are enabled. Here is an example of one possible attack vector:\n\n- A portfolio consists of 3 tranches and is in Live status with no active loans.\n- Users have deposited 100 tokens to each tranche with no accrued interest (i.e. 1 share per token).\n- An attacker calls deposit on the junior tranche with 99 tokens.\n- In the safeTransferFrom call, the underlying token calls back to the attacker's contract.\n- At this point, the checkpoint of the junior tranche has already been updated, while the\n    virtualTokenBalance in the portfolio has not.\n- The attacker now reenters into the deposit function if the equity tranche with a deposit of 100 tokens.\n- 10,000 shares are minted to the attacker as the virtualTokenBalance is still 300, while the\n    checkpoints of senior and junior tranches return a sum of 299 tokens, leaving only 1 token for the\n    equity tranche waterfall value.\n- After the call, the attacker now holds shares representing 99 tokens in the junior tranche and ~198\n    tokens in the equity tranche resulting in an instant profit of ~98 tokens.\n\nTokens With Fees:\n\nWhen transferring tokens with fees, the receiver does not get the amount the sender sends but a part of it\nas fees are deducted. However, updating the virtualTokenBalance for example makes the\nassumption the whole amount has been received. Thus, repetitive transfers will create a discrepancy\nbetween the internal accounting of the portfolio which uses the virtualTokenBalance and the actual\namount held by the portfolio.\n\nRebasing Tokens:\n\nWith rebasing tokens, the amount of tokens each account holds changes over time. This will lead,\nsimilarly to tokens with fees, to internal accounting being wrong.\n\nPausable Tokens:\n\nWhen a token is paused, it might revert on every call to functions like transfer. As Carbon extensively\nuses transfers in many functions, the system could become unusable on such occasions.",
    "dataSource": {
      "name": "ChainSecurity/TrueFi_Carbon_-Smart-Contract-Audit-_-ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/07/TrueFi_Carbon_-Smart-Contract-Audit-_-ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/07/TrueFi_Carbon_-Smart-Contract-Audit-_-ChainSecurity.pdf"
    }
  },
  {
    "title": "6.2 Missing Transfer of Tokens When Adding New",
    "body": "Assets\n\nCorrectness Medium Version 1 Code Corrected\n\nFunction add_asset can be called only by management which is trusted to behave correctly in the\ncontract Pool. The parameter _amount in function add_asset is the amount of tokens that are\ndeposited into the Pool when the new asset is added. However, the code does not pull the funds from an\nexternal account (if approved) or check that the Pool has already the required balance (if already\ntransferred).\n\nCode corrected:\n\nThe issue has been resolved by adding the code in function add_asset that pulls the respective tokens\nfrom msg.sender:\n\n```\nassert ERC20(_asset).transferFrom(msg.sender, self, _amount, default_return_value=True)\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Yearn_Yearn_yETH_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Yearn_Yearn_yETH_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Yearn_Yearn_yETH_audit.pdf"
    }
  },
  {
    "title": "5.1 Problems Related to Consent and",
    "body": "ConsentVerification\n\nDesign Medium Version 1 Acknowledged\n\nThe consent ECDSA signature that the depositor needs to provide has the following design issues:\n\n```\n1.When Alice wants to deposit 100 wei ERC20 token from Optimism to Bob on mainnet, she has to\nsign EIP712 hash of Consent(Bob, 100, \"\"). However, the same signature she has to provide\nif Alice wants to deposit 100 ERC20 token from Polygon to Bob. This signature does not contain\nany information about origin domain. Only address of ConsentVerification contract on the\ndestination chain is taken into account.\n2.Only EOA addresses are able to sign data. Multisig wallets or any other smart contract addresses\nwon't be able to provide a consent signature. This limits potential integrations of SRG with the other\nsystems\n```\n```\n3.Consent itself is redundant. Both ERC20Gateway and savETHGateway allow only deposits when\nmsg.sender == ownerGivingConsent. Thus, only Alice will be able to insert the deposit leaf\ninto Accumulator. Check that deposit is inserted into the Accumulator tree can be seen as an \"Alice\nwanted to transfer funds to Bob\" check. In addition, deposit leaf insertion contains more information\nand thus is a stronger constraint.\n```\n```\n4.CONSENT_TYPEHASH violates the EIP712 specification. The type of a struct must be encoded as\nname || \"(\" || member_1 || \",\" || member_2 || \",\" || ... || member_n \")\" where each member is written\nas type || \" \" || name. The CONSENT_TYPEHASH doesn't have member names.\n```\n\n```\n5.ConsentVerification.computeTypedStructHash violates the EIP712 specification. Each encoded\nmember value must be exactly 32-byte long. abi.encodePacked will encode address _paramOne\nas 20-byte long.\n```\nAcknowledged:\n\nBlockswap responded:\n\n```\nWe will be addressing these as part of the transportation layer upgrade we mentioned in the call\n```",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "5.7 saveETHManager.init Is Not Defined in",
    "body": "ISavETHManager\n\nDesign Low Version 1 Acknowledged\n\nIn StakeHouseUniverseDestinationGateway.init an ERC1967 Proxy gets deployed for the logic\ncontract _saveETHManagerLogic. However, when encoding _data input field for the constructor of\nERC1967, it assumes\n\n```\n1.init function is implemented for savETHManager, although not defined in ISavETHManager\n```\n```\n2.init function of savETHManager has the exact same layout as\nsavETHDestinationReporter.init, which might be invalid assumption.\n```\nThese assumptions can be wrong.\n\nAcknowledged:\n\nBlockswap has acknowledged it, claiming that calling this function from external users is not encouraged.\n\n\n\nHere, we list findings that have been resolved during the course of the engagement. Their categories are\nexplained in the Findings section.\n\nBelow we provide a numerical overview of the identified findings, split up by their severity.\n\n```\nCritical-Severity Findings 0\n```\n```\nHigh-Severity Findings 0\n```\n```\nMedium-Severity Findings 4\n```\n- Cost of bytesToHex Code Corrected\n- ERC20 Token Decimals Code Corrected\n- Inconsistent DepositEvent Amount Units Code Corrected\n- batchDeposit Reverts if the Lengths of Input Arrays Match Code Corrected\n\n```\nLow-Severity Findings 5\n```\n- EIP165 Interface Implementation Check Is Not Fully Correct Code Corrected\n- Sandwich Attack Without MEV Services Specification Changed\n- Deployed Event of Gateway Is Not Informative Specification Changed\n- whenGatewayAndPushNotKilled Specification Mistmatch Code Corrected\n- dETH Dispensers Are Not a IsavETHDispenser Code Corrected",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "6.2 ERC20 Token Decimals",
    "severity": "medium",
    "body": "Design Medium Version 1 Code Corrected\n\nThe GatewayToken contract inherits from ERC20Upgradeable fixed decimals of 18. In general, this\nmight be not the same as the original token decimals. As a result, this might break UIs that will deal with\nsuch bridged tokens. Also, protocols that rely on decimals might have problems with compatibility.\n\n\nCode corrected:\n\nThe GatewayToken.decimals now returns a variable that can be set in the init function.",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "6.3 Inconsistent DepositEvent Amount Units",
    "severity": "medium",
    "body": "Design Medium Version 1 Code Corrected\n\nThe ERC20Gateway.deposit function users provide the amount of tokens to extend as a\nBaseInputParams.paramTwo in wei. This param in wei will contribute to the deposit leaf hash. Same\nparamTwo in wei will be emitted in DepositEvent. On the destination domain recipient will need to\nspecify the same paramTwo in _depositMetadata.baseDepositInfo.paramTwo.\n\nHowever, this is not consistent with savETHGateway. In savETHGateway.deposit the user provides\nthe KNOT that he wants to migrate. The savETHRegistry.knotDETHBalanceInIndex in gwei of this\nKNOT will contribute to the deposit leaf hash. But the knotDETHBalanceInIndex in wei will be emitted\nin Deposit tx. On push, _depositMetadata.amount in gwei will be converted to wei and the savETH\non the destination domain will be minted. In summary, inconsistency is that units of event do not match\nthe value from _depositMetadata.amount and the deposit leaf hash. Assuming that the endorsers\nwill be querying the depositMetadata for the attestation, an extra conversion of deposit event values will\nbe needed for one of these cases to compute the hash of the RPBS info.\n\nCode corrected:\n\nBlockswap has successfully resolved this inconsistency in various parts of the codebase (both\ndispensers and ingestors).",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "7.2 Gas Optimisation",
    "severity": "info",
    "body": "Informational Version 1 Acknowledged\n\nThe codebase has several inefficiencies in terms of gas costs when deploying and executing smart\ncontracts. Here, we report a list of non-exhaustive possible gas optimizations:\n\n```\n1.The modifier Gateway.whenGatewayAndDomainNotPausedOrKilled loads information about\na specific domain Id to the storage and later reads the underlying information from storage, which is\nquite inefficient.\n```\n```\n2.ERC20Gateway._assertConsumptionAuthorised reverts if\nmsg.sender != _baseParams.ownerGivingConsent. However, the same check is\nperformed in _consume function, before calling to _assertConsumptionAuthorised.\n3.Gateway.injectForeignDomainCheckpoint checks that recovery is enabled for the\ndispenser and then calls into Dispenser.injectForeignDomainCheckpoint which performs\nthe exact same check.\n4.Gateway.batchDeposit iterates through every deposit in a list and calls to Gateway.deposit\nwhich solely calls into Gateway._consume. By calling _consume directly from batchDeposit\ngas can be saved.\n5.Once Gateway.batchDeposit directly calls to _consume, the visibility of Gateway.deposit\ncan also be changed to external.\n6.Gateway._dispense, in case of recovery not being enabled, performs a multitude of checks (e.g.\nvalidating consent signature, asserting dispense being authorized, and finally dispensing in the\ndispenser module). After all of these gas expensive operations, it checks whether UTXO is already\nspent or not. In case of an attempt to use spent UTXO the revert will happen late in execution.\nMoving this check earlier would consume less gas in this scenario.\n```\n\n```\n7.Gateway._dispense, in case of recovery being enabled, checks that a non-zero recovery Merkle\nroot has been injected. Later, it calls to dispenseViaRecovery of the dispenser, which again\nassures that the recovery Merkle root is injected.\n8.Domain.dispense, checks isRecoveryEnabled, however, Gateway will only call this function if it\nis not set.\n```\n```\n9.ConsentVerification.validateConsentSignature is defined as public but never used\ninternally. Its visibility can be changed to external to save gas.\n10.Both functions _onlyStakeHouseKnotThatHasNotRageQuit and\n_onlyValidStakeHouseKnot in savETHRegistryDestinationGateway have the exact\nsame functionality, only with different naming. It makes bytecode of the contract larger; hence, the\ndeployment costs would be more expensive.\n11.Gateway.deposit can increase userConsentNonce without the use of the safemath.\n12.The fields in the Domain struct from the IGateway can be benefit from tight variable packing\npatterns.\n13.The balanceIncrease function checks that accumulator of the the domain is not 0. The same\ncheck is performed in the whenGatewayAndDomainNotPausedOrKilled modifier of the same\nfunction.\n14.Many functions of the savETHGateway query saveETHRegistry from the universe multiple times\nin the same function.\n```\nAcknowledged:\n\nBlockswap will consider these optimizations later and apply changes when needed.",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "8.2 Checked Properties",
    "body": "Note Version 1\n\nCertain invariants of Blockswap SRG system were checked during this assessment or explicitly\nconsidered:\n\n- GatewayToken needs to be deployed with the same decimal value as the original token.\n- ERC20 Gateway is capable of handling simple ERC20 tokens. Any special tokens need to be\n    wrapped. Consider this list: https://github.com/d-xo/weird-erc20\n- Tree leaf of the Recovery Merkle tree should never be made of 64 bytes. Intermediate nodes might\n    become claimable due to the collisions with the total length of leaf components matching the length\n    of two concatenated hashes. See:\n    https://github.com/OpenZeppelin/openzeppelin-contracts/issues/3091\n- To prevent cross-domain replays any leaf inserted into the accumulator needs to contain origin and\n    destination chain ids, and origin and destination gateway addresses.\n- Any kind of leaf that is inserted into Accumulator needs to have a unique prefix like TYPE_HASH to\n    prevent collisions with other leaf types.\n- The total supply of ERC20 tokens minted on some destination domain should equal the\n    totalExtended value of the origin domain on this destination domain.\n- The total supply of ERC20 tokens minted on some destination domain should equal the\n    totalExtended value of this destination domain on the origin domain.\n- Balances or KNOTs deposited from the origin domain can always be pushed on the destination\n    domain, assuming both domains are not paused/killed.\n- In case of ERC20: ERC20OriginDispenser must be the minter of GatewayToken.\n    ERC20DestinationIngestor must be the burner of GatewayToken.\n- In the case of ERC20: the sum of leaf amounts in the Recovery Merkle tree should always equal the\n    origin's totalExtended value of the recovered domain.\n- In the case of dETH: the set of leaf KNOTs in the Recovery Merkle tree should always be the same\n    as KNOTs that belong to the destination index on the origin domain. No leaf should contain the\n    same KNOT twice.\n\nSuch invariants need to be considered during future updates.",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "8.3 Handling ERC20 With Access Control",
    "body": "Functionality\n\nNote Version 1\n\nSome ERC20 tokens can ban certain addresses from sending and receiving the tokens, e.g. USDC.\nAssume a scenario, where Alice deposits USDC tokens from Optimism back to the mainnet. Upon push,\nthe receiver of USDC on the mainnet chain might be blacklisted. In this scenario, Alice's tokens will be\nlocked and the push transaction will revert.",
    "dataSource": {
      "name": "ChainSecurity/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/Blockswap-Smart-Contract-Audit_State-Replication-Gateway_SRG_ChainSecurity.pdf"
    }
  },
  {
    "title": "6.5 Reserve Balance Does Not Include Kandel's",
    "body": "Balance\n\n```\nCorrectness Low Version 1 Code Corrected\nISSUEIDPREFIX-\n```\nThe reserveBalance() is the available balance for a strategy of an offered token. Note that Direct\nstrategies try to use the local balance always first, see function __get__().\n\n```\nuint amount_ = IERC20(order.outbound_tkn).balanceOf(address(this));\nif (amount_ >= amount) {\nreturn 0;\n}\n```\nHowever, the AaveKandel does not account for the local balance (potentially received through donations)\nin reserveBalance().\n\nCode corrected:\n\nThe function AaveKandel.reserveBalance() has been updated to take its own balance into\naccount.",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mangrove_Association_ADDMA_Kandel_Strats_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Mangrove_Association_ADDMA_Kandel_Strats_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Mangrove_Association_ADDMA_Kandel_Strats_audit.pdf"
    }
  },
  {
    "title": "8.5 Tokens With Transfer Fees",
    "body": "Note Version 1\n\nMangrove is supposed to handle the exchange of ERC20 tokens. As shown in the snippet below, the\nsystem expects to send to the maker the same amount (sor.gives) it received from the taker.\nHowever, in the case of the tokens with transfer fees this trade will fail since the amount received and\nforwarded by Mangrove will be different than the one requested due to the fees. By providing additional\nbalance of this token to the contract ahead of the transaction, a party may make the transfer to succeed\nnevertheless. This may be done by either the maker or the taker. The other party then receives less\ntokens then expected, as the transfer fee will be deducted.\n\n```\nif (transferTokenFrom(sor.quote, taker, address(this), sor.gives)) {\nif (\ntransferToken(\nsor.quote,\n$$(offerDetail_maker(\"sor.offerDetail\")),\nsor.gives\n)\n) {\n```\n```\n...\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/08/ChainSecurity_Mangrove_Association_ADDMA_Mangrove_audit.pdf"
    }
  },
  {
    "title": "5.7 InterfaceT Does Not Implement Type",
    "body": "Comparison\n\n```\nDesign Medium Version 1\nCS-VYPER_JANUARY_2023-\n```\nTypechecking is not performed between interface types, a variable of any interface type can be assigned\nto any other interface typed variable. The reason is that InterfaceT does not implement a custom\n\n\ncompare_type(), and reuses the one from VyperNode, according to which two instances of\nInterfaceT represent the same type, regardless of their attributes.\n\nThe following should not compile, but does:\n\n```\nfrom vyper.interfaces import ERC\n```\n```\ninterface A:\ndef f(): view\n```\n```\n@internal\ndef foo():\na:ERC20 = A(empty(address))\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Vyper_January_2023_limited_review.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Vyper_January_2023_limited_review.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2023/02/ChainSecurity_Vyper_January_2023_limited_review.pdf"
    }
  },
  {
    "title": "6.6 LendAndStake Stakes the Full Balance",
    "severity": "minor",
    "body": "Design Low Version 1 Code Corrected\n\nLendAndStake is an action wrapping the lending and the staking action. First, it lends an amount of\nliquidity assets to the Maple pool. Next, it stakes LP tokens to the rewards contract to get some extra\nrewards:\n\n```\nfunction __lendAndStakeAction(bytes memory _actionArgs) private {\n(\naddress pool,\naddress rewardsContract,\nuint256 liquidityAssetAmount\n) = __decodeLendAndStakeActionArgs(_actionArgs);\n```\n\n```\n__lend(IMaplePool(pool).liquidityAsset(), pool, liquidityAssetAmount);\n__stake(rewardsContract, pool, ERC20(pool).balanceOf(address(this)));\n}\n```\nThe argument passed to the internal __stake function is the full balance of the pool token. Note that it is\nalso possible to lend the underlying without staking. Consider now the following scenario:\n\n```",
    "dataSource": {
      "name": "ChainSecurity/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IV_audit.pdf",
      "url": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IV_audit.pdf",
      "repo": "https://chainsecurity.com/wp-content/uploads/2022/05/ChainSecurity_Avantgarde_Finance_Sulu_Extensions_IV_audit.pdf"
    }
  },
  {
    "title": "The First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans",
    "severity": "medium",
    "body": "# Handle\n\njvaqa\n\n\n# Vulnerability details\n\nThe First User To Borrow a Particular Token Can Drain Funds In MarginSwap by Making An Undercollateralized Borrow Using Flash Loans\n\n## Impact\n\nThis attack can be performed with any two ERC20 tokens, where one of them has not yet been borrowed on MarginSwap.\nSince any newly added token must first be loaned before it can be borrowed, there will always be a window of time where this attack is possible for any newly added asset.\nThe magnitude of the attack will be limited by the size of MarginSwap.CrossMarginAccounts.tokenCaps[borrowToken], but could potentially allow an attacker to drain one particular token from MarginSwap if it has been lent but not yet borrowed.\n\n## Proof of Concept\n\nFor the sake of argument, let's assume two ERC20 tokens called Token0 and Token1, who have a current market price of 1:1.\n\nExpected Behavior:\nAlice can only borrow 900 Token1 if she puts up 1,000 Token0 as collateral.\n\nActual Behavior:\nUsing this attack, Alice can borrow 9,000 Token1 when using 1,000 Token0 as collateral. She can leave her 1,000 Token0 behind in MarginSwap, and sell the 9,000 Token1 for an 8,000 token profit.\nIt should be noted that this attack can be larger than what is shown here: we demonstrate a 10x attack for simplicity, but it only depends on how much liquidity is in the Uniswap pool, determining how much it will cost to skew the price.\n\n(0) Alice begins with 1,000 Token0 and 1,000 Token1\n(1) Alice calls AliceAttackerContract.functionOneOfTwo(), which performs the following calls:\n  (1.1) Calls Token0.approve(MarginSwap, UINT256MAX) to allow MarginSwap to spend her Token0\n  (1.2) Calls MarginSwap.MarginRouter.crossDeposit(Token0Address, 1000 * 1e18)\n(2) Alice waits for n + 1 blocks to pass, where n is specified in MarginSwap.CrossMarginTrading.coolingOffPeriod (currently set at 20 blocks)\n(3) Alice calls AliceAttackerContract.functionTwoOfTwo(), which performs the following calls:\n  (3.1) Flashloan Token1\n  (3.2) Trade Token1 for Token0 on Uniswap to make Token1's price on Uniswap appear cheaper. For argument's sake let's skew the price to 10:1\n  (3.3) Calls Token1.approve(MarginSwap, UINT256MAX) to allow MarginSwap to spend her Token1\n  (3.3) Call MarginRouter.crossBorrow(Token1Address, 9000 * 1e18);\n  (3.4) Call MarginRouter.crossWithdraw(Token1Address, 9000 * 1e18);\n  (3.5) Trade Token0 for Token1 on Uniswap to return the Uniswap price to market price, minus fees\n  (3.6) Repay the Flashloan of Token1\n(4) Alice ends with 10,000 Token1 (minus Uniswap fees). Since we assumed Token0 and Token1 had the same market price for the sake of argument, Alice has a profit of 8,000 Token1 minus Uniswap fees, and MarginSwap has lost 8,000 Token1.\n\nThe various defenses that MarginSwap has employed against flashLoans are all bypassed:\n(a) MarginSwap employed noIntermediary() on MarginSwap.CrossMarginLiquidation.liquidate() in order to prevent the liquidation function from being called by a contract. However, this defense does not prevent crossDeposit() or crossBorrow() from being called by a contract.\n(b) The coolingOffPeriod is bypassed, since the flashLoan price manipulation can occur at the moment of withdrawal, and the coolingOffPeriod is only triggered upon deposit, so you can split the deposit and withdrawal into two transactions that are separated by at least coolingOffPeriod number of blocks.\n(c) UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT are bypassed, since if this is the first borrow for Token1, then MarginSwap.PriceAware.getCurrentPriceInPeg() simply returns the current price from Uniswap, not an exponential moving average, and does not consult UPDATE_MIN_PEG_AMOUNT and UPDATE_MAX_PEG_AMOUNT at all.\n(d) MarginSwap.Lending.registerBorrow check is bypassed. The check is \"meta.totalLending >= meta.totalBorrowed\", but this is a global check that only ensures that the contract as a whole has sufficient Token1 to fund Alice's borrow. If users have lent Token1 to MarginSwap but no one has borrowed it yet, then Alice simply needs to ensure that she does not borrow more than those users have lent.\n(e) MarginSwap.CrossMarginTrading._registerBorrow check is bypassed. The check is \"tokenCaps[borrowToken] >= totalShort[borrowToken]\". Since Alice does not need to make a huge borrow for her attack to succeed, even a conservative initial borrowCap can be bypassed for at least some profit.\n\n## Recommended Mitigation Steps\n\nThe best solution is to use Uniswap's built in TWAP, and to take your first measurement from it when you add a new token, rather than at the time of the first borrow of that token.\nUsing a price oracle that is internal to MarginSwap leads to less accurate prices, which is especially problematic for an application that features lending/borrowing. If MarginSwap is not widely used or if it features a lesser used token, the price oracle will be innacurate and will lead to attacks.\nSince Uniswap already has TWAPs built in, there is no reason not to utilize them, since they will be far more accurate.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-marginswap-findings",
      "repo": "https://github.com/code-423n4/2021-04-marginswap-findings",
      "url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/66"
    }
  },
  {
    "title": "[Gas] Not used imports",
    "severity": "minor",
    "body": "# Vulnerability details\n\nGas optimization suggestion:\n\nNot used imports: Contracts CrossMarginAccounts and CrossMarginTrading import \"./MarginRouter.sol\"; but do not use it. Contract Admin import \"./CrossMarginTrading.sol\"; Also unused imports in several contracts:\n  import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n  import \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\n# Eth address\n\n0x523B5b2Cc58A818667C22c862930B141f85d49DD\n\n\n# Handle\n\npaulius.eth\n\n\n# Email address\n\npauliax6@gmail.com\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-marginswap-findings",
      "repo": "https://github.com/code-423n4/2021-04-marginswap-findings",
      "url": "https://github.com/code-423n4/2021-04-marginswap-findings/issues/58"
    }
  },
  {
    "title": "Potential reentrancy when the borrower drawdowns the loan.",
    "severity": "minor",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nIf the `liquidityAsset` or `collateralAsset` is an ERC777 that allowed receviers to define receive hooks when tranferring, reentrancy is theoretically possible when the borrower calls the `drawdown` function, which will possibly break the functionality of lending loans. Although currently it doesn't seems to be an attack that the borrower can take advantage from, this vulnerability increases risk when developing new methods of the loan in the future. Otherwise, the protocol should not support ERC777 tokens.\n\n## Proof of Concept\n\nIn the `drawdown` function, line 203 transfers `collateralAsset` from the borrower to `collateralLocker`. The borrower can register a `tokensToSend` hook in the token contract of `collateralAsset` to gain the program execution flow, and try to reentrant other functions in the loan contract to mess up the internal states. Similarly, in line 215, the borrower can register a `tokensReceived` hook in the token contract of `liquidityAsset`, which is called when the funds are transferred to him.\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\n\nAdding `ReentrancyGuard` in critial functions that involves ERC20 token transferring.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-maple-findings",
      "repo": "https://github.com/code-423n4/2021-04-maple-findings",
      "url": "https://github.com/code-423n4/2021-04-maple-findings/issues/115"
    }
  },
  {
    "title": "Not ERC20 Compliant",
    "severity": "minor",
    "body": "# Handle\n\njanbro\n\n\n# Vulnerability details\n\n## Summary\nCode is not technically ERC20 compliant.\n\n## Risk Rating\nLow\n\n## Vulnerability Details\nLoan.sol\nLine 511: return amt.mul(10 ** 18).div(10 ** IERC20Details(address(liquidityAsset)).decimals());\nPool.sol\nLine 547: return amt.mul(WAD).div(10 ** liquidityAssetDecimals);\nLoanLib.sol\nLine 247: return amt.mul(10 ** 18).div(10 ** liquidityAsset.decimals());\n\nERC20 tokens aren't guaranteed to implement ERC20Detailed standard on chain as it's optional. \"OPTIONAL - This method can be used to improve usability, but interfaces and other contracts MUST NOT expect these values to be present.\" See https://eips.ethereum.org/EIPS/eip-20#methods.\n\n## Impact\nSome ERC20 tokens may not be supported.\n\n## Tools Used\nManual code review\n\n## Recommended Mitigation Steps\nAcknowledge liquidity assets must implement decimals function.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-maple-findings",
      "repo": "https://github.com/code-423n4/2021-04-maple-findings",
      "url": "https://github.com/code-423n4/2021-04-maple-findings/issues/108"
    }
  },
  {
    "title": "Allowance Double-Spend Exploit",
    "body": "# Handle\n\n@cmichelio\n\n\n# Vulnerability details\n\n## Vulnerability Details\n\nThe `Pool.deposit` function and the LPs are vulnerable to the [allowance double-spend exploit](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/b4f87bb8fc25fb07f73099701e39e167a3d36465/contracts/token/ERC20/ERC20.sol#L71-L78).\n\n## Impact\n\nThe approver might spend both the old and the new allowance instead of just the new allowance.\n\n## Recommended Mitigation Steps\n\nConsider the risk and use functions that increase/decrease the allowance relative to its current value, such as `increaseAllowance()` and `decreaseAllowance()`.\n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-maple-findings",
      "repo": "https://github.com/code-423n4/2021-04-maple-findings",
      "url": "https://github.com/code-423n4/2021-04-maple-findings/issues/89"
    }
  },
  {
    "title": "Possible sandwich-attack when treasury converts tokens",
    "body": "# Handle\n\n@cmichelio\n\n\n# Vulnerability details\n\n## Vulnerability Details\n\nAs the docs say:\n\n> If the MapleTreasury collects fees from a Loan drawdown that was performed with WBTC, it can swap WBTC to USDC so that it can distribute those funds to token holders.\n\nWhen this trade is observed, it can be [sandwich-attacked](https://cmichel.io/de-fi-sandwich-attacks/) by arbitrage bots observing the mem pool.\n> Upon observing a trade of asset X for asset Y, an attacker frontruns the victim trade by also buying asset Y, lets the victim execute the trade, and then backruns (executes after) the victim by trading back the amount gained in the first trade. Intuitively, one uses the knowledge that someone’s going to buy an asset, and that this trade will increase its price, to make a profit. \n\nThe default max slippage (`_globals.maxSwapSlippage()`) is set to 10% and is too high which makes attacks profitable compared to the swap fees the attacker would have to pay:\n\n```solidity\nmaxSwapSlippage      = 1000;       // 10 %\n```\n\n\n## Impact\n\nThe attacker's profit is the treasury's loss and would result in the Maple treasury receiving fewer tokens than at market price.\n\n## Recommended Mitigation Steps\n\nSet a max slippage to at most 1% and add a second parameter to `convertERC20` that allows specifying the amount of tokens to trade at once, instead of the whole amount.\nA lower trade size (chosen according to the swap pool's reserves) makes sandwich attacks not profitable.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-maple-findings",
      "repo": "https://github.com/code-423n4/2021-04-maple-findings",
      "url": "https://github.com/code-423n4/2021-04-maple-findings/issues/88"
    }
  },
  {
    "title": "sweepToken() function removed in CErc20.sol from original Compound code",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nThe sweepToken() function in the original Compound code whose specified purpose was to recover accidentally sent ERC20 tokens to contract has been removed. \n\nThe original code comment says: “A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock).” This safety measure is helpful given the number/value of accidentally stuck tokens that are sent to contracts by mistake.\n\nTokens accidentally sent to this contract will be stuck leading to fund loss for sender.\n\n## Proof of Concept\n\nhttps://github.com/compound-finance/compound-protocol/blob/b9b14038612d846b83f8a009a82c38974ff2dcfe/contracts/CErc20.sol#L112-L120\n\nhttps://github.com/code-423n4/2021-04-basedloans/blob/5c8bb51a3fdc334ea0a68fd069be092123212020/code/contracts/CErc20.sol#L109-L121\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRetain this function unless there is a specific reason to remove it here.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-basedloans-findings",
      "repo": "https://github.com/code-423n4/2021-04-basedloans-findings",
      "url": "https://github.com/code-423n4/2021-04-basedloans-findings/issues/17"
    }
  },
  {
    "title": "ERC20 specification declares decimals as uint8 type",
    "body": "# Handle\n\npaulius.eth\n\n\n# Vulnerability details\n\n## Impact\niERC20 decimals field is declared as uint, but to be exact, ERC20 specification declares decimals as uint8. Anyway, this has no security impact as 18 decimals is set which fits in uint8.\n\n## Recommended Mitigation Steps\nYou can refactor to uint8 or just be informed about such compatibility guidelines.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-04-vader-findings",
      "repo": "https://github.com/code-423n4/2021-04-vader-findings",
      "url": "https://github.com/code-423n4/2021-04-vader-findings/issues/283"
    }
  },
  {
    "title": "NFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault",
    "severity": "major",
    "body": "# Handle\n\njvaqa\n\n\n# Vulnerability details\n\nNFTXLPStaking Is Subject To A Flash Loan Attack That Can Steal Nearly All Rewards/Fees That Have Accrued For A Particular Vault\n\n## Impact\n\nThe LPStaking contract does not require that a stake be locked for any period of time.\n\nThe LPStaking contract also does not track how long your stake has been locked.\n\nSo an attacker Alice can stake, claim rewards, and unstake, all in one transaction.\n\nIf Alice utilizes a flash loan, then she can claim nearly all of the rewards for herself, leaving very little left for the legitimate stakers.\n\nThe fact that the NFTXVaultUpgradeable contract contains a native flashLoan function makes this attack that much easier, although it would still be possible even without that due to flashloans on Uniswap, or wherever else the nftX token is found.\n\nSince a flash loan will easily dwarf all of the legitimate stakers' size of stake, the contract will erroneously award nearly all of the rewards to Alice.\n\n## Proof of Concept\n\n(1) Wait until an NFTX vault has accrued any significant amount of fees/rewards\n(2) FlashLoanBorrow a lot of ETH using any generic flash loan provider\n(3) FlashLoanBorrow a lot of nftx-vault-token using NFTXVaultUpgradeable.flashLoan()\n(4) Deposit the ETH and nftx-vault-token's into Uniswap for Uniswap LP tokens by calling Uniswap.addLiquidity()\n(5) Stake the Uniswap LP tokens in NFTXLPStaking by calling NFTXLPStaking.deposit()\n(6) Claim nearly all of the rewards that have accrued for this vault due to how large the flashLoaned deposit is relative to all of the legitimate stakes by calling NFTXLPStaking.claimRewards()\n(7) Remove LP tokens from NFTXLPStaking by calling NFTXLPStaking.exit();\n(8) Withdraw ETH and nftx-vault-token's by calling Uniswap.removeLiquidity();\n(9) Pay back nftx-vault-token flash loan\n(10) Pay back ETH flash loan\n\nHere is an example contract that roughly implements these steps in pseudocode:\n\ncontract AliceAttackContract {\n\n\n    bytes32 constant private NFTX_FLASH_LOAN_RETURN_VALUE = keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n\n    uint256 largeAmountOfEther = 10_000 ether;\n\n\n    uint256 targetVaultId;\n\n\n    address targetVaultAddress;\n\n\n    // attackVaultWithId calls onEthFlashLoan(), which subsequently calls NFTX's onFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function attackVaultWithId(uint256 vaultId, address vaultAddress) external {\n\n        targetVaultId = vaultId;\n        targetVaultAddress = vaultAddress;\n\n        EthFlashLoanProvider.borrowFlashLoan(largeAmountOfEther); /* this calls onEthFlashLoan() in between mint and burn */\n\n    }\n\n\n    // onEthFlashLoan is called by the line EthFlashLoanProvider.borrowFlashLoan() in attackVaultWithId() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n\n    function onEthFlashLoan(...) external {\n\n        NFTXVaultUpgradeable(vaultAddress).flashLoan( /* this calls onFlashLoan() in between mint and burn */\n            address(this),\n            vaultAddress,\n            NFTXVaultUpgradeable(vaultAddress).maxFlashLoan(vaultAddress),\n            ''\n        );\n\n    }\n\n    // onFlashLoan is called by the line NFTXVaultUpgradeable.flashLoan() in onEthFlashLoan() (flashloans use a callback structure in order to revert if the flash loan is not paid back).\n    function onFlashLoan(address sender, address token, uint256 amount, uint256 fee, bytes data) external {\n\n        UniswapRouter(uniswapRouterAddress).addLiquidity(token, etherAddress, amount, ...);\n\n        uint256 lpTokenBalance = ERC20(uniswapLPAddress).balanceOf(address(this));\n        ERC20(token).approve(nftxLpStakingAddress, lpTokenBalance);\n        NFTXLPStaking(nftxLpStakingAddress).deposit(targetVaultId, lpTokenBalance);\n\n        NFTXLPStaking(nftxLpStakingAddress).claimRewards(targetVaultId);\n\n        NFTXLPStaking(nftxLpStakingAddress).exit(targetVaultId);\n\n        UniswapRouter(uniswapRouterAddress).removeLiquidity(token, etherAddress, amount, ...);\n\n        return NFTX_FLASH_LOAN_RETURN_VALUE;\n    }\n\n}\n\n\n## Recommended Mitigation Steps\n\nRequire that staked LP tokens be staked for a particular period of time before they can be removed. Although a very short time frame (a few blocks) would avoid flash loan attacks, this attack could still be performed over the course of a few blocks less efficiently. Ideally, you would want the rewards to reflect the product of the amount staked and the duration that they've been staked, as well as having a minimum time staked.\n\nAlternatively, if you really want to allow people to have the ability to remove their stake immediately, then only allow rewards to be claimed for stakes that have been staked for a certain period of time. Users would still be able to remove their LP tokens, but they could no longer siphon off rewards immediately.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-nftx-findings",
      "repo": "https://github.com/code-423n4/2021-05-nftx-findings",
      "url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/88"
    }
  },
  {
    "title": "The direct redeem fee can be circumvented",
    "severity": "medium",
    "body": "# Handle\n\njanbro\n\n\n# Vulnerability details\n\n## Summary\nThe direct redeem fee can be circumvented\n\n## Risk Rating\nMedium\n\n## Vulnerability Details\nSince the random NFT is determined in the same transaction a payment or swap is being executed, a malicious actor can revert a transaction if they did not get the NFT they wanted. Combined with utilizing Flashbots miners which do not publish transactions which revert with FlashbotsCheckAndSend, there would be no cost to constantly attempting this every block or after the nonce is updated from getPseudoRand().\n\nNFTXVaultUpgradeable.sol\n```\nLine 374: uint256 tokenId = i < specificIds.length\n                ? specificIds[i]\n                : getRandomTokenIdFromFund();\n```\n\n## Impact\nThe directReedemFee can be avoided and users lose on potential earnings.\n\n## Proof of Concept\nTransfer ownership of ERC20 tokens to attack contract\n```\nfunction revertIfNotSpecifiedID(uint256 targetTokenID) public {\n    NFTXVaultUpgradeable vault = NFTXVaultUpgradeable(_vault);\n    uint256[] resultID = vault.redeem(1,[]);\n    require(resultID[0] == targetTokenID);\n}\n```\n\n## Tools Used\nManual Code Review\n\n## Recommended Mitigation Steps\nUse a commit-reveal pattern for NFT swaps and redemptions\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-nftx-findings",
      "repo": "https://github.com/code-423n4/2021-05-nftx-findings",
      "url": "https://github.com/code-423n4/2021-05-nftx-findings/issues/71"
    }
  },
  {
    "title": "Gas optimizations by using external over public ",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nSome functions could use external instead of public in order to save gas.\n\nIf we run the following methods on Remix, we can see the difference\n```\n  //  transaction cost  21448 gas\n  //  execution cost    176 gas\n  function tt() external returns(uint256) {\n      return 0;\n  }\n\n  //  transaction cost  21558 gas\n  //  execution cost    286 gas\n  function tt_public() public returns(uint256) {\n      return 0;\n  }\n```\n\n```\nsurplusOfDeposit(uint256) should be declared external:\n        - DInterest.surplusOfDeposit(uint256) (contracts/DInterest.sol#623-648)\ndividendOf(uint256,address,address) should be declared external:\n        - ERC1155DividendToken.dividendOf(uint256,address,address) (contracts/libs/ERC1155DividendToken.sol#101-107)\nwithdrawnDividendOf(uint256,address,address) should be declared external:\n        - ERC1155DividendToken.withdrawnDividendOf(uint256,address,address) (contracts/libs/ERC1155DividendToken.sol#114-126)\nuri(uint256) should be declared external:\n        - ERC1155Upgradeable.uri(uint256) (contracts/libs/ERC1155Upgradeable.sol#92-94)\nbalanceOfBatch(address[],uint256[]) should be declared external:\n        - ERC1155Upgradeable.balanceOfBatch(address[],uint256[]) (contracts/libs/ERC1155Upgradeable.sol#124-143)\nsetApprovalForAll(address,bool) should be declared external:\n        - ERC1155Upgradeable.setApprovalForAll(address,bool) (contracts/libs/ERC1155Upgradeable.sol#148-160)\nsafeTransferFrom(address,address,uint256,uint256,bytes) should be declared external:\n        - ERC1155Upgradeable.safeTransferFrom(address,address,uint256,uint256,bytes) (contracts/libs/ERC1155Upgradeable.sol#178-190)\nsafeBatchTransferFrom(address,address,uint256[],uint256[],bytes) should be declared external:\n        - ERC1155Upgradeable.safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) (contracts/libs/ERC1155Upgradeable.sol#195-207)\nincreaseAllowance(address,uint256) should be declared external:\n        - ERC20Wrapper.increaseAllowance(address,uint256) (contracts/libs/ERC20Wrapper.sol#146-157)\ndecreaseAllowance(address,uint256) should be declared external:\n        - ERC20Wrapper.decreaseAllowance(address,uint256) (contracts/libs/ERC20Wrapper.sol#173-186)\nmint(address,uint256) should be declared external:\n        - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#7-9)\ndeposit(uint256) should be declared external:\n        - VaultMock.deposit(uint256) (contracts/mocks/VaultMock.sol#16-21)\nwithdraw(uint256) should be declared external:\n        - VaultMock.withdraw(uint256) (contracts/mocks/VaultMock.sol#23-29)\ndeposit(uint256) should be declared external:\n        - VaultWithDepositFeeMock.deposit(uint256) (contracts/mocks/VaultWithDepositFeeMock.sol#23-33)\nwithdraw(uint256) should be declared external:\n        - VaultWithDepositFeeMock.withdraw(uint256) (contracts/mocks/VaultWithDepositFeeMock.sol#35-41)\nupdateAndQuery() should be declared external:\n        - EMAOracle.updateAndQuery() (contracts/models/interest-oracle/EMAOracle.sol#55-84)\nquery() should be declared external:\n        - EMAOracle.query() (contracts/models/interest-oracle/EMAOracle.sol#86-88)\ninitialize() should be declared external:\n        - MPHToken.initialize() (contracts/rewards/MPHToken.sol#19-23)\nownerMint(address,uint256) should be declared external:\n        - MPHToken.ownerMint(address,uint256) (contracts/rewards/MPHToken.sol#26-33)\n```\n\n\n## Tools Used\n\nSlither\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-88mph-findings",
      "repo": "https://github.com/code-423n4/2021-05-88mph-findings",
      "url": "https://github.com/code-423n4/2021-05-88mph-findings/issues/18"
    }
  },
  {
    "title": "Deflationary tokens are not considered in time-locked ERC20 functions",
    "severity": "minor",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe functions `timeLockERC20` and `timeUnlockERC20` do not consider deflationary tokens, which burn a percentage of the transferred amount during transfers. In that case, time-locked deflationary ERC20 tokens cannot be unlocked (by `timeUnlockERC20`) nor transferred out of the vault (by `transferERC20`), since the transferred amount exceeds the vault's balance.\n\n## Proof of Concept\n\nReferenced code:\n[Visor.sol#L583-L639](https://github.com/code-423n4/2021-05-visorfinance/blob/main/contracts/contracts/visor/Visor.sol#L583-L639)\n\n## Tools Used\n\nNone\n\n## Recommended Mitigation Steps\n\nIn function `timeLockERC20`, after the function `transferFrom`, the vault should get the actual receieved amount by `token.balanceOf(address(this)).sub(tokenAmountBeforeTransfer)`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/78"
    }
  },
  {
    "title": "Gas optimizations - calculation getBalanceLocked",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nIn Visor.sol, the function `getBalanceLocked` returns the amount locked.\nThis method do will O(n) to return the highest locked value.\n\n```\n    function getBalanceLocked(address token)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        uint256 count = _lockSet.length();\n        for (uint256 index; index < count; index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n\n            //FIXME: Shouldn't be incremental\n            if (_lockData.token == token && _lockData.balance > balance)\n                balance = _lockData.balance;\n        }\n        return balance;\n    }\n\n```\n\nBut this method is only being used to verify that there is an X amount of tokens locked.\n```\n        require(\n            IERC20(token).balanceOf(address(this)) >=\n                (getBalanceLocked(token).add(amount)).add(\n                    timelockERC20Balances[token]\n                ),\n            \"UniversalVault: insufficient balance\"\n        );\n       \n        require(\n            IERC20(token).balanceOf(address(this)) >=\n                (getBalanceLocked(token).add(amount)).add(\n                    timelockERC20Balances[token]\n                ),\n            \"UniversalVault: insufficient balance\"\n        );\n\n        require(\n            IERC20(token).balanceOf(address(this)) >=\n                getBalanceLocked(token).add(amount),\n            \"Insufficient balance\"\n        );\n\n\n```\n\nSo, instead of doing O(n), we could just exit when we found that balance >= amount requested. Something like:\n\n```\n    function enoughBalanceLocked(address token, uint256 amount)\n        public\n        view\n        override\n        returns (uint256 balance)\n    {\n        if (totalBalanceLocked == amount) return true;\n\n        for (uint256 index; index < _lockSet.length(); index++) {\n            LockData storage _lockData = _locks[_lockSet.at(index)];\n            if (_lockData.token == token && _lockData.balance > amount) {\n                return true;\n            }\n        }\n        return false;\n    }\n```\n\n## Tools Used\n\nNone \n\n## Recommended Mitigation Steps\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/55"
    }
  },
  {
    "title": "Gas optimizations by using external over public ",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nUsing public over external has an impact on execution cost.\n\nIf we run the following methods on Remix, we can see the difference \n```\n    //  transaction cost\t21448 gas \n    //  execution cost\t176 gas \n    function tt() external returns(uint256) {\n        return 0;\n    }\n    \n    //  transaction cost\t21558 gas \n    //  execution cost\t286 gas\n    function tt_public() public returns(uint256) {\n        return 0;\n    }\n```\n\nThe following are methods that currently use public and should be declared external\n\n```\nstake(address,address,uint256,bytes) should be declared external:\n        - Mainframe.stake(address,address,uint256,bytes) (contracts/Mainframe.sol#158-171)\ngetCurrentVaultStakeUnits(address) should be declared external:\n        - Hypervisor.getCurrentVaultStakeUnits(address) (contracts/hypervisor/Hypervisor.sol#576-586)\ngetPowerSwitch() should be declared external:\n        - Powered.getPowerSwitch() (contracts/hypervisor/Powered.sol#67-74)\nnft() should be declared external:\n        - OwnableERC721.nft() (contracts/visor/OwnableERC721.sol#23-25)\ngetTimeLockCount(address) should be declared external:\n        - Visor.getTimeLockCount(address) (contracts/visor/Visor.sol#305-310)\ngetTimeLockERC721Count(address) should be declared external:\n        - Visor.getTimeLockERC721Count(address) (contracts/visor/Visor.sol#312-318)\nsetURI(string) should be declared external:\n        - Visor.setURI(string) (contracts/visor/Visor.sol#469-471)\ntimeLockERC721(address,address,uint256,uint256) should be declared external:\n        - Visor.timeLockERC721(address,address,uint256,uint256) (contracts/visor/Visor.sol#647-673)\ntimeUnlockERC721(address,address,uint256,uint256) should be declared external:\n        - Visor.timeUnlockERC721(address,address,uint256,uint256) (contracts/visor/Visor.sol#685-708)\ntimeLockERC20(address,address,uint256,uint256) should be declared external:\n        - Visor.timeLockERC20(address,address,uint256,uint256) (contracts/visor/Visor.sol#718-749)\ntimeUnlockERC20(address,address,uint256,uint256) should be declared external:\n        - Visor.timeUnlockERC20(address,address,uint256,uint256) (contracts/visor/Visor.sol#761-782)\naddTemplate(bytes32,address) should be declared external:\n        - VisorFactory.addTemplate(bytes32,address) (contracts/visor/VisorFactory.sol#26-35)\nsetActive(bytes32) should be declared external:\n        - VisorFactory.setActive(bytes32) (contracts/visor/VisorFactory.sol#37-41)\ncreateSelected(bytes32) should be declared external:\n        - VisorFactory.createSelected(bytes32) (contracts/visor/VisorFactory.sol#69-85)\ncreateSelected2(bytes32,bytes32) should be declared external:\n        - VisorFactory.createSelected2(bytes32,bytes32) (contracts/visor/VisorFactory.sol#87-107)\nnameCount() should be declared external:\n        - VisorFactory.nameCount() (contracts/visor/VisorFactory.sol#160-162)\nvaultCount(address) should be declared external:\n        - VisorFactory.vaultCount(address) (contracts/visor/VisorFactory.sol#164-166)\ngetUserVault(address,uint256) should be declared external:\n        - VisorFactory.getUserVault(address,uint256) (contracts/visor/VisorFactory.sol#168-174)\n```\n## Tools Used\n\nSlither\n\n## Recommended Mitigation Steps\n\nJust change from public to external if possible\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/51"
    }
  },
  {
    "title": "Wrong TimeLockERC20 event emitted",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n\n## Vulnerability Details\n\nThe `Visor.timeLockERC721` function emits the `TimeLockERC20` event but should emit `TimeLockERC721` instead.\n\n## Impact\n\nIt allows tricking the backend into registering ERC20 token transfers that never happened which could lead to serious issues when something like an accounting app uses this data.\n\n## Recommended Mitigation Steps\n\nEmit the correct event.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/45"
    }
  },
  {
    "title": "Unhandled return value of transferFrom in timeLockERC20() could lead to fund loss for recipients",
    "severity": "medium",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nERC20 implementations are not always consistent. Some implementations of transfer and transferFrom could return ‘false’ on failure instead of reverting. It is safer to wrap such calls into require() statements or use safe wrapper functions implementing return value/data checks to handle these failures. For reference, see similar Medium-severity finding from Consensys Diligence Audit of Aave Protocol V2: https://consensys.net/diligence/audits/2020/09/aave-protocol-v2/#unhandled-return-values-of-transfer-and-transferfrom\n\nWhile the contract uses Uniswap’s TransferHelper library functions safeTransfer in other places for ERC20 tokens or OpenZeppelin’s saferTransferFrom for ERC721 tokens (both of which call the token’s transfer/transferFrom functions and check return value for success and return data), it misses using TransferHelper.safeTransferFrom in this one case on L610 in timeLockERC20() when tokens are transferred from owner to the vault and instead directly uses the token’s transferFrom() call without checking for its return value.\n\nThe impact can be that for an arbitrary ERC20 token, this transferFrom() call may return failure but the vault logic misses that, assumes it was successfully transferred into the vault and updates the timelockERC20Balances  accounting accordingly. The timeUnlockERC20(), transferERC20() or delegatedTransferERC20() calls for that token will fail because the vault contract balance would have less tokens than accounted for in timelockERC20Balances because of the previously failed (but ignored) transferFrom() call.\n\n\n## Proof of Concept\n\n1. Let’s say Alice owes Bob 100 USD after a week, for which they agree that Alice will pay in 100 tokens of USD stablecoin tokenA.\n2. Alice, the vault owner, calls timeLockERC20() for recipient=Bob, token=tokenA, amount=100 and expiry=1-week-from-then (corresponding Unix timestamp) but tokenA’s implementation does not revert on failure but instead returns true/false. If the transferFrom failed, say because Alice did not have those 100 tokenAs, the return value is ignored on L610 in timeLockERC20() and vault logic considers that it indeed has 100 tokenAs locked for Bob.\n3. Bob looks at the TimeLockERC20 event emitted in the successful timeLockERC20() transaction from Alice and assumes 100 tokenAs are indeed locked by Alice in the vault for him which can be withdrawn after expiry.\n4. After timelock expiry, Bob tries to transfer the 100 tokenAs Alice locked in the vault for him. The TransferHelper.safeTransfer() call on L637 in timeUnlockERC20() fails because the vault has 0 tokenAs because they were never successfully transferred in Step 2.\n5. Bob could thus be tricked into thinking that 100 tokenAs are locked in the vault for him by Alice but they never were. This leads to loss of funds for Bob.\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L610\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L637\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nReplace use of IERC20(token).transferFrom(msg.sender, address(this), amount); on L610 with:\n\nTransferHelper.safeTransferFrom(token, msg.sender, address(this), amount); as shown in\n\nhttps://github.com/Uniswap/uniswap-lib/blob/c01640b0f0f1d8a85cba8de378cc48469fcfd9a6/contracts/libraries/TransferHelper.sol#L33-L45\n\nThis will revert on transfer failure for e.g. if msg.sender does not have a token balance >= amount. \n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/39"
    }
  },
  {
    "title": "Timelock keys are never removed after unlocks",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\ntimelockERC20Keys and timelockERC721Keys are used to keep track of number of timelocks for ERC20 and ERC721 tokens. While timelockERC20() and timelockERC721() functions update these data structures to add the new timelocks, the corresponding unlock functions do not remove the expired timelocks.\n\nThis results in their getter functions getTimeLockCount() and getTimeLockERC721Count() returning the number of all timelocks ever held instead of the expected number of timelocks that are currently active.\n\n\n## Proof of Concept\n\nLet’s say 5 timelocks are creates for a specific ERC20 token of which 3 have been unlocked after expiry. The getter function getTimeLockCount() incorrectly reports 5 instead of 2.\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L82\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L92\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L550\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L608\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L247-L255\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove unlocked keys from timelockERC20Keys and timelockERC721Keys in timeUnlockERC20() and timeUnlockERC721() functions. \n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/37"
    }
  },
  {
    "title": "Use a temporary variable to cache repetitive complex calculation",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nIn function delegatedTransferERC20(), the complex calculation keccak256(abi.encodePacked(msg.sender, token)) is performed three times in three different places in the function. This consumes a lot of unnecessary gas which can be saved by saving the calculation in a temporary bytes32 variable and using that instead.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L450\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L459\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nSave keccak256(abi.encodePacked(msg.sender, token)) in a temporary bytes32 variable and use that in all places.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/30"
    }
  },
  {
    "title": "Change function visibility from public to external",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nFunctions getTimeLockCount(), getTimeLockERC721Count(), timeLockERC721(), timeUnlockERC721(), timeLockERC20() and timeUnlockERC20() are never called from within contracts but yet declared public. Their visibility can be made external to save gas.\n\nAs described in https://mudit.blog/solidity-gas-optimization-tips/: “For all the public functions, the input parameters are copied to memory automatically, and it costs gas. If your function is only called externally, then you should explicitly mark it as external. External function’s parameters are not copied into memory but are read from calldata directly. This small optimization in your solidity code can save you a lot of gas when the function input parameters are huge.”\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L248\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L253\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L529\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L561\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L583\n\nhttps://github.com/code-423n4/2021-05-visorfinance/blob/e0f15162a017130aa66910d46c70ee074b64dd40/contracts/contracts/visor/Visor.sol#L619\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nChange function visibility from public to external\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/27"
    }
  },
  {
    "title": "delegatedTransferERC20 can revert when called by owner",
    "severity": "minor",
    "body": "# Handle\n\ngpersoon\n\n\n# Vulnerability details\n\n## Impact\nIf the function delegatedTransferERC20 is called from the owner  (e.g. msg.sender == _getOwner ) then \nerc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] doesn't have to set, so it can have the value of 0.\n\nIf you then subtract the amount, you will get an error and the code will revert:\nerc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n\nA work around would be to call approveTransferERC20 also for the owner.\n\n## Proof of Concept\n function delegatedTransferERC20(address token,address to,uint256 amount) external {\n        if(msg.sender != _getOwner()) {\n            require(erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] >= amount,\"Account not approved to transfer amount\");\n        } \n        // check for sufficient balance\n        require(IERC20(token).balanceOf(address(this)) >= (getBalanceLocked(token).add(amount)).add(timelockERC20Balances[token]),\"UniversalVault: insufficient balance\");\n\n        erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n        \n        // perform transfer\n        TransferHelper.safeTransfer(token, to, amount);\n    }\n## Tools Used\nEditor\n\n## Recommended Mitigation Steps\nAlso add \n   if(msg.sender != _getOwner()) \nbefore \n   erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))] = erc20Approvals[keccak256(abi.encodePacked(msg.sender, token))].sub(amount);\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/21"
    }
  },
  {
    "title": "sandwich approveTransferERC20",
    "severity": "minor",
    "body": "# Handle\n\npaulius.eth\n\n\n# Vulnerability details\n\n## Impact\nfunction approveTransferERC20 is vulnerable to the sandwich attack. Similar to the erc20 approve issue described here: https://blog.smartdec.net/erc20-approve-issue-in-simple-words-a41aaf47bca6 \nA malicious delegate can scout for a approveTransferERC20 change and sandwich that (delegatedTransferERC20 amount A, approveTransferERC20 amount A->B, delegatedTransferERC20 amount B). It is more of a theoreticall issue and mostly depends on the honesty of the delegators. If we can assume that delegators are trustable actors, then this is very unlikely to happen.\n\n## Recommended Mitigation Steps\nPossible mitigation could be to replace approveTransferERC20 with increasing/decreasing functions.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-visorfinance-findings",
      "repo": "https://github.com/code-423n4/2021-05-visorfinance-findings",
      "url": "https://github.com/code-423n4/2021-05-visorfinance-findings/issues/10"
    }
  },
  {
    "title": "Check if variables are initialized",
    "severity": "minor",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nA variable named fairSideConviction is set in the contract FSD function setFairSideConviction. However, functions that use this variable do not check if it is already initialized. For example, function tokenizeConviction in contract ERC20ConvictionScore may transfer tokens to the 0x0 address:\n   _transfer(msg.sender, address(fairSideConviction), locked);\nThis will make these tokens inaccessible and basically burned. It would be better if the code explicitly checked before that address(fairSideConviction) != address(0). Rating this as low cuz I expect that in practice these variables will be initialized as soon as possible.\n\nAlso, this may be an additional small issue but I think it would make sense if functions setFairSideConviction and setFairSideNetwork do explicitly check that the parameter is not 0x0 address as theoretically it is possible to invoke these functions again and again when the address is empty.\n\n## Recommended Mitigation Steps\nrequire address(fairSideConviction) != address(0) where this variable is used. Same can be applied to fsdNetwork variable.\n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/59"
    }
  },
  {
    "title": "Gas optimizations - checkpoints from ERC20ConvictionScore",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nIn `ERC20ConvictionScore.sol`, we store\n\n```\n    // Conviction score based on # of days multiplied by # of FSD & NFT\n    // @notice A record of conviction score checkpoints for each account, by index\n    mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n    // @notice The number of checkpoints for each account\n    mapping(address => uint32) public numCheckpoints;\n``\n\nThese two state variables are used in the following way:\n\n```\nfunction _updateConvictionScore(address user, int256 amount)\n        internal\n        returns (uint224 convictionDelta, uint224 governanceDelta)\n    {\n        if (user == address(0)) return (0, 0);\n\n        uint256 balance = balanceOf(user);\n\n        uint32 userNum = numCheckpoints[user];\n        uint256 ts =\n            userNum > 0\n                ? block.timestamp - checkpoints[user][userNum - 1].ts\n                : 0;\n        convictionDelta = safe224(\n            balance.mul(ts) / 1 days,\n            \"ERC20ConvictionScore::_updateConvictionScore: Conviction score has reached maximum limit\"\n        );\n\n        bool hasMinimumGovernanceBalance =\n            (int256(balance) + amount) >= governanceMinimumBalance;\n\n        if (convictionDelta != 0) {\n            uint224 userOld =\n                userNum > 0\n                    ? checkpoints[user][userNum - 1].convictionScore\n                    : 0;\n            uint224 userNew =\n                add224(\n                    userOld,\n                    convictionDelta,\n                    \"ERC20ConvictionScore::_updateConvictionScore: conviction score amount overflows\"\n                );\n            _writeCheckpoint(user, userNum, userNew);\n\n            if (address(fairSideConviction) == user)\n                return (convictionDelta, 0);\n\n            if (\n                !isGovernance[user] &&\n                userNew >= governanceThreshold &&\n                hasMinimumGovernanceBalance\n            ) {\n                isGovernance[user] = true;\n                governanceDelta = userNew;\n            } else if (isGovernance[user]) {\n                if (hasMinimumGovernanceBalance)\n                    governanceDelta = convictionDelta;\n                else {\n                    isGovernance[user] = false;\n                    governanceDelta = getPriorConvictionScore(\n                        user,\n                        block.number - 1\n                    );\n                }\n            }\n        }\n    }\n```\n\nChecking the contract seems like using `mapping(address => Checkpoint[]) public checkpoints;` would provide the same functionality while using less storage.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/54"
    }
  },
  {
    "title": "`ERC20ConvictionScore.acquireConviction` implements wrong governance checks",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\n\nThere are two issues with the governance checks when acquiring them from an NFT:\n\n#### Missing balance check\nThe governance checks in `_updateConvictionScore` are:\n\n```solidity\n!isGovernance[user]\n&& userConvictionScore >= governanceThreshold \n&& balanceOf(user) >= governanceMinimumBalance;\n```\n\nWhereas in `acquireConviction`, only `userConvictionScore >= governanceThreshold` is checked but not `&& balanceOf(user) >= governanceMinimumBalance`.\n\n```solidity\nelse if (\n    !isGovernance[msg.sender] && userNew >= governanceThreshold\n) {\n    isGovernance[msg.sender] = true;\n}\n```\n\n#### the `wasGovernance` might be outdated\n\nThe second issue is that at the time of NFT creation, the `governanceThreshold` or `governanceMinimumBalance` was different and would not qualify for a governor now.\nThe NFT's governance state is blindly appplied to the new user:\n\n```solidity\nif (wasGovernance && !isGovernance[msg.sender]) {\n    isGovernance[msg.sender] = true;\n}\n```\n\nThis allows a user to circumvent any governance parameter changes by front-running the change with an NFT creation.\n\n## Impact\nIt's easy to circumvent the balance check to become a governor by minting and redeeming your own NFT.\nOne can also circumvent any governance parameter increases by front-running these actions with an NFT creation and backrunning with a redemption.\n\n## Recommended Mitigation Steps\nAdd the missing balance check in `acquireConviction`.\nRemove the `wasGovernance` governance transfer from the NFT and solely recompute it based on the current `governanceThreshold` / `governanceMinimumBalance` settings.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/45"
    }
  },
  {
    "title": "`ERC20ConvictionScore` allows transfers to special TOTAL_GOVERNANCE_SCORE address",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe credit score of the special `address(type(uint160).max)` is supposed to represent the sum of the credit scores of all users that are governors.\nBut any user can directly transfer to this address increasing its balance and accumulating a credit score in `_updateConvictionScore(to=address(uint160.max), amount)`.\nIt'll first write a snapshot of this address' balance which should be very low:\n\n```solidity\n// in _updateConvictionScore\n_writeCheckpoint(user, userNum, userNew) = _writeCheckpoint(TOTAL_GOVERNANCE_SCORE, userNum, checkpoints[user][userNum - 1].convictionScore + convictionDelta);\n```\n\nThis address then accumulates a score based on its balance which can be updated using `updateConvictionScore(uint160.max)` and breaks the invariant.\n\n## Impact\nIncreasing it might be useful for non-governors that don't pass the voting threshold and want to grief the proposal voting system by increasing the `quorumVotes` threshold required for proposals to pass. (by manipulating `FairSideDAO.totalVotes`). `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\n## Recommended Mitigation Steps\nDisallow transfers from/to this address. Or better, track the total governance credit score in a separate variable, not in an address.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/42"
    }
  },
  {
    "title": "`ERC20ConvictionScore._updateConvictionScore` uses stale credit score for `governanceDelta`",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nIn `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore, the `governanceDelta` is the old conviction score of the previous block.\n\n```solidity\nisGovernance[user] = false;\ngovernanceDelta = getPriorConvictionScore(\n    user,\n    block.number - 1\n);\n```\n\nThe user could increase their conviction / governance score first in the same block and then lose their status in a second transaction, and the total governance conviction score would only be reduced by the previous score.\n\nExample:\nBlock n - 10000: User is a governor and has a credit score of 1000 which was also contributed to the `TOTAL_GOVERNANCE_SCORE`\nBlock n:\n- User updates their own conviction score using public `updateConvictionScore` function which increases the credit score by 5000 based on the accumulated time. The total governance credit score increased by 5000, making the user contribute 6000 credit score to governance in total.\n- User transfers their whole balance away, the balance drops below `governanceMinimumBalance` and user is not a governor anymore. The `governanceDelta` update of the transfer should be 6000 (user's whole credit score) but it's only `1000` because it takes the snapshot of block n - 1.\n\n## Impact\nThe `TOTAL_GOVERNANCE_SCORE` score can be inflated this way and break the voting mechanism in the worst case as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\n## Recommended Mitigation Steps\nUse the current conviction store which should be `governanceDelta = checkpoints[user][userCheckpointsLength - 1].convictionScore`\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/41"
    }
  },
  {
    "title": "`ERC20ConvictionScore`'s `governanceDelta` should be subtracted when user is not a governor anymore",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `TOTAL_GOVERNANCE_SCORE` is supposed to track the sum of the credit scores of all governors.\n\nIn `ERC20ConvictionScore._updateConvictionScore`, when the user does not fulfill the governance criteria anymore and is therefore removed, the `governanceDelta` should be negative but it's positive.\n\n```solidity\nisGovernance[user] = false;\ngovernanceDelta = getPriorConvictionScore(\n    user,\n    block.number - 1\n);\n```\n\nIt then gets added to the new total:\n\n```solidity\nuint224 totalGCSNew =\n    add224(\n        totalGCSOld,\n        governanceDelta,\n        \"ERC20ConvictionScore::_updateConvictionTotals: conviction score amount overflows\"\n    );\n```\n\n## Impact\nThe `TOTAL_GOVERNANCE_SCORE` tracks wrong data leading to issues throughout all contracts like wrong `FairSideDAO.totalVotes` data which can then be used for anyone to pass proposals in the worst case.\nOr `totalVotes` can be arbitrarily inflated and break the voting mechanism as no proposals can reach the quorum (percentage of `totalVotes`) anymore.\n\n## Recommended Mitigation Steps\nReturn a negative, signed integer for this case and add it to the new total.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/40"
    }
  },
  {
    "title": "NFTs can never be redeemed back to their conviction scores leading to lock/loss of funds ",
    "severity": "major",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nBesides the conviction scores of users, there appears to be tracking of the FairSide protocol’s tokenized conviction score as a whole (using fscAddress = address(fairSideConviction)). This is evident in the attempted reduction of the protocol’s score when a user acquires conviction back from a NFT. However, the complementary accrual of user's conviction score to fscAddress when user tokenizes their conviction score to mint a NFT is missing in tokenizeConviction().\n\nBecause of this missing updation of conviction score to fscAddress on tokenization, there are no checkpoints written for fscAddress and there also doesn’t appear to be any initialization for bootstrapping this address’s conviction score checkpoints. As a result, the sub224() on Line350 of ERC20ConvictionScore.sol will always fail with an underflow because fscOld = 0 (because fscNum = 0) and convictionScore > 0, effectively reverting all calls to acquireConviction().\n\nThe impact is that all tokenized NFTs can never be redeemed back to their conviction scores and therefore leads to lock/loss of FSD funds for users who tokenized/sold/bought FairSide NFTs.\n\n\n## Proof of Concept\n\n1. Alice tokenizes her conviction score into a NFT. She sells that NFT to Bob who pays an amount commensurate with the conviction score captured by that NFT (as valued by the market) and any FSDs locked with the NFT. \n\n2. Bob then attempts to redeem the bought NFT back to the conviction score to use it on FairSide network. But the call to acquireConviction() fails. Bob is never able to redeem Alice’s NFT and has lost the funds used to buy it.\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L343-L355\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd appropriate logic to bootstrap+initialize fscAddress’s tokenized conviction score checkpoints and update it during tokenization.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/31"
    }
  },
  {
    "title": "Locked funds from tokenization are credited twice to user leading to protocol fund loss",
    "severity": "major",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nThe tokens optionally locked during tokenization are released twice on acquiring conviction back from a NFT. (The incorrect double debit of locked funds during tokenization has been filed as a separate finding because it is not necessarily related and also occurs in a different part of the code.)\n\nWhen a user wants to acquire back the conviction score captured by a NFT, the FSD tokens locked, if any, are released to the user as well. However, this is incorrectly done twice. Released amount is transferred once on Line123 in _release() (via acquireConviction -> burn) of FairSideConviction.sol and again immediately after the burn on Line316 in acquireConviction() of ERC20ConvictionScore.sol.\n\nThis leads to loss of protocol funds.\n\n## Proof of Concept\n\nAlice tokenizes her conviction score into a NFT and locks 100 FSDs. Bob buys the NFT from Alice and acquires the conviction score back from the NFT. But instead of 100 FSDs that were supposed to be locked with the NFT, Bob receives 100+100 = 200 FSDs from FairSide protocol.\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L123\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L314-L316\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove the redundant transfer of FSD tokens from protocol to user on Line316 in acquireConviction() of ERC20ConvictionScore.sol.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/30"
    }
  },
  {
    "title": "Locked funds are debited twice from user during tokenization leading to fund loss",
    "severity": "major",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nDuring tokenization of conviction scores, the user can optionally provide FSDs to be locked to let it continue conviction accrual. However, the amount of FSDs specified for locking are debited twice from the user leading to fund loss for user.\n\nThis, in effect, forces the user to unknowingly and unintentionally lock twice the amount of FSD tokens, leading to a loss of the specified ‘locked’ number of tokens.\n\n## Proof of Concept\n\nAlice decides to tokenise her conviction score into an NFT and specifies 100 FSD tokens to be locked in her call to tokenizeConviction(100). 100 FSD tokens are transferred from her FSD balance to FairSideConviction contract on Line282 of ERC20ConvictionScore.sol. However, in FairSideConviction.createConvictionNFT(), the specified locked amount is transferred again from Alice to the contract on Line50 of FairSideConviction.sol.\n\nThe impact is that Alice wanted to lock only 100 FSD token but the FairSide protocol has debited 200 tokens from her balance leading to a loss of 100 FSD tokens.\n\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L282\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/conviction/FairSideConviction.sol#L48-L51\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove the redundant transfer of FSD tokens on Line282 in tokenizeConviction() of ERC20ConvictionScore.sol.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/29"
    }
  },
  {
    "title": "Conviction totals not updated during tokenization",
    "severity": "medium",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\n_updateConvictionScore() function returns convictionDelta and governanceDelta which need to be used immediately in a call to _updateConvictionTotals(convictionDelta, governanceDelta) for updating the conviction totals of conviction and governance-enabled conviction for the entire FairSide network.\n\nThis updation of totals after a call to _updateConvictionScore() is done on Line70 in _beforeTokenTransfer() and Line367 in updateConvictionScore() of ERC20ConvictionScore.sol.\n\nHowever, the return values of _updateConvictionScore() are ignored on Line284 in tokenizeConviction() and not used to update the totals using _updateConvictionTotals(convictionDelta, governanceDelta).\n\nThe impact is that when a user tokenizes their conviction score, their conviction deltas are updated and recorded (only if the funds locked are zero which is incorrect and reported separately in a different finding) but the totals are not updated. This leads to incorrect accounting of TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE which are used in the calculation of tributes and therefore will lead to incorrect tribute calculations.\n\n## Proof of Concept\n\nAlice calls tokenizeConviction() to convert her conviction score into an NFT. Her conviction deltas as returned by _updateConvictionScore() are ignored and TOTAL_CONVICTION_SCORE and TOTAL_GOVERNANCE_SCORE values are not updated. As a result, the tributes rewarded are proportionally more than what should have been the case because the conviction score totals are used as the denominator in availableTribute() and availableGovernanceTribute().\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L284\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L108-L110\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L52-L70\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L365-L367\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/ERC20ConvictionScore.sol#L73-L106\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L83-L100\n\nhttps://github.com/code-423n4/2021-05-FairSide/blob/3e9f6d40f70feb67743bdc70d7db9f5e3a1c3c96/contracts/dependencies/TributeAccrual.sol#L102-L123\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse the return values of _updateConvictionScore() function (i.e. convictionDelta and governanceDelta) on Line284 of ERC20ConvictionScore.sol and use them in a call to _updateConvictionTotals(convictionDelta, governanceDelta).\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/28"
    }
  },
  {
    "title": "Conviction scoring fails to initialize and bootstrap",
    "severity": "major",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nConviction scores for new addresses/users fail to initialize+bootstrap in ERC20ConvictionScore’s _updateConvictionScore() because a new user’s numCheckpoints will be zero and never gets initialized. \n\nThis effectively means that FairSide conviction scoring fails to bootstrap at all, leading to failure of the protocol’s pivotal feature.\n\n## Proof of Concept\n\nWhen Alice transfers FSD tokens to Bob for the first time, _beforeTokenTransfer(Alice, Bob, 100) is triggered which calls _updateConvictionScore(Bob, 100) on Line55 of ERC20ConvictionScore.sol. \n\nIn function _updateConvictionScore(), given that this is the first time Bob is receiving FSD tokens, numCheckpoints[Bob] will be 0 (Line116) which will make ts = 0 (Line120), and Bob’s FSD balance will also be zero (Bob never has got FSD tokens prior to this) which makes convictionDelta = 0 (Line122) and not let control go past Line129. \n\nThis means that a new checkpoint never gets written, i.e. conviction score never gets initialized, for Bob or for any user for that matter.\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nFairSide’s adjustment of Compound’s conviction scoring is based on time and so needs an initialization to take place vs. Compound’s implementation. A new checkpoint therefore needs to be created+initialized for a new user during token transfer.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-05-fairside-findings",
      "url": "https://github.com/code-423n4/2021-05-fairside-findings/issues/26"
    }
  },
  {
    "title": "Gas optimizations - using external over public ",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\nThe following methods could be external instead of public\n\n```\nlevel(bytes12) should be declared external:\n        - Cauldron.level(bytes12) (contracts/Cauldron.sol#513-521)\nmature(bytes6) should be declared external:\n        - Cauldron.mature(bytes6) (contracts/Cauldron.sol#524-532)\naccrual(bytes6) should be declared external:\n        - Cauldron.accrual(bytes6) (contracts/Cauldron.sol#546-553)\nsetFlashFeeFactor(uint256) should be declared external:\n        - Join.setFlashFeeFactor(uint256) (contracts/Join.sol#33-36)\nmaxFlashLoan(address) should be declared external:\n        - Join.maxFlashLoan(address) (contracts/Join.sol#90-97)\nflashFee(address,uint256) should be declared external:\n        - Join.flashFee(address,uint256) (contracts/Join.sol#105-113)\nflashLoan(IERC3156FlashBorrower,address,uint256,bytes) should be declared external:\n        - Join.flashLoan(IERC3156FlashBorrower,address,uint256,bytes) (contracts/Join.sol#132-151)\nsetFee(uint256) should be declared external:\n        - Ladle.setFee(uint256) (contracts/Ladle.sol#102-105)\naddAsset(bytes6,address) should be declared external:\n        - Wand.addAsset(bytes6,address) (contracts/Wand.sol#49-61)\nmakeBase(bytes6,IMultiOracleGov,address,address) should be declared external:\n        - Wand.makeBase(bytes6,IMultiOracleGov,address,address) (contracts/Wand.sol#65-78)\nmakeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) should be declared external:\n        - Wand.makeIlk(bytes6,bytes6,IMultiOracleGov,address,uint32,uint96,uint24,uint8) (contracts/Wand.sol#81-94)\naddSeries(bytes6,bytes6,uint32,bytes6[],string,string) should be declared external:\n        - Wand.addSeries(bytes6,bytes6,uint32,bytes6[],string,string) (contracts/Wand.sol#98-154)\nsetAuctionTime(uint128) should be declared external:\n        - Witch.setAuctionTime(uint128) (contracts/Witch.sol#41-44)\nsetInitialProportion(uint128) should be declared external:\n        - Witch.setInitialProportion(uint128) (contracts/Witch.sol#47-51)\ngrab(bytes12) should be declared external:\n        - Witch.grab(bytes12) (contracts/Witch.sol#54-59)\nbuy(bytes12,uint128,uint128) should be declared external:\n        - Witch.buy(bytes12,uint128,uint128) (contracts/Witch.sol#62-99)\nmint(address,uint256) should be declared external:\n        - DAIMock.mint(address,uint256) (contracts/mocks/DAIMock.sol#36-38)\nmint(address,uint256) should be declared external:\n        - ERC20Mock.mint(address,uint256) (contracts/mocks/ERC20Mock.sol#11-13)\nmint(address,uint256) should be declared external:\n        - RestrictedERC20Mock.mint(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#12-14)\nburn(address,uint256) should be declared external:\n        - RestrictedERC20Mock.burn(address,uint256) (contracts/mocks/RestrictedERC20Mock.sol#17-19)\npull(address,uint256) should be declared external:\n        - GemJoinMock.pull(address,uint256) (contracts/mocks/TLMMock.sol#14-16)\nmint(address,uint256) should be declared external:\n        - USDCMock.mint(address,uint256) (contracts/mocks/USDCMock.sol#13-15)\nwithdraw(uint256) should be declared external:\n        - WETH9Mock.withdraw(uint256) (contracts/mocks/WETH9Mock.sol#21-26)\ntotalSupply() should be declared external:\n        - WETH9Mock.totalSupply() (contracts/mocks/WETH9Mock.sol#28-30)\nlatestRoundData() should be declared external:\n        - ChainlinkAggregatorV3Mock.latestRoundData() (contracts/mocks/oracles/chainlink/ChainlinkAggregatorV3Mock.sol#22-34)\nexchangeRateCurrent() should be declared external:\n        - CTokenChiMock.exchangeRateCurrent() (contracts/mocks/oracles/compound/CTokenChiMock.sol#12-14)\ntickSpacing() should be declared external:\n        - UniswapV3PoolMock.tickSpacing() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#27-29)\nmaxLiquidityPerTick() should be declared external:\n        - UniswapV3PoolMock.maxLiquidityPerTick() (contracts/mocks/oracles/uniswap/UniswapV3PoolMock.sol#31-33)\nsetSources(bytes6[],bytes6[],address[]) should be declared external:\n        - ChainlinkMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#56-68)\npeek(bytes32,bytes32,uint256) should be declared external:\n        - ChainlinkMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#105-113)\n        - CompoundMultiOracle.peek(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#78-86)\n        - UniswapV3Oracle.peek(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#126-132)\nget(bytes32,bytes32,uint256) should be declared external:\n        - ChainlinkMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/chainlink/ChainlinkMultiOracle.sol#119-127)\n        - CompoundMultiOracle.get(bytes32,bytes32,uint256) (contracts/oracles/compound/CompoundMultiOracle.sol#92-100)\n        - UniswapV3Oracle.get(bytes32,bytes32,uint256) (contracts/oracles/uniswap/UniswapV3Oracle.sol#138-144)\nsetSources(bytes6[],bytes6[],address[]) should be declared external:\n        - CompoundMultiOracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/compound/CompoundMultiOracle.sol#37-48)\nsetSecondsAgo(uint32) should be declared external:\n        - UniswapV3Oracle.setSecondsAgo(uint32) (contracts/oracles/uniswap/UniswapV3Oracle.sol#44-48)\nsetSources(bytes6[],bytes6[],address[]) should be declared external:\n        - UniswapV3Oracle.setSources(bytes6[],bytes6[],address[]) (contracts/oracles/uniswap/UniswapV3Oracle.sol#73-85)\ntransferOwnership(address) should be declared external:\n        - Ownable.transferOwnership(address) (contracts/utils/access/Ownable.sol#25-28)\ntokenSymbol(address) should be declared external:\n        - SafeERC20Namer.tokenSymbol(address) (contracts/utils/token/SafeERC20Namer.sol#87-95)\ntokenName(address) should be declared external:\n        - SafeERC20Namer.tokenName(address) (contracts/utils/token/SafeERC20Namer.sol#98-106)\nsetParameter(bytes32,int128) should be declared external:\n        - Pool.setParameter(bytes32,int128) (contracts/yieldspace/Pool.sol#135-141)\ngetK() should be declared external:\n        - Pool.getK() (contracts/yieldspace/Pool.sol#144-147)\ngetG1() should be declared external:\n        - Pool.getG1() (contracts/yieldspace/Pool.sol#150-152)\ngetG2() should be declared external:\n        - Pool.getG2() (contracts/yieldspace/Pool.sol#155-157)\ngetCache() should be declared external:\n        - Pool.getCache() (contracts/yieldspace/Pool.sol#175-185)\nfyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:\n        - YieldMath.fyTokenOutForBaseIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#657-694)\nbaseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) should be declared external:\n        - YieldMath.baseOutForFYTokenIn(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#707-744)\nfyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:\n        - YieldMath.fyTokenInForBaseOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#757-797)\nbaseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) should be declared external:\n        - YieldMath.baseInForFYTokenOut(uint128,uint128,uint128,uint128,int128,int128) (contracts/yieldspace/YieldMath.sol#811-848)\n```\n\nHere more information about the gas optimizations of external vs public: https://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac\n\n## Tools Used\n\nSlither\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-yield-findings",
      "repo": "https://github.com/code-423n4/2021-05-yield-findings",
      "url": "https://github.com/code-423n4/2021-05-yield-findings/issues/60"
    }
  },
  {
    "title": "Multiple compiler versions allowing a wide range from 0.5.0 to >=0.8.0",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nProject uses multiple compiler versions with most specifying ^0.8.0, some specifying >=0.8.0 which allows breaking versions >= 0.9.0 in future if reused/redeployed, and some even allowing much older >= 0.5.0/0.6.0. \n\nThe dangers of allowing multiple compilers across breaking revisions is that the security bug fixes and features might be different across different contracts introducing vulnerabilities or giving a false sense of security.\n\nFor example, most contract use ^0.8.0 which means they have default checked arithmetic to prevent overflows/underflows without using OZ SafeMath. This doesn’t apply to the few (inherited) contracts that may be compiled with <0.8.0 and have unchecked overflows/underflows.\n\n\n## Proof of Concept\n\n^0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/Join.sol#L2\n\n>= 0.8.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/yieldspace/YieldMath.sol#L2\n\n>= 0.5.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/SafeERC20Namer.sol#L3\n\n>= 0.6.0: https://github.com/code-423n4/2021-05-yield/blob/e4c8491cd7bfa5dc1b59eb1b257161cd5bf8c6b0/contracts/utils/token/TransferHelper.sol#L4\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\n1. Update all contracts to use pragma solidity ^0.8.0 or better a fixed version like 0.8.4\n2. Deploy with the same compiler version which was used for testing\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-yield-findings",
      "repo": "https://github.com/code-423n4/2021-05-yield-findings",
      "url": "https://github.com/code-423n4/2021-05-yield-findings/issues/54"
    }
  },
  {
    "title": "ERC20 approve is vulnerable to the front-running",
    "severity": "minor",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nfunction approve is vulnerable to the front-running. This issue is described here: https://blog.smartdec.net/erc20-approve-issue-in-simple-words-a41aaf47bca6 A malicious delegate can scout for a change in approval and front-run that. It is more of a theoretical issue but still I want you to be aware of this and that.\n\n## Recommended Mitigation Steps\nIt is recommended introducing increaseAllowance / decreaseAllowance functions.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-yield-findings",
      "repo": "https://github.com/code-423n4/2021-05-yield-findings",
      "url": "https://github.com/code-423n4/2021-05-yield-findings/issues/38"
    }
  },
  {
    "title": "no need for transferToPool to be payable",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nfunction transferToPool is marked as 'payable'. It only transfers ERC20 tokens, no Ether, so there is no need in having 'payable' here.\n\n## Recommended Mitigation Steps\nRemove 'payable' modifier from function transferToPool.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-yield-findings",
      "repo": "https://github.com/code-423n4/2021-05-yield-findings",
      "url": "https://github.com/code-423n4/2021-05-yield-findings/issues/36"
    }
  },
  {
    "title": "Unsafe call to `.decimals`",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `FYToken.constructor` performs an external call to `IERC20Metadata(address(IJoin(join_).asset())).decimals()`.\nThis function was optional in the initial ERC-20 and might fail for old tokens that therefore did not implement it.\n\n## Impact\nFyTokens cannot be created for tokens that implemented the old initial ERC20 without the `decimals` function.\n\n## Recommended Mitigation Steps\nConsider using the helper function in the utils to retrieve it `SafeERC20Namer.tokenDecimals`, the same way the `Pool.constructor` works.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-05-yield-findings",
      "repo": "https://github.com/code-423n4/2021-05-yield-findings",
      "url": "https://github.com/code-423n4/2021-05-yield-findings/issues/32"
    }
  },
  {
    "title": "Deposits don't work with fee-on transfer tokens",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\n\n## Impact\n\nThe `deposit()` function will introduce unexpected balance inconsistencies when comparing internal asset records with external ERC20 token contracts.\n\n## Recommended Mitigation Steps\n\n One possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-realitycards-findings",
      "repo": "https://github.com/code-423n4/2021-06-realitycards-findings",
      "url": "https://github.com/code-423n4/2021-06-realitycards-findings/issues/152"
    }
  },
  {
    "title": "Return values of ERC20 `transfer` and `transferFrom` are unchecked",
    "severity": "medium",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nIn the contracts `BadgerYieldSource` and `SushiYieldSource`, the return values of ERC20 `transfer` and `transferFrom` are not checked to be `true`, which could be `false` if the transferred tokens are not ERC20-compliant (e.g., `BADGER`). In that case, the transfer fails without being noticed by the calling contract.\n\n## Proof of Concept\n\nIf warden's understanding of the `BadgerYieldSource` is correct, the `badger` variable should be the `BADGER` token at address `0x3472a5a71965499acd81997a54bba8d852c6e53d`. However, this implementation of `BADGER` is not ERC20-compliant, which returns `false` when the sender does not have enough token to transfer (both for `transfer` and `transferFrom`). See the [source code on Etherscan](https://etherscan.io/address/0x3472a5a71965499acd81997a54bba8d852c6e53d#code) (at line 226) for more details.\n\nReferenced code:\n[BadgerYieldSource.sol#L44](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L44)\n[BadgerYieldSource.sol#L79](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/BadgerYieldSource.sol#L79)\n[SushiYieldSource.sol#L48](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L48)\n[SushiYieldSource.sol#L89](https://github.com/code-423n4/2021-06-pooltogether/blob/main/contracts/yield-source/SushiYieldSource.sol#L89)\n\n## Recommended Mitigation Steps\n\nUse the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from Openzeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-06-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/112"
    }
  },
  {
    "title": "Various gas optimizations",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n# General Gas optimization\n\n## Upgrade to at least 0.8.4 (even better is 0.8.5)\n\nThe following should lead to better gas savings:\n\n  - The inliner should decrease runtime gas.\n  - Inbuilt safemath instead of openzeppelin safemath should save some gas.\n  - Various improvement in the expression simplifier in the compiler throughout (0.7.0 - 0.8.5)\n    which should decrease both runtime and deploy time costs. (I'm assuming that the project\n    currently uses 0.6.12, since the compiler version was not explicitly specified.)\n\nOf course, these improvements comes when optimizer is enabled, preferably with a high\n`--optimize-runs` value.\n\nNote that the `inliner` in particular can be quite useful for the contract, since the contracts\nsometimes generously chains small functions.\n\n## Use custom errors instead of large revert strings\n\nSaves both deploy time and runtime gas (runtime gas is only relevant when the revert condition is\nmet.)\n\nNeed at least solidity 0.8.4 for this feature.\n\n### Use shorter revert strings\n\nIf you decide to not use custom errors, then try to use revert strings of size at most 32\ncharacters.\n\nFor one, shorter strings would save deploy cost (one time saving of 200 gas per byte / character\ndecreased). Also strings more than 32 bytes requires an additional `mstore`, two additional `push`,\nand an `add`. Roughly, 18 more gas during runtime (when revert condition is met).\n\nExample string (33 bytes), from ControlledToken.sol\n\n``` solidity\nuint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\");\n```\n\n# Specific Gas optimizations\n\n## Use `immutable`\n\nFor state variables that are only assigned in constructors, change it to `immutable`.\n\nThis saves an `sload` each time the variable is accessed. Can save around 2100 gas (or 100 depending\non warm / cold.)\n\nExamples:\n\n### StakePrizePool.sol\n\n``` diff\nmodified   contracts/StakePrizePool.sol\n@@ -8,7 +8,7 @@ import \"../PrizePool.sol\";\n\n contract StakePrizePool is PrizePool {\n\n-  IERC20Upgradeable private stakeToken;\n+  IERC20Upgradeable immutable private stakeToken;\n\n   event StakePrizePoolInitialized(address indexed stakeToken);\n```\n\n### ControlledToken.sol\n\n``` diff\ncontract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {\n\n   /// @notice Interface to the contract responsible for controlling mint/burn\n-  TokenControllerInterface public override controller;\n+  TokenControllerInterface public immutable override controller;\n```\n\n### yield-source/YearnV2YieldSource.sol\n\n``` diff\n@@ -24,7 +24,7 @@ contract YearnV2YieldSource is IYieldSource, ERC20Upgradeable, OwnableUpgradeabl\n     /// @notice Yearn Vault which manages `token` to generate yield\n     IYVaultV2 public vault;\n     /// @dev Deposit Token contract address\n-    IERC20Upgradeable internal token;\n+    IERC20Upgradeable immutable internal token;\n     /// @dev Max % of losses that the Yield Source will accept from the Vault in BPS\n     uint256 public maxLosses = 0; // 100% would be 10_000\n```\n\nThis change would likely require changing the initialization pattern. See the section below for\ndetails.\n\nSimilarly, several such variables can be changed. Not listing everything here.\n\n## Avoiding the `initialize` pattern\n\nIf elements can be initialized in the constructor, or via calls to internal functions in\nconstructor, instead of the public `initialize` function, it should be possible to save deployment\ncosts. On top of that, since the `initialize` function won't be part of the function dispatch in the\ncontract, one could save some gas at run time for some calls (saves approximately two `push`, an\n`eq` and a `jumpi`.)\n\nAnother benefit for this is that several state variables can be converted to immutables. Again,\nsaves `sload` costs during runtime.\n\nAlso, it might also be possible to change `initialize` from `public` to `internal`.\n\n## `_msgSender()` (Possible micro optimization)\n\nUse `msg.sender` instead of `_msgSender()`. The latter might not be inlined by the compiler. (This\nis for cases where `_msgSender()` function simply returns `msg.sender`.) Can save around 30 gas (2\n`JUMP`, plus some `PUSH` and some stack operations.)\n\nAlso, the contracts seem to mix `_msgSender()` and `msg.sender`, for example in `PrizePool.sol`.\nThis could be avoided.\n\n## Use `decreaseAllowance` in ControllerToken.sol\n\n``` diff\n@@ -58,8 +58,7 @@ contract ControlledToken is ERC20PermitUpgradeable, ControlledTokenInterface {\n   /// @param _amount Amount of tokens to burn\n   function controllerBurnFrom(address _operator, address _user, uint256 _amount) external virtual override onlyController {\n     if (_operator != _user) {\n-      uint256 decreasedAllowance = allowance(_user, _operator).sub(_amount, \"ControlledToken/exceeds-allowance\");\n-      _approve(_user, _operator, decreasedAllowance);\n+      decreaseAllowance(_user, _operator, _amount);\n     }\n     _burn(_user, _amount);\n   }\n```\n\nWill be slightly more gas efficient than the first once.\n\n# General comments\n\n## Try to avoid `super` if possible\n\nFor example, in Ticket.sol:\n\n``` solidity\n  public\n  virtual\n  override\n  initializer\n{\n  super.initialize(_name, _symbol, _decimals, _controller);\n```\n\nThe above usage of `super` is unnecessary. Unless you are dealing with multiple inheritance, where\n`super` is absolutely required, there is no need to use super, instead of statically specifying the\nname of the parent contract. There is however no performance penalty in using `super` instead of a\nstatic call to the parent.\n\n## Several `balance` related function can be made `view`?\n\nIn PrizePool, the function `function balance() external returns (uint256)` can perhaps be made\n`view`. This would also mean that a few other internal functions should be made `view`, such as\n`_balance`.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-06-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/77"
    }
  },
  {
    "title": "safeApprove() for Yearn Vault may revert preventing deposits causing DoS",
    "severity": "medium",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nThe _depositInVault() function for Yearn yield source uses ERC20 safeApprove() from OpenZeppelin's SafeERC20 library to give maximum allowance to the Yearn Vault address if the current allowance is less than contract’s token balance.\n\nHowever, the safeApprove function prevents changing an allowance between non-zero values to mitigate a possible front-running attack. It reverts if that is the case. Instead, the safeIncreaseAllowance and safeDecreaseAllowance functions should be used. Comment from the OZ library for this function: “// safeApprove should only be called when setting an initial allowance, // or when resetting it to zero. To increase and decrease it, use // 'safeIncreaseAllowance' and ‘safeDecreaseAllowance'\"\n\nImpact: If the existing allowance is non-zero (say, for e.g., previously the entire balance was not deposited due to vault balance limit resulting in the allowance being reduced but not made 0), then safeApprove() will revert causing the user’s token deposits to fail leading to denial-of-service. The condition predicate indicates that this scenario is possible.\n\n## Proof of Concept\n\nReference: See similar Medium-severity finding M03 here: https://blog.openzeppelin.com/1inch-exchange-audit/\n\nhttps://github.com/code-423n4/2021-06-pooltogether/blob/85f8d044e7e46b7a3c64465dcd5dffa9d70e4a3e/contracts/yield-source/YearnV2YieldSource.sol#L171-L173\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/6842518b1b71fac9a21c7d94ec521992cff266b5/contracts/token/ERC20/utils/SafeERC20.sol#L44-L57\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse safeIncreaseAllowance() function instead of safeApprove().\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-06-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-06-pooltogether-findings/issues/71"
    }
  },
  {
    "title": "No check transferFrom() return value",
    "severity": "medium",
    "body": "# Handle\n\ns1m0\n\n\n# Vulnerability details\n\n## Impact\nThe smart contract doesn't check the return value of token.transfer() and token.transferFrom(), some erc20 token might not revert in case of error but return false.\nIn the [TracerPerpetualSwaps:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L151) and [Insurance:deposit](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L51) this would allow a user to deposit for free.\nOther places:\n[TracerPerpetualSwaps: withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L203)\n[TracerPerpetualSwaps:withdrawFees](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/TracerPerpetualSwaps.sol#L514)\n[SafetyWithdraw:withdrawERC20Token](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/lib/SafetyWithdraw.sol#L13)\n[Insurance:withdraw](https://github.com/code-423n4/2021-06-tracer/blob/main/src/contracts/Insurance.sol#L97)\n\n## Recommended Mitigation Steps\nWrap the call into a require() or use openzeppelin's [SafeERC20](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) library.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-06-tracer-findings",
      "url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/115"
    }
  },
  {
    "title": "Deflationary tokens are not supported",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\n\n## Impact\n\nThe `deposit()` functions of `Insurance` and `TracerPerpetualSwaps` assume that the external `ERC20` balance of the contract increases by the same amount as the `amount` parameter of the `transferFrom`.\n\nThe user is credited the full amount without the taxes (`userBalance.position.quote`).\n\n\n## Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring functions.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-06-tracer-findings",
      "url": "https://github.com/code-423n4/2021-06-tracer-findings/issues/104"
    }
  },
  {
    "title": "Two SafeApprove calls when it could be just one",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nIn `LifeGuard3Pool`  and `BaseVaultAdaptor` contracts, we are doing two approve calls when we could just use one. Doing two safeApprove calls with value = 0 and after value = max doesn't seem to provide any extra feature.\n\nFor example:\n```\n        IERC20(_token).safeApprove(address(_vault), 0);\n        IERC20(_token).safeApprove(address(_vault), type(uint256).max);\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-gro-findings",
      "repo": "https://github.com/code-423n4/2021-06-gro-findings",
      "url": "https://github.com/code-423n4/2021-06-gro-findings/issues/84"
    }
  },
  {
    "title": "decimals of FixedStablecoins",
    "severity": "minor",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nFixedStablecoins constructor does not validate that addresses in the array are not empty, != address(0), and relies that the creator passes the correct values for decimals. The comment next to USDC (0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48) says that it is supposed to have 6 decimals:\n    uint256 public immutable USDC_DECIMALS; // = 1E6;\nHowever, when querying the actual value on Etherscan, it shows 0 decimals: https://etherscan.io/address/0xa2327a938febf5fec13bacfb16ae10ecbc4cbdcf#readContract The problem with USDC is that it uses a proxy pattern thus the implementation could change (decimals could change but in practice, I think it is very unlikely).\n\n## Recommended Mitigation Steps\nI think it would be better not to pass decimals separately and rely on the correctness of the input but use IERC20Detailed and query the decimals in code. Always querying the decimals on the go may be very inefficient and bring new attack vectors so I think you need to do here an assumption that decimals of upgradeable tokens won't change.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-06-gro-findings",
      "repo": "https://github.com/code-423n4/2021-06-gro-findings",
      "url": "https://github.com/code-423n4/2021-06-gro-findings/issues/77"
    }
  },
  {
    "title": "Add a proper revert message in `transferFrom` of `LPTokenMaster`",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe `transferFrom` function of `LPTokenMaster` does not check if the allowance is enough to transfer the `amount` of tokens, causing the transaction to revert without a proper message (subtraction underflow). However, the `transferFrom` function of `external/ERC20` does implement such allowance checks.\n\n## Proof of Concept\n\nReferenced code:\n[LPTokenMaster.sol#L42-L46](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/LPTokenMaster.sol#L42-L46)\n[external/ERC20.sol#L42](https://github.com/code-423n4/2021-07-wildcredit/blob/main/contracts/external/ERC20.sol#L42)\n\n## Recommended Mitigation Steps\n\nAdd an allowance check, e.g., `require(allowance[_sender][msg.sender] >= _amount, \"ERC20: insufficient approval\");`, or make `LPTokenMaster` directly inherit from `ERC20`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-07-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/138"
    }
  },
  {
    "title": "`LendingPair.liquidateAccount` fails if tokens are lent out",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `LendingPair.liquidateAccount` function tries to pay out underlying supply tokens to the liquidator using `_safeTransfer(IERC20(supplyToken), msg.sender, supplyOutput)` but there's no reason why there should be enough `supplyOutput` amount in the contract, the contract only ensures `minReserve`.\n\n## Impact\nNo liquidations can be performed if all tokens are lent out.\nExample: User A supplies 1k$ WETH, User B supplies 1.5k$ DAI and borrows the ~1k$ WETH (only leaves `minReserve`). The ETH price drops but user B cannot be liquidated as there's not enough WETH in the pool anymore to pay out the liquidator.\n\n## Recommendation\nMint LP supply tokens to `msg.sender` instead, these are the LP supply tokens that were burnt from the borrower. This way the liquidator basically seizes the borrower's LP tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-07-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/123"
    }
  },
  {
    "title": "LPTokenMaster does not implement `IERC20`",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `LPTokenMaster` is only `Ownable` and not also `IERC20`.\n\n## Impact\nMissing functions from `IERC20` could go unnoticed as the token contract does not \"implement\" it.\n\n## Recommended Mitigation Steps\nChange to `contract LPTokenMaster is IERC20, Ownable`\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-07-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/113"
    }
  },
  {
    "title": "Variables that can be converted into immutables",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Variables that can be converted into immutables\n\n``` txt\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/external/ERC20.sol:17:3:\n   |\n17 |   uint8 public decimals;\n   |   ^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/PairFactory.sol:17:3:\n   |\n17 |   uint MAX_INT = 2**256 - 1;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/PairFactory.sol:22:3:\n   |\n22 |   address public lendingPairMaster;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/PairFactory.sol:23:3:\n   |\n23 |   address public lpTokenMaster;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/PairFactory.sol:24:3:\n   |\n24 |   IController public controller;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/RewardDistribution.sol:35:3:\n   |\n35 |   IPairFactory public factory;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/RewardDistribution.sol:36:3:\n   |\n36 |   IController  public controller;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\n\nWarning: Variable declaration can be converted into an immutable.\n  --> contracts/RewardDistribution.sol:37:3:\n   |\n37 |   IERC20  public rewardToken;\n   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n```\n\nInstead of the expensive `sload`, to read from storage, these would be transformed into a cheap `push value`, when the variables are converted into immutable.\n\n## Tools Used\n\nA custom compiler.\n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-07-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-07-wildcredit-findings/issues/110"
    }
  },
  {
    "title": "Saving gas by checking the last-recorded block number",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe `_accrueSherX` function of `LibSherX` and the `payOffDebtAll` function of `LibPool` can be called multiple times in the same block (from different users and transactions). If the current block number is the same as the last-recorded one, it is possible to save gas by early returning at the beginning of the functions.\n\n## Proof of Concept\n\nReferenced code:\n[LibSherX.sol#L123-L141](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibSherX.sol#L123-L141)\n[LibPool.sol#L84-L95](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/libraries/LibPool.sol#L84-L95)\n\n## Recommended Mitigation Steps\n\nFor example, consider re-writing `_accrueSherX` as follows:\n\n```solidity\nfunction _accrueSherX(IERC20 _token, uint256 sherXPerBlock) private returns (uint256 sherX) {\n  PoolStorage.Base storage ps = PoolStorage.ps(_token);\n  if (block.number == ps.sherXLastAccrued) {\n    return 0;\n  }\n  sherX = block.number.sub(ps.sherXLastAccrued).mul(sherXPerBlock).mul(ps.sherXWeight).div(\n    uint16(-1)\n  );\n  // need to settle before return, as updating the sherxperlblock/weight\n  // after it was 0 will result in a too big amount (accured will be < block.number)\n  ps.sherXLastAccrued = uint40(block.number);\n  if (address(_token) == address(this)) {\n    ps.stakeBalance = ps.stakeBalance.add(sherX);\n  } else {\n    ps.unallocatedSherX = ps.unallocatedSherX.add(sherX);\n    ps.sWeight = ps.sWeight.add(sherX);\n  }\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/150"
    }
  },
  {
    "title": "Possible divide-by-zero error in `PoolBase`",
    "severity": "minor",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nA possible divide-by-zero error could happen in the `getSherXPerBlock(uint256, IERC20)` function of `PoolBase` when the `totalSupply` of `lockToken` and `_lock` are both 0.\n\n## Proof of Concept\n\nReferenced code:\n[PoolBase.sol#L215](https://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/PoolBase.sol#L215)\n\n## Recommended Mitigation Steps\n\nCheck if `baseData().lockToken.totalSupply().add(_lock)` equals to 0 before line 214. If so, then return 0.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/136"
    }
  },
  {
    "title": "order of operations in Payout.sol",
    "severity": "minor",
    "body": "# Handle\n\n0xsanson\n\n\n# Vulnerability details\n\n## Impact\nThe expression `excludeUsd.div(curTotalUsdPool.div(SherXERC20Storage.sx20().totalSupply))` computes a division of a division: it's possible to write it as a multiplication and a division. We gain a lot of precision this way, since there is a risk that the second division gives 0, reverting the total computation.\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-07-sherlock/blob/main/contracts/facets/Payout.sol#L185\n\n## Tools Used\neditor\n\n## Recommended Mitigation Steps\nWrite the expression as `excludeUsd.mul(SherXERC20Storage.sx20().totalSupply).div(curTotalUsdPool)`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/130"
    }
  },
  {
    "title": "Single under-funded protocol can break paying off debt",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `SherXERC20.payOffDebtAll` function iterates over all protocols of the token.\nIf _a single project_ does not have enough funds to cover the premium payments, the transactions come to a halt, see `_payOffDebt`:\n\n```\ndebt = _accruedDebt(ps, _protocol, _blocks);\n// this can revert tx\nps.protocolBalance[_protocol] = ps.protocolBalance[_protocol].sub(debt);\n```\n\n## Impact\nMany core functions require paying off debt first and can therefore revert when a single protocol cannot pay the token premium:\n- `setTokenPrice`\n- `setProtocolPremium`\n- `withdrawProtocolBalance`\n- `redeem`\n- etc.\n\nThis scenario that a protocol is unable to pay a premium does not seem unlikely especially as there can be many protocols and each protocol can pay premiums in potentially many tokens and have to continuously re-deposit to their account to increase the balance.\nIt is also rather involved to remove the protocol's coverage and remove the premium payments for the token. It requires governance interaction and potentially paying for the accumulated debt themselves.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/119"
    }
  },
  {
    "title": "ERC20 can accidentally burn tokens",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `SherXERC20.transfer`/`transferFrom` actions allow transferring tokens to the zero address.\nThis is usually prohibited to accidentally avoid \"burning\" tokens by sending them to an unrecoverable zero address.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/118"
    }
  },
  {
    "title": "ERC20 non-standard names",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nUsually, the functions to increase the allowance are called `increaseAllowance` and `decreaseAllowance` but in `SherXERC20` they are called `increaseApproval` and `decreaseApproval`\n\n## Recommendation\nRename these functions to the more common names.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/117"
    }
  },
  {
    "title": "`initializeSherXERC20` can be called more than once",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `SherXERC20.initializeSherXERC20` function has `initialize` in its name which indicates that it should only be called once to initialize the storage. But it can be repeatedly called to overwrite and update the ERC20 name and symbol.\n\n## Recommendation\nConsider an `initializer` modifier or reverting if `name` or `symbol` is already set.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/116"
    }
  },
  {
    "title": "[Gas optimizations] - Public functions that are public, but could be external",
    "body": "# Handle\n\na_delamo\n\n\n# Vulnerability details\n\n## Impact\n\nThe following functions are public, but they could be decla\n\n```\ngetUnactivatedStakersPoolBalance(IERC20) should be declared external:\n        - PoolBase.getUnactivatedStakersPoolBalance(IERC20) (contracts/facets/PoolBase.sol#146-148)\ngetTotalUnmintedSherX(IERC20) should be declared external:\n        - PoolBase.getTotalUnmintedSherX(IERC20) (contracts/facets/PoolBase.sol#170-173)\naccruedDebt(bytes32,IERC20) should be declared external:\n        - LibPool.accruedDebt(bytes32,IERC20) (contracts/libraries/LibPool.sol#31-34)\ngetTotalAccruedDebt(IERC20) should be declared external:\n        - LibPool.getTotalAccruedDebt(IERC20) (contracts/libraries/LibPool.sol#36-39)\naccrueSherX(IERC20) should be declared external:\n        - LibSherX.accrueSherX(IERC20) (contracts/libraries/LibSherX.sol#75-81)\naccrueSherXWatsons() should be declared external:\n        - LibSherX.accrueSherXWatsons() (contracts/libraries/LibSherX.sol#83-86)\ndeposit() should be declared external:\n        - AaveV2.deposit() (contracts/strategies/AaveV2.sol#75-81)\n```\n\n\n## Tools Used\n\nSlither \n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-sherlock-findings",
      "repo": "https://github.com/code-423n4/2021-07-sherlock-findings",
      "url": "https://github.com/code-423n4/2021-07-sherlock-findings/issues/112"
    }
  },
  {
    "title": "Deflationary and fee-on-transfer tokens are not correctly accounted",
    "severity": "minor",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nWhen a router adds liquidity to the `TransactionManager`, the manager does not correctly handle the received amount if the transferred token is a deflationary or fee-on-transfer token. The actual received amount is less than that is recorded in the `routerBalances` variable.\n\n## Proof of Concept\n\nReferenced code:\n[TransactionManager.sol#L97](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L97)\n[TransactionManager.sol#L101](https://github.com/code-423n4/2021-07-connext/blob/main/contracts/TransactionManager.sol#L101)\n\n## Recommended Mitigation Steps\n\nGet the received token amount by calculating the difference of token balance before and after the transfer, for example:\n\n```solidity\nuint256 balanceBefore = getOwnBalance(assetId);\nrequire(LibERC20.transferFrom(assetId, router, address(this), amount, \"addLiquidity: ERC20_TRANSFER_FAILED\");\nuint256 receivedAmount = getOwnBalance(assetId) - balanceBefore;\n\n// Update the router balances\nrouterBalances[router][assetId] += receivedAmount;\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/68"
    }
  },
  {
    "title": "Revert strings",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Revert strings\n\n### Consider using custom errors instead of revert strings\n\nCan save gas when the revert condition has been met. And also during\nruntime.\n\n### Consider shortening revert strings to less than 32 bytes\n\nRevert strings more than 32 bytes require at least one additional\n`mstore`, along with additional operations for computing memory offset,\netc.\n\nEven if you need a string to represent an error, it can usually be done\nin less than 32 bytes / characters.\n\nHere are some examples of strings that can be shortened from codebase:\n\n``` txt\n./contracts/TransactionManager.sol:96:      \"addLiquidity: ETH_WITH_ERC_TRANSFER\"\n./contracts/TransactionManager.sol:97:      \"addLiquidity: ERC20_TRANSFER_FAILED\"\n./contracts/TransactionManager.sol:122:     \"removeLiquidity: INSUFFICIENT_FUNDS\"\n```\n\nNote that this will only decrease runtime gas when the revert condition\nhas been met. Regardless, it will decrease deploy time gas.\n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/59"
    }
  },
  {
    "title": "Missing zero-address checks",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nZero-address checks are in general a best-practice. However, addLiquidity() and removeLiquidity() are missing zero-address checks on router and recipient addresses respectively.  \n\naddLiquidity() on Eth transfers will update the zero index balance and get logged as such in the event without the amount getting accounted for the correct router.\n\nFor ERC20 assets, token.transfer() generally implements this check but the Eth transfer using transferEth() does not have this check and calls addr.call(value) which will lead to burning in the case of removeLiquidity(). \n\nThe checks may be more important because assetID is 0 for Eth. So a router may accidentally use 0 values for both assetID and router/recipient.\n\nThere is also a missing zero-address check on sendingChainFallback which is relevant for Eth transfers in cancel(). The comment on L178 indicates the need for this but the following check on L179 ends up checking receivingAddress instead (which is also necessary).\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L101-L104\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L116\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128-L131\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd zero-address checks.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/50"
    }
  },
  {
    "title": "Anyone can arbitrarily add router liquidity",
    "severity": "major",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nThe addLiquidity() function takes a router address parameter whose liquidity is increased (instead of assuming that router == msg.sender like done on removeLiquidity()) on this contract/chain by transferring the fund amount from router address to this contract if assetID != 0 i.e. ERC20 tokens. However, anyone can call this function on the router’s behalf. For assetID == 0, the Ether transfer via msg.value comes from msg.sender and hence is assumed to be the router itself.\n\nImpact: This will allow anyone to call this function and arbitrarily move ERC20 tokens from router address to this contract, assuming router has given max approval to this contract and has assetID amount available for transfer. While the router can always remove the liquidity if it doesn’t want to maintain that level of liquidity, this lack of access control or flexibility for a relayer to add liquidity on router’s behalf may unnecessarily (and without authorization) increase the router’s exposure to protocol risk to more than it desires.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98\n\nUse of msg.sender in removeLiquidity: https://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L88-L98\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider the use of msg.sender in addLiquidity() or evaluate this risk otherwise.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/48"
    }
  },
  {
    "title": "Consolidating library functions can save gas by preventing external calls",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nWhile code modularity is generally a good practice and creating libraries of functions commonly used across different contracts can increase maintainability and reduce contract deployment size/cost, it comes at the increased cost of gas usage at runtime because of the external calls. EIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. \n\nImpact: A LibAsset.transferAsset() call from TransactionManager.sol makes LibERC20.transfer() call for ERC20 which in turn makes another external call to LibUtils.revertIfCallFailed() in wrapCall. So an ERC20 transfer effectively makes 3 additional (besides the ERC20 token contract function call assetId.call(..) external calls -> LibAsset -> LibERC20 -> LibUtils, which costs 2600*3 = 7800 gas.\n \nCombining these functions into a single library or making them all internal to TransactionManager.sol can convert these delegatecalls into JMPs to save gas.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L58\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L44\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L64\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L128\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L369\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L378\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L406\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L425\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L504\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L514\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/TransactionManager.sol#L525\n\nAnd other Lib* calls.\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider moving all the library functions internal to this contract or to a single library to save gas from external calls each of which costs 2600 gas.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/42"
    }
  },
  {
    "title": "Checking before external library call can save 2600 gas",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nEIP-2929 in Berlin fork increased the gas costs of CALL* family opcodes to 2600. Making a delegatecall to a library function therefore costs 2600. LibUtils.revertIfCallFailed() reverts and passes on the revert string if the boolean argument is false. Instead, moving the checking of the boolean to the caller avoids the library call when the boolean is true, which is likely the case most of the time.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibUtils.sol#L10-L19\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibAsset.sol#L35\n\nhttps://github.com/code-423n4/2021-07-connext/blob/8e1a7ea396d508ed2ebeba4d1898a748255a48d2/contracts/lib/LibERC20.sol#L20\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nRemove the boolean parameter from revertIfCallFailed() and move the conditional check logic to the call sites.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/41"
    }
  },
  {
    "title": "Approval is not reset if the call to IFulfillHelper fails",
    "severity": "major",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nFunction fulfill first approves the callTo to transfer an amount of toSend tokens and tries to call IFulfillHelper but if the call fails it transfers these assets directly. However, in such case the approval is not reset so a malicous callTo can pull these tokens later:\n    // First, approve the funds to the helper if needed\n        if (!LibAsset.isEther(txData.receivingAssetId) && toSend > 0) {\n          require(LibERC20.approve(txData.receivingAssetId, txData.callTo, toSend), \"fulfill: APPROVAL_FAILED\");\n        }\n\n        // Next, call `addFunds` on the helper. Helpers should internally\n        // track funds to make sure no one user is able to take all funds\n        // for tx\n        if (toSend > 0) {\n          try\n            IFulfillHelper(txData.callTo).addFunds{ value: LibAsset.isEther(txData.receivingAssetId) ? toSend : 0}(\n              txData.user,\n              txData.transactionId,\n              txData.receivingAssetId,\n              toSend\n            )\n          {} catch {\n            // Regardless of error within the callData execution, send funds\n            // to the predetermined fallback address\n            require(\n              LibAsset.transferAsset(txData.receivingAssetId, payable(txData.receivingAddress), toSend),\n              \"fulfill: TRANSFER_FAILED\"\n            );\n          }\n        }\n\n## Recommended Mitigation Steps\nApprove should be placed inside the try/catch block or approval needs to be reset if the call fails.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-connext-findings",
      "repo": "https://github.com/code-423n4/2021-07-connext-findings",
      "url": "https://github.com/code-423n4/2021-07-connext-findings/issues/31"
    }
  },
  {
    "title": "Gas: `SyntheticToken` does not use pausing functionality",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `SyntheticToken` overwrites the `_beforeTokenTransfer` hook and removes the pausing functionality of `ERC20PresetMinterPauser`.\nBut the `ERC20PresetMinterPauser` constructor still assigns pauser roles which leads to unnecessary gas costs.\nInherit from an `ERC20PresetMinterPauser`-like contract without the pausing functionality.\nThis would also make the intention of the code more clear by showcasing that it does not implement the pauser interface functions `pause`/`unpause` (which it currently still does but they don't have any effect).\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-floatcapital-findings",
      "repo": "https://github.com/code-423n4/2021-08-floatcapital-findings",
      "url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/118"
    }
  },
  {
    "title": "Assuming tokens are compliant with ERC20 could cause transactions to revert unexpectedly",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nIn the following lines of code, when transferring tokens, it is assumed that the token complies with the standard ERC20 interface (since the OpenZeppelin `IERC20` is used). However, for tokens that do not have a return value of `transfer` or `transferFrom` (e.g., `USDT` and `BNB`) the function calls `transfer` and `transferFrom` reverts due to a return value decoding error.\n\n## Proof of Concept\n\nReferenced code:\n[LongShort.sol#L791](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/LongShort.sol#L791)\n[YieldManagerAave.sol#L132](https://github.com/code-423n4/2021-08-floatcapital/blob/main/contracts/contracts/YieldManagerAave.sol#L132)\n\n## Recommended Mitigation Steps\n\nUse the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin, which handles tokens that have no return values of `transfer` and `transferFrom`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-floatcapital-findings",
      "repo": "https://github.com/code-423n4/2021-08-floatcapital-findings",
      "url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/93"
    }
  },
  {
    "title": "Interface notations are used for abstract contracts",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nInterfaces are not allowed to define any functions while abstract contracts can have a few defined functions (with at least one undefined function). The code base uses interface notations (IContractName in interfaces directory) for what are really abstract contracts.\n\nFor example, ISyntheticToken is an abstract contract and not an interface. This allows defining functions in it that accidentally allow critical functionality available to users which is risky. This also affects readability/maintainability because being an abstract contract allows it to derive from ERC20PresetMinterPauser which is transitively inherited here as well.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/interfaces/ISyntheticToken.sol#L12\n\nhttps://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/interfaces/ILongShort.sol#L5\n\nhttps://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/interfaces/IStaker.sol#L5\n\nhttps://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/interfaces/IYieldManager.sol#L6\n\nhttps://github.com/code-423n4/2021-08-floatcapital/blob/bd419abf68e775103df6e40d8f0e8d40156c2f81/contracts/contracts/interfaces/ISyntheticToken.sol#L12\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider changing the abstract contracts to interfaces and if that’s possible remove the interface notations for clarity.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-floatcapital-findings",
      "repo": "https://github.com/code-423n4/2021-08-floatcapital-findings",
      "url": "https://github.com/code-423n4/2021-08-floatcapital-findings/issues/86"
    }
  },
  {
    "title": "Potential DOS in Contracts Inheriting `UUPSUpgradeable.sol`",
    "severity": "major",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nThere are a number of contracts which inherit `UUPSUpgradeable.sol`, namely; `GovernanceAction.sol`, `PauseRouter.sol` and `NoteERC20.sol`. All these contracts are deployed using a proxy pattern whereby the implementation contract is used by the proxy contract for all its logic. The proxy contract will make delegate calls to the implementation contract. This helps to facilitate future upgrades by pointing the proxy contract to a new and upgraded implementation contract. However, if the implementation contract is left uninitialized, it is possible for any user to gain ownership of the `onlyOwner` role in the implementation contract for `NoteERC20.sol`. Once the user has ownership they are able to perform an upgrade of the implementation contract's logic contract and delegate call into any arbitrary contract, allowing them to self-destruct the proxy's implementation contract. Consequently, this will prevent all `NoteERC20.sol` interactions until a new implementation contract is deployed.\n\n## Proof of Concept\n\nInitial information about this issue was found [here](https://forum.openzeppelin.com/t/security-advisory-initialize-uups-implementation-contracts/15301).\n\nConsider the following scenario:\n- Notional finance deploys their contracts using their deployment scripts. These deployment scripts leave the implementation contracts uninitialized. Specifically the contract in question is `NoteERC20.sol`.\n- This allows any arbitrary user to call `initialize()` on the `NoteERC20.sol` implementation contract.\n- Once a user has gained control over `NoteERC20.sol`'s implementation contract, they can bypass the `_authorizeUpgrade` check used to restrict upgrades to the `onlyOwner` role.\n- The malicious user then calls `UUPSUpgradeable.upgradeToAndCall()` shown [here](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/utils/UUPSUpgradeable.sol#L40-L43) which in turn calls [this](https://github.com/code-423n4/2021-08-notional/blob/main/contracts/proxy/ERC1967/ERC1967Upgrade.sol#L77-L107) function. The new implementation contract then points to their own contract containing a self-destruct call in its fallback function.\n- As a result, the implementation contract will be self-destructed due the user controlled delegate call shown [here](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0-solc-0.7/contracts/utils/Address.sol#L163-L169), preventing all future calls to the `NoteERC20.sol` proxy contract until a new implementation contract has been deployed.\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider initializing the implementation contract for `NoteERC20.sol` and checking the correct permissions before deploying the proxy contract or performing any contract upgrades. This will help to ensure the implementation contract cannot be self-destructed.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/98"
    }
  },
  {
    "title": "No Transfer Ownership Pattern",
    "severity": "minor",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nThe current ownership transfer process involves the current owner calling `NoteERC20.transferOwnership()`. This function checks the new owner is not the zero address and proceeds to write the new owner's address into the owner's state variable. If the nominated EOA account is not a valid account, it is entirely possible the owner may accidentally transfer ownership to an uncontrolled account, breaking all functions with the `onlyOwner()` modifier.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L123-L127\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider implementing a two step process where the owner nominates an account and the nominated account needs to call an `acceptOwnership()` function for the transfer of ownership to fully succeed. This ensures the nominated EOA account is a valid and active account.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/94"
    }
  },
  {
    "title": "Lack of Zero Address Validation",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nThere is currently no input validation done on the `Router.initialize()` and `NoteERC20.initialize()` functions, potentially leading to an initialized state where the contracts have no owner and the deployer needs to re-deploy the contract to have it working properly.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/Router.sol#L63-L92\nhttps://github.com/code-423n4/2021-08-notional/blob/main/contracts/external/governance/NoteERC20.sol#L90-L108\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nPerform zero address checks for the `owner_`, `pauseRouter_` and `pauseGuardian_` inputs to ensure the contract isn't initialized into an unexpected state.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/93"
    }
  },
  {
    "title": "Caching length in for loops",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Caching length in for loops\n\nConsider a generic example of an array `arr` and the following loop:\n\n``` solidity\nfor (uint i = 0; i < arr.length; i++) {\n    // do something that doesn't change arr.length\n}\n```\n\nIn the above case, the solidity compiler will always read the length of\nthe array during each iteration. That is, if it is a storage array, this\nis an extra `sload` operation (100 additional extra gas for each\niteration except for the first) and if it is a memory array, this is an\nextra `mload` operation (3 additional gas for each iteration except for\nthe first).\n\nThis extra costs can be avoided by caching the array length (in stack):\n\n``` solidity\nuint length = arr.length;\nfor (uint i = 0; i < length; i++) {\n    // do something that doesn't change arr.length\n}\n```\n\nIn the above example, the `sload` or `mload` operation is only done once\nand subsequently replaced by a cheap `dupN` instruction.\n\nThis optimization is especially important if it is a storage array or if\nit is a lengthy for loop.\n\nNote that the Yul based optimizer (not enabled by default; only relevant\nif you are using `--experimental-via-ir` or the equivalent in standard\nJSON) can sometimes do this caching automatically. However, this is\nlikely not the case in your project.\n\n### Examples\n\nHere are some examples where this can be applied (found using a simple\ngrep)\n\n``` txt\n./contracts/external/Views.sol:187:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n./contracts/external/actions/BatchAction.sol:42:        for (uint256 i; i < actions.length; i++) {\n./contracts/external/actions/BatchAction.sol:120:        for (uint256 i; i < actions.length; i++) {\n./contracts/external/actions/ERC1155Action.sol:62:        for (uint256 i; i < accounts.length; i++) {\n./contracts/external/actions/ERC1155Action.sol:91:        for (uint256 i; i < portfolio.length; i++) {\n./contracts/external/actions/ERC1155Action.sol:240:        for (uint256 i; i < ids.length; i++) {\n./contracts/external/actions/InitializeMarketsAction.sol:121:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) {\n./contracts/external/actions/InitializeMarketsAction.sol:146:        for (uint256 i = 1; i < nToken.portfolioState.storedAssets.length; i++) {\n./contracts/external/actions/InitializeMarketsAction.sol:537:        for (uint256 i; i < nToken.cashGroup.maxMarketIndex; i++) {\n./contracts/external/actions/TradingAction.sol:81:        for (uint256 i; i < trades.length; i++) {\n./contracts/external/actions/TradingAction.sol:123:        for (uint256 i; i < trades.length; i++) {\n./contracts/external/actions/nTokenMintAction.sol:110:        for (uint256 marketIndex = nToken.cashGroup.maxMarketIndex; marketIndex > 0; marketIndex--) {\n./contracts/external/actions/nTokenRedeemAction.sol:138:        for (uint256 i; i < markets.length; i++) {\n./contracts/external/actions/nTokenRedeemAction.sol:222:        for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {\n./contracts/external/actions/nTokenRedeemAction.sol:265:        for (uint256 i; i < markets.length; i++) {\n./contracts/external/adapters/CompoundToNotionalV2.sol:81:        for (uint256 i; i < notionalV2CollateralIds.length; i++) {\n./contracts/external/governance/NoteERC20.sol:98:        for (uint256 i = 0; i < initialGrantAmount.length; i++) {\n./contracts/internal/balances/BalanceHandler.sol:300:        for (uint256 i; i < settleAmounts.length; i++) {\n./contracts/internal/liquidation/LiquidateCurrency.sol:31:        for (uint256 i; i < portfolio.length; i++) {\n./contracts/internal/liquidation/LiquidateCurrency.sol:345:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/liquidation/LiquidateCurrency.sol:449:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/liquidation/LiquidateCurrency.sol:528:            for (uint256 i; i < markets.length; i++) {\n./contracts/internal/liquidation/LiquidatefCash.sol:77:        for (uint256 i; i < portfolio.length; i++) {\n./contracts/internal/liquidation/LiquidatefCash.sol:131:        for (uint256 i; i < fCashMaturities.length; i++) {\n./contracts/internal/liquidation/LiquidatefCash.sol:232:        for (uint256 i; i < fCashMaturities.length; i++) {\n./contracts/internal/liquidation/LiquidatefCash.sol:495:        for (uint256 i; i < assets.length; i++) {\n./contracts/internal/markets/CashGroup.sol:297:        for (uint256 i; i < cashGroup.liquidityTokenHaircuts.length; i++) {\n./contracts/internal/markets/CashGroup.sol:309:        for (uint256 i; i < cashGroup.rateScalars.length; i++) {\n./contracts/internal/nTokenHandler.sol:279:        for (uint256 i; i < depositShares.length; i++) {\n./contracts/internal/nTokenHandler.sol:306:        for (uint256 i; i < proportions.length; i++) {\n./contracts/internal/nTokenHandler.sol:371:        for (; i < array1.length; i++) {\n./contracts/internal/nTokenHandler.sol:494:            for (uint256 i; i < nToken.portfolioState.storedAssets.length; i++) {\n./contracts/internal/portfolio/BitmapAssetsHandler.sol:96:        for (uint256 i; i < assets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:20:        for (uint256 i; i < assets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:40:        for (uint256 i; i < assetArray.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:129:        for (uint256 i; i < newAssets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:161:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:171:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:202:        for (uint256 i; i < portfolioState.newAssets.length; i++) {\n./contracts/internal/portfolio/PortfolioHandler.sol:283:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/portfolio/TransferAssets.sol:47:        for (uint256 i; i < assets.length; i++) {\n./contracts/internal/settlement/SettlePortfolioAssets.sol:32:        for (uint256 i = portfolioState.storedAssets.length; (i--) > 0;) {\n./contracts/internal/settlement/SettlePortfolioAssets.sol:137:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/internal/valuation/AssetHandler.sol:231:        for (uint256 i = portfolioIndex; i < assets.length; i++) {\n./contracts/internal/valuation/AssetHandler.sol:250:        for (; j < assets.length; j++) {\n./contracts/mocks/BaseMockLiquidation.sol:52:        for (uint256 i = 0; i < cashGroup.maxMarketIndex; i++) {\n./contracts/mocks/BaseMockLiquidation.sol:72:        for (uint256 i; i < portfolioState.storedAssets.length; i++) {\n./contracts/mocks/MockFlashLender.sol:30:        for (uint256 i; i < assets.length; i++) {\n./contracts/mocks/MockFlashLender.sol:39:        for (uint256 i; i < assets.length; i++) {\n```\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/88"
    }
  },
  {
    "title": "`TokenHandler.safeTransferIn` does not work on non-standard compliant tokens like USDT",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `TokenHandler.safeTransferIn` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work as calling `token.transferFrom(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transferFrom` is defined to always return a `boolean`.\n\n## Impact\nWhen using any non-standard compliant token like USDT, the function will revert.\nWithdrawals for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.\n\n## Recommended Mitigation Steps\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/80"
    }
  },
  {
    "title": "`TokenHandler.safeTransferOut` does not work on non-standard compliant tokens like USDT",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `TokenHandler.safeTransferOut` function uses the standard `IERC20` function for the transfer call and proceeds with a `checkReturnCode` function to handle non-standard compliant tokens that don't return a return value.\nHowever, this does not work as calling `token.transfer(account, amount)` already reverts if the token does not return a return value, as `token`'s `IERC20.transfer` is defined to always return a `boolean`.\n\n## Impact\nWhen using any non-standard compliant token like USDT, the function will revert.\nDeposits for these tokens are broken, which is bad as `USDT` is a valid underlying for the `cUSDT` cToken.\n\n## Recommended Mitigation Steps\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/79"
    }
  },
  {
    "title": "`TokenHandler.transfer` wrong branch order",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `TokenHandler.transfer` should handle the `if (token.tokenType == TokenType.Ether)` case first, as if the token type is `Ether` but `netTransferExternal <= 0` it treats the token as an `ERC20` token and tries to call `ERC20` functions on it. \n\n## Impact\nLuckily, trying to call ERC20 functions on the invalid token address will revert which is the desired behavior.\n\n## Recommended Mitigation Steps\nWe still recommend reordering the branches and adding a `netTransferExternal <= 0` check. The code becomes cleaner and it's more obvious that the transaction will fail.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/78"
    }
  },
  {
    "title": "`TokenHandler.setToken` ERC20 missing return value check",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `setToken` function performs an `ERC20.approve()` call but does not check the `success` return value.\nSome tokens do **not** revert if the approval failed but return `false` instead.\n\n## Impact\nTokens that don't actually perform the approve and return `false` are still counted as a correct approve.\n\n## Recommended Mitigation Steps\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeApprove` function that handles the return value check as well as non-standard-compliant tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/77"
    }
  },
  {
    "title": "NoteERC20.getPriorVotes includes current unclaimed incentives",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `NoteERC20.getPriorVotes` function is supposed to return the voting strength of an account at a specific block in the past.\nThis should be a static value but it directly includes the _current_ unclaimed incentives due to the `getUnclaimedVotes(account)` call.\n\n## Impact\nUsers that didn't even have tokens at the time of proposal creation but are now interested in voting on the proposal can farm unclaimed incentives and impact the outcome of the proposal.\n\n## Recommended Mitigation Steps\nAdding checkpoints for all unclaimed incentives would be the correct solution but was probably not done because it'd cost too much gas.\nIt also needs to be ensured that incentives cannot be increased through flash-loaning of assets.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/76"
    }
  },
  {
    "title": "NoteERC20 _authorizeUpgrade not implemented",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `NoteERC20._authorizeUpgrade` function is not implemented.\n\n## Recommended Mitigation Steps\nDouble-check if this is the expected behavior.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/75"
    }
  },
  {
    "title": "NoteERC20 missing initial ownership event",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `NoteERC20.initialize` function does not emit an initial `OwnershipTransferred` event.\n\n## Recommended Mitigation Steps\nIn `initialize`, emit `OwnershipTransferred(address(0), owner_)`.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/74"
    }
  },
  {
    "title": "nTokenERC20Proxy emits events even when not success",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `nTokenERC20Proxy` functions emit events all the time, even if the return value from the inner call returns `false` indicating an unsuccessful action.\n\n## Impact\nAn off-chain script scanning for `Transfer` or `Approval` events can be tricked into believing that an unsuccessful transfer was indeed successful.\nThis happens in the `approve`, `transfer` and `transferFrom` functions.\n\n## Recommended Mitigation Steps\nOnly emit evens on `success`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/72"
    }
  },
  {
    "title": "Access restrictions on `CompoundToNotionalV2.notionalCallback` can be bypassed",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\n## Vulnerability Details\nThe `CompoundToNotionalV2.notionalCallback` is supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providing `sender = this` as `sender` is a parameter of the function that can be chosen by the attacker.\n\n```solidity\nfunction notionalCallback(\n    address sender,\n    address account,\n    bytes calldata callbackData\n) external returns (uint256) {\n// @audit sender can be passed in by the attacker\nrequire(sender == address(this), \"Unauthorized callback\");\n```\n\n## Impact\nAn attacker can call the function passing in an arbitrary `account` whose tokens are then transferred to the contract.\nThe `account` first has to approve this contract but this can happen with accounts that legitimately want to call the outer function and have to send a first transaction to approve the contract, but then an attacker frontruns the actual transaction.\n\nIt's at least a griefing attack:\nI can pass in a malicious `cTokenBorrow` that returns any token of my choice (through the `.underlying()` call) but whose `repayBorrowBehalf` is a no-op.\nThis will lead to any of the victim's approved tokens becoming stuck in the contract, essentially burning them:\n\n```solidity\n// @audit using a malicious contract, this can be any token\naddress underlyingToken = CTokenInterface(cTokenBorrow).underlying();\nbool success = IERC20(underlyingToken).transferFrom(account, address(this), cTokenRepayAmount);\nrequire(success, \"Transfer of repayment failed\");\n\n// Use the amount transferred to repay the borrow\n// @audit using a malicious contract, this can be a no-op\nuint code = CErc20Interface(cTokenBorrow).repayBorrowBehalf(account, cTokenRepayAmount);\n```\n\nNote that the assumption at the end of the function \"// When this exits a free collateral check will be triggered\" is not correct anymore but I couldn't find a way to make use of it to lead to an invalid account state.\n\n## Recommended Mitigation Steps\nFix the authorization check.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-notional-findings",
      "repo": "https://github.com/code-423n4/2021-08-notional-findings",
      "url": "https://github.com/code-423n4/2021-08-notional-findings/issues/69"
    }
  },
  {
    "title": "Validation",
    "severity": "minor",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nfunction supplyTokenTo should check that mAssetAmount and creditsIssued > 0 and to != address(0) or if empty to address is provided, it can replace it with msg.sender to prevent potential burn of funds. function redeemToken should check that mAssetAmount and creditsBurned > 0. function transferERC20 should similarly validate erc20Token, to and amount parameters. function _mintShares requires that shares > 0, while _burnShares lacks such requirement.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/74"
    }
  },
  {
    "title": "Incorrect comment about memory",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Incorrect comment\n\n[Context](https://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L47)\n\n``` diff\nmodified   contracts/MStableYieldSource.sol\n@@ -44,7 +44,7 @@ contract MStableYieldSource is IYieldSource, ReentrancyGuard {\n\n     constructor(ISavingsContractV2 _savings) ReentrancyGuard() {\n         // As immutable storage variables can not be accessed in the constructor,\n-        // create in-memory variables that can be used instead.\n+        // create in-stack variables that can be used instead.\n         IERC20 mAssetMemory = IERC20(_savings.underlying());\n\n         // infinite approve Savings Contract to transfer mAssets from this contract\n```\n\nThe comment and therefore the variable name aren't accurate. The value\nwould be in stack, and not memory.\n\nHowever, this doesn't affect the code in any way.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/69"
    }
  },
  {
    "title": "`redeemToken` can fail for certain tokens",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `SwappableYieldSource.redeemToken` function transfers tokens from the contract back to the sender, however, it uses the `ERC20.transferFrom(address(this), msg.sender, redeemableBalance)` function for this.\nSome deposit token implementations might fail as `transferFrom` checks if the contract approved itself for the `redeemableBalance` instead of skipping the allowance check in case the sender is the `from` address.\n\nThis can make the transaction revert and the deposited funds will be unrecoverable for the user.\n\nIt's recommended to use `_depositToken.safeTransfer(msg.sender, redeemableBalance)` instead.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/61"
    }
  },
  {
    "title": "Yield sources cannot be swapped back",
    "severity": "medium",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe `_setYieldSource` function of `SwappableYieldSource` calls the `safeApprove` function to approve the yield sources with the maximum allowance of transferring underlying tokens. However, according to OpenZeppelin's implementation, the `safeApprove` function succeeds only if the current allowance is zero or the allowance to be set is zero (see the following link).\n\nAs a result, a yield source cannot be set twice by the contract. For example, set A -> set B -> set A is not possible since A's allowance is non-zero in the second \"set A\", causing the transaction to revert.\n\n## Proof of Concept\n\nReferenced code:\n[SwappableYieldSource.sol#L259](https://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L259)\n\n[OpenZeppelin - SafeERC20.sol#L52-L55](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#L52-L55)\n\n## Recommended Mitigation Steps\n\nUse `safeIncreaseAllowance` to increase the allowance to the maximum instead.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/51"
    }
  },
  {
    "title": "Use of safeApprove will always cause approveMax to revert",
    "severity": "medium",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nUnlike SwappableYieldSource which uses safeIncreaseAllowance to increase the allowance to uint256.max, mStableYieldSource uses OpenZeppelin’s safeApprove() which has been documented as 1) Deprecated because of approve-like race condition and 2) To be used only for initial setting of allowance (current allowance == 0) or resetting to 0 because it reverts otherwise.\n\nThe usage here is intended to allow increase of allowance when it falls low similar to the documented usage in SwappableYieldSource. Using it for that scenario will not work as expected because it will always revert if current allowance is != 0. The initial allowance is already set as uint256.max in constructor. And once it gets reduced, it can never be increased using this function unless it is invoked when allowance is reduced completely to 0.\n\n## Proof of Concept\n\nhttps://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L60-L65\n\nhttps://github.com/pooltogether/pooltogether-mstable/blob/0bcbd363936fadf5830e9c48392415695896ddb5/contracts/yield-source/MStableYieldSource.sol#L51\n\nhttps://github.com/pooltogether/swappable-yield-source/blob/89cf66a3e3f8df24a082e1cd0a0e80d08953049c/contracts/SwappableYieldSource.sol#L135-L143\n\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/081776bf5fae2122bfda8a86d5369496adfdf959/contracts/token/ERC20/utils/SafeERC20Upgradeable.sol#L37-L57\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse logic similar to SwappableYieldSource instead of using safeApprove().\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/47"
    }
  },
  {
    "title": "SwappableYieldSource: Missing same deposit token check in transferFunds()",
    "severity": "major",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\n`transferFunds()` will transfer funds from a specified yield source `_yieldSource` to the current yield source set in the contract `_currentYieldSource`. However, it fails to check that the deposit tokens are the same. If the specified yield source's assets are of a higher valuation, then a malicious owner or asset manager will be able to exploit and pocket the difference.\n\n### Proof of Concept\n\nAssumptions:\n\n- `_yieldSource` has a deposit token of WETH (18 decimals)\n- `_currentYieldSource` has a deposit token of DAI (18 decimals)\n- 1 WETH > 1 DAI (definitely true, I'd be really sad otherwise)\n\nAttacker does the following:\n\n1. Deposit 100 DAI into the swappable yield source contract\n2. Call `transferFunds(_yieldSource, 100 * 1e18)`\n    - `_requireDifferentYieldSource()` passes\n    - `_transferFunds(_yieldSource, 100 * 1e18)` is called\n        - `_yieldSource.redeemToken(_amount);` → This will transfer 100 WETH out of the `_yieldSource` into the contract\n        - `uint256 currentBalance = IERC20Upgradeable(_yieldSource.depositToken()).balanceOf(address(this));` → This will equate to ≥ 100 WETH.\n        - `require(_amount <= currentBalance, \"SwappableYieldSource/transfer-amount-different\");` is true since both are `100 * 1e18`\n        - `_currentYieldSource.supplyTokenTo(currentBalance, address(this));` → This supplies the transferred 100 DAI from step 1 to the current yield source\n    - We now have 100 WETH in the swappable yield source contract\n3. Call `transferERC20(WETH, attackerAddress, 100 * 1e18)` to withdraw 100 WETH out of the contract to the attacker's desired address. \n\n### Recommended Mitigation Steps\n\n`_requireDifferentYieldSource()` should also verify that the yield sources' deposit token addresses are the same.\n\n```jsx\nfunction _requireDifferentYieldSource(IYieldSource _yieldSource) internal view {\n    require(address(_yieldSource) != address(yieldSource), \"SwappableYieldSource/same-yield-source\");\n\t\trequire(_newYieldSource.depositToken() == yieldSource.depositToken(), \"SwappableYieldSource/different-deposit-token\");\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/29"
    }
  },
  {
    "title": "SwappableYieldSource.sol: Save depositToken as a storage variable",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nAssuming that `depositToken` of a yield source doesn't change, it would make sense to save its value as a storage variable in the contract as well, so that an external call to `yieldSource` to retrieve it can be avoided whenever it is needed.\n\n### Recommended Mitigation Steps\n\nDefine `address public override depositToken;` or `IERC20Upgradeable public depositToken;` which gets initialized in the `initialize()` function. The nice thing is that it also doesn't need to be updated when swapping sources because a requirement is that the new yield source must have the same deposit token.\n\nAs an optimization, since the `_requireYieldSource()` function already retrieves the `depositToken` address, it can return it so that its value need not be externally retrieved again in the `initialize()` function.\n\nThe `depositToken()` function can be removed if the former suggestion is implemented (ie. `address public override depositToken`).\n\nThen, `yieldSource.depositToken()` can be replaced with `depositToken` where applicable (with appropriate casting).\n\nA part of the former implementation is provided below.\n\n```jsx\naddress public override depositToken;\n\nfunction initialize(...) {\n\taddress depositTokenAddress = _requireYieldSource(_yieldSource);\n\tyieldSource = _yieldSource;\n  depositToken = depositTokenAddress;\n\t...\n\tIERC20Upgradeable(depositTokenAddress).safeApprove(address(_yieldSource), type(uint256).max);\n}\n\nfunction _requireYieldSource(IYieldSource _yieldSource) internal view returns (address depositTokenAddress) {\n\t...\n\t(depositTokenAddress) = abi.decode(depositTokenAddressData, (address));\n}\n\n// function depositToken() can be removed\n// yieldSource.depositToken() can be replaced with depositToken in other functions\n// Example: _setYieldSource\nfunction _setYieldSource(IYieldSource _newYieldSource) internal {\n\t_requireDifferentYieldSource(_newYieldSource);\n\t// Commented out check below should be shifted to inside _requireDifferentYieldSource()\n\t// Optimization: it can also return depositToken to avoid another SLOAD\n\t// similar to _requireYieldSource() above\n\t// require(_newYieldSource.depositToken() == depositToken, \"SwappableYieldSource/different-deposit-token\");\n\n  yieldSource = _newYieldSource;\n  IERC20Upgradeable(depositToken).safeApprove(address(_newYieldSource), type(uint256).max);\n\n  emit SwappableYieldSourceSet(_newYieldSource);\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/26"
    }
  },
  {
    "title": "MStableYieldSource.sol: Optimise balanceOf()",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nSince `mAsset` is immutable and is initialized to a valid token address, a redundant extcodesize check can be avoided, just like how [UniswapV3](https://github.com/Uniswap/uniswap-v3-core/blob/b2c5555d696428c40c4b236069b3528b2317f3c1/contracts/UniswapV3Pool.sol#L138-L145) does it.\n\n### Recommended Mitigation Steps\n\n```jsx\nfunction mAssetBalance() private view returns (uint256) {\n\t(bool success, bytes memory data) =\n\t\tmAsset.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n\t\trequire(success && data.length >= 32);\n\t\treturn abi.decode(data, (uint256));\n}\n\n// Replace lines mAsset.balanceOf(address(this)) with mAssetBalance()\nfunction redeemToken(uint256 mAssetAmount)\n  external\n  override\n  nonReentrant\n  returns (uint256 mAssetsActual)\n{   \n\tuint256 mAssetBalanceBefore = mAssetBalance();\n\n  uint256 creditsBurned = savings.redeemUnderlying(mAssetAmount);\n\n  imBalances[msg.sender] -= creditsBurned;\n  uint256 mAssetBalanceAfter = mAssetBalance();\n  mAssetsActual = mAssetBalanceAfter - mAssetBalanceBefore;\n\n  mAsset.safeTransfer(msg.sender, mAssetsActual);\n\n  emit Redeemed(msg.sender, mAssetAmount, mAssetsActual);\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-07-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-07-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-07-pooltogether-findings/issues/21"
    }
  },
  {
    "title": "Rewards accumaulated can stay constant and oftern not increment",
    "severity": "major",
    "body": "# Handle\n\nmoose-code\n\n\n# Vulnerability details\n\n## Impact\nrewardsPerToken_.accumulated can stay constant while rewardsPerToken_.lastUpdated is continually updated, leading to no actual rewards being distributed. I.e. No rewards accumulate. \n\n## Proof of Concept\nLine 115, rewardsPerToken_.accumulated could stay constant if there are very quick update intervals, a relatively low rewardsPerToken_.rate and a decent supply of the ERC20 token. \n\nI.e. imagine the token supply is 1 billion tokens (quite a common amount, note even if a supply of only say 1 million tokens this is still relevant). i.e. 1e27 wei.\n\nLine 115 has \n1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply\n\ntimeSinceLastUpdated can be crafted to be arbitrarily small by simply transferring or burning tokens, so lets exclude this term (it could be 10 seconds etc). Imagine total supply is 1e27 as mentioned. \n\ntherefore, 1e18 * rewardsPerToken_.rate / 1e27, which shows that if the rewardsPerToken_.rate is < 1e9, something which is very likely, then the accumulated amount won't increment, as there are no decimals in solidity and this line of code will evaluate to adding zero. While this is rounded down to zero, critically,          rewardsPerToken_.lastUpdated = end; is updated. \n\n\nThe reason I have labelled this as a high risk is the express purpose of this contract is to reward users with tokens, yet a user could potentially quite easily exploit this line to ensure no one ever gets rewards and the accumulated amount never increases. \n\nGiven a fairly large token supply, and a relatively low emissions rate is set, that satisfies the above equation, for the entire duration of the rewards period, the user simply sends tokens back and forth every couple seconds (gas limitations, but layer 2), to keep the delta timeSinceLastUpdated close to 1. \n\nThis way the accumulated amount will never tick up, but time keeps being counted.\n\nFurthermore, I would say this is high risk as this wouldn't even need an attacker. Given the transfer function is likely often being called by users, timeSinceLastUpdated will naturally be very low anyways. \n\nEven if not so extreme as the above case, Alberto points out that \"rounding can eat into the rewards\" which is likely to be prevalent in the current scenario and make a big impact over time on the targeted vs actual distribution.  \n\nAgain this problem is more likely to occur in naturally liquid tokens where lots of transfer, mint or burn events occur. \n\n\n\n\n## Tools Used\nManual analysis.\n\n## Recommended Mitigation Steps\nAs suggested by Alberto, the simplest it to probably not update the rewardsPerToken_.lastUpdated field if rewardsPerToken_.accumulated does not change. Although this change should be closely scrutinized to see it doesn't introduce bugs elsewhere. \n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/65"
    }
  },
  {
    "title": "Rewards squatting - setting rewards in different ERC20 tokens opens various economic attacks. ",
    "severity": "medium",
    "body": "# Handle\n\nmoose-code\n\n\n# Vulnerability details\n\n## Impact\nUsers have essentially have an option to either claim currently earned reward amounts on future rewards tokens, or the current rewards token. \n\nAlthough stated on line 84, it does not take into account the implications and lock in this contract will have on the future value of new tokens able to be issued via rewards. \n\n## Proof of Concept\nSmart users will monitor the mempool for setRewards transactions. If the new reward token (token b) is less valuable than the old reward token (token a), they front run this transaction by calling claim. Otherwise they let their accrued 'token a' roll into rewards of of the more valuable 'token b'.\n\nGiven loads of users will likely hold these tokens from day 1, there will potentially be thousands of different addresses squatting on rewards. \n\nEconomically, given the above it makes sense that the value of new reward tokens, i.e. 'token b' should always be less than that of 'token a'. This is undesirable in a rewards token contract as there is no reliable way to start issuing a more valuable token at a later stage, unless exposing yourself to a major risk of reward squatting.\n\ni.e. You could not in future say we want to run a rewards period of of issuing an asset like WETH rewards for 10 days, after first initially issuing DAI as a reward. This hamstrings flexibility of the contract.\n\nP.s. This is one of the slickest contracts I've read. Love how awesome it is.Just believe this should be fixed, then its good to go. \n\n## Tools Used\nManual analysis\n\n## Recommended Mitigation Steps\nIt is true you could probably write a script to manually go call 'claim' on thousands of squatting token addresses but this is a poor solution. \n\nA simple mapping pattern could be used with an index mapping to a reward cycle with a reward token and a new accumulative etc. Users would likely need to be given a period a to claim from old reward cycles before their token balance could no longer reliably used to calculate past rewards. The would still be able to claim everything up until their last action (even though this may be before the rewards cycle ended).\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/64"
    }
  },
  {
    "title": "Methods should be external instead of public",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nAs brought up in a [previous audit issue](https://github.com/code-423n4/2021-05-yield-findings/issues/4), \"the suggestion of changing all public auth functions to external auth will be applied\". The same should therefore be done for the new contracts `Strategy.sol` and `ERC20Rewards.sol`, since all public methods in it aren't called internally.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/61"
    }
  },
  {
    "title": "ERC20Rewards.sol: Unnecessary return argument for _updateRewardsPerToken()",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nThe `uint128` output by `_updateRewardsPerToken()` isn't used by any function. Furthermore, L107 returns a wrong value.\n\n`if (_totalSupply == 0 || block.timestamp.u32() < rewardsPeriod.start) return 0;`\n\nIt should return `rewardsPerToken_.accumulated` instead, because in the case of a new rewards schedule being set, `rewardsPeriod.start` is updated to a new timestamp. Hence, the current accumulated value of all previous reward schedules thus far should be returned.\n\n### Recommended Mitigation Steps\n\nSince the return value isn't used anywhere, remove it.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/60"
    }
  },
  {
    "title": "ERC20Rewards.sol: latest() is unused",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nThe `latest()` function is unused and can be removed.\n\n### Recommended Mitigation Steps\n\nRemove L68-L71\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/58"
    }
  },
  {
    "title": "ERC20Rewards.sol: Have a method to calculate the latest rewardsPerToken accumulated value",
    "severity": "minor",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nThis would be equivalent to [Unipool's `rewardPerToken()` function](https://github.com/k06a/Unipool/blob/master/contracts/Unipool.sol#L69). Note that `rewardsPerToken.accumulated` only reflects the latest stored accumulated value, but does not account for pending accumulation like Unipool, and is therefore not the same. It possibly might be mistaken to be so, hence the low risk classification.\n\n### Recommended Mitigation Steps\n\nA possible implementation is given below.\n\n```jsx\nfunction latestRewardPerToken() external view returns (uint256) {\n\tRewardsPerToken memory rewardsPerToken_ = rewardsPerToken;\n\tif (_totalSupply == 0) return rewardsPerToken_.accumulated;\n\tuint32 end = earliest(block.timestamp.u32(), rewardsPeriod.end);\n\tuint256 timeSinceLastUpdated = end - rewardsPerToken_.lastUpdated;\n\treturn rewardsPerToken_.accumulated + 1e18 * timeSinceLastUpdated * rewardsPerToken_.rate / _totalSupply;\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/57"
    }
  },
  {
    "title": "ERC20Rewards.sol: Consider making rewardsToken immutable",
    "severity": "medium",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nWhile it might seem like a good feature to have, being able to switch reward tokens will only be useful for tokens which are equivalent in value (probably stablecoins, pegged tokens) since it carries over unclaimed rewards from the previous reward program. It would be safer to keep the reward token immutable as a safeguard against violations of this condition.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/56"
    }
  },
  {
    "title": "Multiple solc versions may be allowed",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nTo be consistent with the other files in this project, TimeLock.sol should be changed to 0.8.1 (from ^0.8.0) to prevent this contract from being compiled with a different version than others and derive different optimizations and security properties from the compiler version difference.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L4\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nChange pragma to use 0.8.1 instead of the floating pragma ^0.8.0.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/53"
    }
  },
  {
    "title": "Upgrading solc compiler version may help with bug fixes ",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nsolc version 0.8.3 and 0.8.4 fixed important bugs in the compiler. Using version 0.8.1 misses these fixes and may cause a vulnerability.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L2\n\nhttps://github.com/ethereum/solidity/releases/tag/v0.8.4: Solidity 0.8.4 fixes a bug in the ABI decoder. The release contains an important bugfix. See decoding from memory bug blog post for more details.\n\nhttps://github.com/ethereum/solidity/releases/tag/v0.8.3: Solidity 0.8.3 is a bugfix release that fixes an important bug about how the optimizer handles the Keccak256 opcode.\nFor details on the bug, please see the bug blog post.\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider upgrading to 0.8.3 or 0.8.4\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/50"
    }
  },
  {
    "title": "Missing input validation to check that end > start",
    "severity": "minor",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nsetRewards() is missing input validation on parameters start and end to check if end > start. If accidentally set incorrectly, this will allow resetting new rewards while there is an ongoing one.\n\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L88\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nAdd a require() to check that end > start.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/49"
    }
  },
  {
    "title": "Using parameters or local variables instead of state variables in event emits can save gas",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nEvent emits where there are equivalent local variables or parameters for state variables can save gas by using those instead of state variables because of the expensive SLOADs.\n\n## Proof of Concept\n\nrewardsToken: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L97\n\ndelay: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/TimeLock.sol#L51\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nUse parameters or local variables instead of state variables in event emits\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/44"
    }
  },
  {
    "title": "Caching state variable in local variables for repeated reads saves gas by converting expensive SLOADs into much cheaper MLOADs",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nSLOADs cost 2100 gas for first time reads of state variables and then 100 gas for repeated reads in the context of a transaction (post Berlin fork). MLOADs cost 3 gas units. Therefore, caching state variable in local variables for repeated reads saves gas.\n\n## Proof of Concept\n\nExamples of state variables that are read at the lines shown and also later in that same function:\n\nrewardsPeriod: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L80\n\n_totalSupply: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L107\n\nnextPool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L163\n\nladle: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L172\n\nbase: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L180\n\npool (600 gas savings): https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L183\n\npool: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L208\n\ncached: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L262\n\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nConsider caching state variables in local variables.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/43"
    }
  },
  {
    "title": "Changing function visibility from public to external saves gas",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nPublic functions need to copy their arguments from calldata to memory resulting in more bytecode and gas consumption. If functions are never called from within the contracts, they can be declared external in which case their parameters are always in calldata without being copied to memory. This results in gas savings.\nThere are many such public functions that don’t appear to be called from within the contract.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L74-L75\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L100-L101\n\nAll functions declared in this range:\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L127-L252\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nChange function visibility from public to external \n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/42"
    }
  },
  {
    "title": "Storage slot packing impacts gas efficiency ",
    "body": "# Handle\n\n0xRajeev\n\n\n# Vulnerability details\n\n## Impact\n\nThe declaration order of state variables affects storage slot packing and gas impact from reads/writes of shared slots.\n\nThe 8B rewardsPeriod struct gets packed with the 20B rewardsToken and may result in increased gas usage at runtime due to masked reads/writes. Declaring it instead with uint128 start and end times will force it to occupy a full slot and result in gas savings.\n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L37-L40\n\nhttps://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/utils/token/ERC20Rewards.sol#L53-L54\n\nOther declarations: https://github.com/code-423n4/2021-08-yield/blob/4dc46470e616dd0cbd9db9b4742e36c4d809e02c/contracts/yieldspace/Strategy.sol#L51-L65\n\n## Tools Used\n\nManual Analysis\n\n## Recommended Mitigation Steps\n\nReconsider the declaration order of state variables and the use of variables with size less than word size of 256-bits. Both these affect gas efficiency.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/41"
    }
  },
  {
    "title": "Gas optimization on `_updateRewardsPerToken` of `ERC20Rewards`",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe `_updateRewardsPerToken` function of `ERC20Rewards` is called when a token is transferred, minted, or burned. Thus, it could be called multiple times in a single block. Gas optimization is possible by checking if the `end` variable is equal to `rewardsPerToken_.lastUpdated`. If so, the function can return after line 112 since no reward needs to be updated. The early return could avoid writing to the storage (line 117) and thus save gas.\n\n## Proof of Concept\n\nReferenced code:\n[ERC20Rewards.sol#L112](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L112)\n[ERC20Rewards.sol#L117](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L117)\n\n## Recommended Mitigation Steps\n\nSimply return if `end == rewardsPerToken_.lastUpdated` if the `_updateRewardsPerToken` function.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/39"
    }
  },
  {
    "title": "Use `safeTransfer` instead of `transfer`",
    "severity": "medium",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nTokens not compliant with the ERC20 specification could return `false` from the `transfer` function call to indicate the transfer fails, while the calling contract would not notice the failure if the return value is not checked. Checking the return value is a requirement, as written in the [EIP-20](https://eips.ethereum.org/EIPS/eip-20) specification:\n\n> Callers MUST handle `false` from `returns (bool success)`. Callers MUST NOT assume that `false` is never returned!\n\n## Proof of Concept\n\nReferenced code:\n[ERC20Rewards.sol#L175](https://github.com/code-423n4/2021-08-yield/blob/main/contracts/utils/token/ERC20Rewards.sol#L175)\n\n## Recommended Mitigation Steps\n\nUse the `SafeERC20` library [implementation](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) from OpenZeppelin and call `safeTransfer` or `safeTransferFrom` when transferring ERC20 tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/36"
    }
  },
  {
    "title": "Gas: `ERC20Rewards._updateRewardsPerToken` return value is not needed",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe return value is never used and should be removed to save some gas.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-yield-findings",
      "repo": "https://github.com/code-423n4/2021-08-yield-findings",
      "url": "https://github.com/code-423n4/2021-08-yield-findings/issues/34"
    }
  },
  {
    "title": "Return value of `erc20.approve` is unchecked",
    "severity": "minor",
    "body": "# Handle\n\nshw\n\n\n# Vulnerability details\n\n## Impact\n\nThe `SafeERC20` library is used in the `RCTreasury` contract to handle the transfer of tokens that are not compliant with the ERC20 specification. However, in line 347, the `approve` function is used instead of the `safeApprove` function. Tokens not compliant with the ERC20 specification could return `false` from the `approve` function call to indicate the approval fails, while the calling contract would not notice the failure if the return value is not checked.\n\n## Proof of Concept\n\nReferenced code:\n[RCTreasury.sol#L347](https://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L347)\n\n## Recommended Mitigation Steps\n\nUse the `safeApprove` function instead, which reverts the transaction with a proper error message when the return value of `approve` is `false`. A better approach is to use the `safeIncreaseAllowance` function, which mitigates the multiple withdrawal attack on ERC20 tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-realitycards-findings",
      "repo": "https://github.com/code-423n4/2021-08-realitycards-findings",
      "url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/64"
    }
  },
  {
    "title": "Unable to Recover Improperly Transferred Tokens",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nUsers intending to fund their RealityCard's rental positions will deposit tokens via the `RCTreasury.deposit()` function. Improper deposits in DeFi systems are a common occurrence. Users may accidentally through unintentional means deposit tokens via the `ERC20.transfer()` function, resulting in inaccessible funds both by the depositor and the underlying `RCTreasury` contract. \n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-08-realitycards/blob/main/contracts/RCTreasury.sol#L366-L397\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider adding a `withdraw` function of sorts with relevant naming. This function should enable the `UBER_OWNER` to withdraw any improperly transferred `ERC20` tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-realitycards-findings",
      "repo": "https://github.com/code-423n4/2021-08-realitycards-findings",
      "url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/62"
    }
  },
  {
    "title": "Deposits don't work with fee-on transfer tokens",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n\n## Impact\nThe `RCTreasury.deposit()` function will credit more deposits than the contract actually received:\n\n```\nerc20.safeTransferFrom(msgSender(), address(this), _amount);\nuser[_user].deposit += SafeCast.toUint128(_amount);\n```\n\n## Recommended Mitigation Steps\nEnsure that the `erc20` token does not implement any customizations.\nAlternatively, a mitigation is to measure the asset change right before and after the asset-transferring routines\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-realitycards-findings",
      "repo": "https://github.com/code-423n4/2021-08-realitycards-findings",
      "url": "https://github.com/code-423n4/2021-08-realitycards-findings/issues/58"
    }
  },
  {
    "title": "Lack of Validation Check",
    "body": "# Handle\n\ndefsec\n\n\n# Vulnerability details\n\n## Impact\n\nDuring the manual code review, It has been observed that on the cosmos side Coin amount has not been checked on the token definition. That can use misfunctionality on the bridge.  Although zero amount definition fee will be calculated. That can cause lose of user funds. \n\n## Proof of Concept\n\n1. Navigate to \"https://github.com/althea-net/cosmos-gravity-bridge/blob/main/module/x/gravity/types/ethereum.go\" Line #69.\n2. On the following code, ValidateBasic function does not validate amount.\n\n```\n// ValidateBasic permforms stateless validation\nfunc (e *ERC20Token) ValidateBasic() error {\n\tif err := ValidateEthAddress(e.Contract); err != nil {\n\t\treturn sdkerrors.Wrap(err, \"ethereum address\")\n\t}\n\t// TODO: Validate all the things\n\treturn nil\n}\n```\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\nAdd the following validation steps on the ValidationBasic function.\n\n```\n\tif !m.Amount.IsValid() {\n\t\treturn cosmos.ErrInvalidCoins(\"coins must be valid\")\n\t}\n\n\tif !m.Amount.IsAllPositive() {\n\t\treturn cosmos.ErrInvalidCoins(\"coins must be positive\")\n\t}\n```\n\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-gravitybridge-findings",
      "repo": "https://github.com/code-423n4/2021-08-gravitybridge-findings",
      "url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/55"
    }
  },
  {
    "title": "Anyone can deploy ERC20 tokens",
    "severity": "minor",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Anyone can deploy ERC20 tokens\n\nThe\n[deployERC20](https://github.com/althea-net/cosmos-gravity-bridge/blob/92d0e12cea813305e6472851beeb80bd2eaf858d/solidity/contracts/Gravity.sol#L546)\nis currently a public function that allows anyone to deploy an ERC20\ntoken with given name, symbol and decimals. Although there is no harm in\nanyone deploying a contract, as a good practice, only deploying\ncontracts that actually exist, and are compatible with the\nOpenZeppelin's ERC20 token in cosmos makes sense.\n\nConsider making this operation to require signatures of the validators,\nwhere validators will need to manually check that a cosmos token is\ncompatible with OpenZeppelin's ERC20 token. For example, the cosmos\nversion of the token may have a fee on transfer or deflationary\nmechanisms whereas the Ethereum version of doesn't have it; such a token\nshould not be deployed on the bridge.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-08-gravitybridge-findings",
      "repo": "https://github.com/code-423n4/2021-08-gravitybridge-findings",
      "url": "https://github.com/code-423n4/2021-08-gravitybridge-findings/issues/53"
    }
  },
  {
    "title": "Requiring a decimals method for ERC-20 tokens is non-standard",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Requiring a decimals method for ERC-20 tokens is non-standard\n\nThe [ERC-20](https://eips.ethereum.org/EIPS/eip-20) token standard\nspecifies that\n\n``` text\ndecimals\n\nReturns the number of decimals the token uses - e.g. 8, means to divide the token amount by\n100000000 to get its user representation.\n\nOPTIONAL - This method can be used to improve usability, but interfaces and other contracts MUST NOT\nexpect these values to be present.\n```\n\nHowever, there are several instances where this is required. Some of the\ninstances (non-exhaustive) are given below:\n\n``` text\n./contracts/Auctions/BatchAuction.sol:143:        require(IERC20(_token).decimals() == 18, \"BatchAuction: Token does not have 18 decimals\");\n./contracts/Auctions/BatchAuction.sol:145:            require(IERC20(_paymentCurrency).decimals() > 0, \"BatchAuction: Payment currency is not ERC20\");\n./contracts/Auctions/Crowdsale.sol:169:        require(IERC20(_token).decimals() == 18, \"Crowdsale: Token does not have 18 decimals\");\n./contracts/Auctions/Crowdsale.sol:171:            require(IERC20(_paymentCurrency).decimals() > 0, \"Crowdsale: Payment currency is not ERC20\");\n./contracts/Auctions/DutchAuction.sol:158:        require(IERC20(_token).decimals() == 18, \"DutchAuction: Token does not have 18 decimals\");\n./contracts/Auctions/DutchAuction.sol:160:            require(IERC20(_paymentCurrency).decimals() > 0, \"DutchAuction: Payment currency is not ERC20\");\n./contracts/Auctions/HyperbolicAuction.sol:161:        require(IERC20(_token).decimals() == 18, \"HyperbolicAuction: Token does not have 18 decimals\");\n./contracts/Auctions/HyperbolicAuction.sol:163:            require(IERC20(_paymentCurrency).decimals() > 0, \"HyperbolicAuction: Payment currency is not ERC20\");\n./contracts/Helper/CalculationsSushiswap.sol:20:    function decimals() external view returns (uint8);\n```\n\nIn particular, according to the standard the revert comment \"Payment\ncurrency is not ERC20\" is incorrect. It is recommended to change this\ncomment. It may also be more pedantic to use a second interface\n`ExtendedERC20` which has the function `decimals()` and replace the\nabove uses with that.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-sushimiso-findings",
      "repo": "https://github.com/code-423n4/2021-09-sushimiso-findings",
      "url": "https://github.com/code-423n4/2021-09-sushimiso-findings/issues/136"
    }
  },
  {
    "title": "lack of input validation in Transfer() and TransferFrom()",
    "severity": "minor",
    "body": "# Handle\n\nJMukesh\n\n\n# Vulnerability details\n\n## Impact\nThere is no input validation of address in  transfer() and transferFrom() in tridentErc20.sol due to which it , token  can be send to the address(0)\n\n## Proof of Concept\n\nhttps://github.com/sushiswap/trident/blob/ccd64a53f361ad06087c34bfa3a206afb7230f1c/contracts/pool/TridentERC20.sol#L67\n\nhttps://github.com/sushiswap/trident/blob/ccd64a53f361ad06087c34bfa3a206afb7230f1c/contracts/pool/TridentERC20.sol#L83\n\n## Tools Used\nmanual review\n\n## Recommended Mitigation Steps\nadd input validation for the address in transfer() and transferFrom()\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-sushitrident-findings",
      "repo": "https://github.com/code-423n4/2021-09-sushitrident-findings",
      "url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/153"
    }
  },
  {
    "title": "Lack of checks for address and amount in `TridentERC20._burn`",
    "severity": "minor",
    "body": "# Handle\n\nGalloDaSballo\n\n\n# Vulnerability details\n\n## Impact\n`burn`\nhttps://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L126\n\nIs not checking for `recipient` being different from address(0)\nand `amount` being greater than 0\n\n\n## Recommended Mitigation Steps\nAdd\n`require(recipient != address(0))`\n`require(amount > 0)`\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-sushitrident-findings",
      "repo": "https://github.com/code-423n4/2021-09-sushitrident-findings",
      "url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/135"
    }
  },
  {
    "title": "Lack of checks for address and amount in `TridentERC20._mint`",
    "severity": "minor",
    "body": "# Handle\n\nGalloDaSballo\n\n\n# Vulnerability details\n\n## Impact\n`_mint`\nhttps://github.com/sushiswap/trident/blob/9130b10efaf9c653d74dc7a65bde788ec4b354b5/contracts/pool/TridentERC20.sol#L116\n\nIs not checking for `recipient` being different from address(0)\nand `amount` being greater than 0\n\n\n## Recommended Mitigation Steps\nAdd\n`require(recipient != address(0))`\n`require(amount > 0)`\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-sushitrident-findings",
      "repo": "https://github.com/code-423n4/2021-09-sushitrident-findings",
      "url": "https://github.com/code-423n4/2021-09-sushitrident-findings/issues/131"
    }
  },
  {
    "title": "`tokens[i]` can be memorized",
    "body": "# Handle\n\n0xsanson\n\n\n# Vulnerability details\n\n## Impact\nIn `StablesConverter.convert` there are multiple storage reads of `tokens[i]` that add up gas. Consider saving the variable in memory.\n\n\n## Tools Used\neditor\n\n## Recommended Mitigation Steps\nRewrite \n```js\nIERC20 _token;    // add this\nfor (uint8 i = 0; i < 3; i++) {\n\t_token = tokens[i];  // add this\n    //if (_output == address(tokens[i])) {\n    if (_output == address(_token)) {\n        //uint256 _before = tokens[i].balanceOf(address(this));\n        uint256 _before = _token.balanceOf(address(this));\n        stableSwap3Pool.remove_liquidity_one_coin(\n            _inputAmount,\n            i,\n            _estimatedOutput\n        );\n        //uint256 _after = tokens[i].balanceOf(address(this));\n        uint256 _after = _token.balanceOf(address(this));\n        _outputAmount = _after.sub(_before);\n        //tokens[i].safeTransfer(msg.sender, _outputAmount);\n        _token.safeTransfer(msg.sender, _outputAmount);\n        return _outputAmount;\n    }\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-yaxis-findings",
      "repo": "https://github.com/code-423n4/2021-09-yaxis-findings",
      "url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/143"
    }
  },
  {
    "title": "`Vault.balance()` mixes normalized and standard amounts",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n\n```\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\n\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized.\nThe code is adding a non-normalized amount (for example 6 decimals only for USDC) to a normalized (18 decimals).\n\n## Impact\nThe result is that the `balance()` will be under-reported.\nThis leads to receiving wrong shares when `deposit`ing tokens, and a wrong amount when redeeming `tokens`.\n\n## Recommended Mitigation Steps\nThe second term `IController(manager.controllers(address(this))).balanceOf()` must also be normalized before adding it.\n`IController(manager.controllers(address(this))).balanceOf()` uses `_vaultDetails[msg.sender].balance` which directly uses the raw token amounts which are not normalized.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-yaxis-findings",
      "repo": "https://github.com/code-423n4/2021-09-yaxis-findings",
      "url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/132"
    }
  },
  {
    "title": "`Vault.withdraw` mixes normalized and standard amounts",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `Vault.balance` function uses the `balanceOfThis` function which scales (\"normalizes\") all balances to 18 decimals.\n\n```\nfor (uint8 i; i < _tokens.length; i++) {\n    address _token = _tokens[i];\n    // everything is padded to 18 decimals\n    _balance = _balance.add(_normalizeDecimals(_token, IERC20(_token).balanceOf(address(this))));\n}\n```\n\nNote that `balance()`'s second term `IController(manager.controllers(address(this))).balanceOf()` is not normalized, but it must be.\n\nThis leads to many issues through the contracts that use `balance` but don't treat these values as normalized values.\nFor example, in `Vault.withdraw`, the computed `_amount` value is normalized (in 18 decimals).\nBut the `uint256 _balance = IERC20(_output).balanceOf(address(this));` value is not normalized but compared to the normalized `_amount` and even subtracted:\n\n```solidity\n// @audit compares unnormalzied output to normalized output\nif (_balance < _amount) {\n    IController _controller = IController(manager.controllers(address(this)));\n    // @audit cannot directly subtract unnormalized\n    uint256 _toWithdraw = _amount.sub(_balance);\n    if (_controller.strategies() > 0) {\n        _controller.withdraw(_output, _toWithdraw);\n    }\n    uint256 _after = IERC20(_output).balanceOf(address(this));\n    uint256 _diff = _after.sub(_balance);\n    if (_diff < _toWithdraw) {\n        _amount = _balance.add(_diff);\n    }\n}\n```\n\n## Impact\nImagine in `withdraw`, the `output` is USDC with 6 decimals, then the normalized `_toWithdraw` with 18 decimals (due to using `_amount`) will be a huge number and attempt to withdraw an inflated amount.\nAn attacker can steal tokens this way by withdrawing a tiny amount of shares and receive an inflated USDC or USDT amount (or any `_output` token with less than 18 decimals).\n\n## Recommended Mitigation Steps\nWhenever using anything involving `vault.balanceOfThis()` or `vault.balance()` one needs to be sure that any derived token amount needs to be denormalized again before using them.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-yaxis-findings",
      "repo": "https://github.com/code-423n4/2021-09-yaxis-findings",
      "url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/131"
    }
  },
  {
    "title": "VaultHelper deposits don't work with fee-on transfer tokens",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n\n## Impact\nThe `VaultHelper`'s `depositVault()` and `depositMultipleVault` functions transfer `_amount` to `this` contract using `IERC20(_token).safeTransferFrom(msg.sender, address(this), _amount);`.\nThis could have a fee, and less than `_amount` ends up in the contract.\nThe next actual vault deposit using `IVault(_vault).deposit(_token, _amount);` will then try to transfer more than the `this` contract actually has and will revert the transaction.\n\n## Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines.\nThis is already done correctly in the `Vault.deposit` function.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-yaxis-findings",
      "repo": "https://github.com/code-423n4/2021-09-yaxis-findings",
      "url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/127"
    }
  },
  {
    "title": "ERC20 return values not checked",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `ERC20.transfer()` and `ERC20.transferFrom()` functions return a boolean value indicating success. This parameter needs to be checked for success.\nSome tokens do **not** revert if the transfer failed but return `false` instead.\n\nThe `Manager.recoverToken` function does not check the return value of this function.\n\n## Impact\n\nTokens that don't actually perform the transfer and return `false` are still counted as a correct transfer.\nFurthermore, tokens that do not correctly implement the EIP20 standard, like USDT which does not return a success boolean, will revert.\n\n## Recommended Mitigation Steps\nWe recommend using [OpenZeppelin’s `SafeERC20`](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.1/contracts/token/ERC20/utils/SafeERC20.sol#L74) versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-yaxis-findings",
      "repo": "https://github.com/code-423n4/2021-09-yaxis-findings",
      "url": "https://github.com/code-423n4/2021-09-yaxis-findings/issues/114"
    }
  },
  {
    "title": "StrategyCvxHelper: safeApprove instead of approve",
    "severity": "minor",
    "body": "# Handle\n\nhickuphh3\n\n\n# Vulnerability details\n\n### Impact\n\nThis was probably an oversight since\n\n- the veCVXStrategy contract used `safeApprove()` for token approvals\n- `using SafeERC20Upgradeable for IERC20Upgradeable;` was declared\n\n### Recommended Mitigation Steps\n\nChange\n\n`cvxToken.approve(address(cvxRewardsPool), MAX_UINT_256);`\n\nto\n\n`cvxToken.safeApprove(address(cvxRewardsPool), MAX_UINT_256);`\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-bvecvx-findings",
      "repo": "https://github.com/code-423n4/2021-09-bvecvx-findings",
      "url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/33"
    }
  },
  {
    "title": "Calculation of valueInLocker",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nhere, it basically does convert(a) + convert(b), but imo it would be cheaper to do convert(a+b) but make sure that the precision is not reduced:\n  uint256 valueInLocker =\n    CVXToWant(LOCKER.lockedBalanceOf(address(this))).add(\n        CVXToWant(IERC20Upgradeable(CVX).balanceOf(address(this)))\n    );\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-bvecvx-findings",
      "repo": "https://github.com/code-423n4/2021-09-bvecvx-findings",
      "url": "https://github.com/code-423n4/2021-09-bvecvx-findings/issues/30"
    }
  },
  {
    "title": "Race condition on ERC20 approval",
    "severity": "minor",
    "body": "# Handle\n\ntensors\n\n\n# Vulnerability details\n\nUsing approve() to manage allowances opens yourself and users of the token up to frontrunning.\nBest practice, but doesn't usually matter.\n\nhttps://github.com/code-423n4/2021-09-wildcredit/blob/c48235289a25b2134bb16530185483e8c85507f8/contracts/LPTokenMaster.sol#L87\n\nSee also:\nhttps://github.com/0xProject/0x-monorepo/issues/850\n\nI recommend using increase/decreaseAllowance instead.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-09-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/120"
    }
  },
  {
    "title": "Unused imports",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nThere are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are: import './interfaces/IERC20.sol'; in InterestRateModel import './interfaces/IERC20.sol'; in LPTokenMaster import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/FixedPoint128.sol'; and import 'uniswap/uniswap-v3-core@1.0.0/contracts/libraries/FullMath.sol'; and import './external/PositionKey.sol'; in UniswapV3Helper\n\n## Recommended Mitigation Steps\nConsider removing unused imports mentioned above.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-09-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/107"
    }
  },
  {
    "title": "Cache and check decimals before write storage can save gas",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-09-wildcredit/blob/main/contracts/LendingPair.sol#L93-L96\n\n```solidity=74{93-96}\n  function initialize(\n    address _lpTokenMaster,\n    address _lendingController,\n    address _uniV3Helper,\n    address _feeRecipient,\n    address _tokenA,\n    address _tokenB\n  ) external {\n    require(tokenA == address(0), \"LendingPair: already initialized\");\n    require(_tokenA != address(0) && _tokenB != address(0), \"LendingPair: cannot be ZERO address\");\n\n    lendingController = ILendingController(_lendingController);\n    uniV3Helper       = IUniswapV3Helper(_uniV3Helper);\n    feeRecipient      = _feeRecipient;\n    tokenA = _tokenA;\n    tokenB = _tokenB;\n    lastBlockAccrued[tokenA] = block.number;\n    lastBlockAccrued[tokenB] = block.number;\n\n    decimals[tokenA] = IERC20(tokenA).decimals();\n    decimals[tokenB] = IERC20(tokenB).decimals();\n\n    require(decimals[tokenA] >= 6 && decimals[tokenB] >= 6, \"LendingPair: min 6 decimals\");\n\n    lpToken[tokenA] = _createLpToken(_lpTokenMaster, tokenA);\n    lpToken[tokenB] = _createLpToken(_lpTokenMaster, tokenB);\n  }\n```\n\nCache and check token decimals before write storage can save gas.\n\n### Recommendation\n\nConsider changing to:\n\n```solidity\nuint decimalsTokenA = IERC20(tokenA).decimals();\nuint decimalsTokenB = IERC20(tokenB).decimals();\n\nrequire(decimalsTokenA  >= 6 && decimalsTokenB >= 6, \"LendingPair: min 6 decimals\");\n\ndecimals[tokenA] = decimalsTokenA;\ndecimals[tokenB] = decimalsTokenB;\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-wildcredit-findings",
      "repo": "https://github.com/code-423n4/2021-09-wildcredit-findings",
      "url": "https://github.com/code-423n4/2021-09-wildcredit-findings/issues/73"
    }
  },
  {
    "title": "Deposits don't work with fee-on transfer tokens",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n\n## Impact\nThe `PrizePool._depositTo()` function will try to supply more `_amount` than was actually transferred.\nThe tx will revert and these tokens cannot be used.\n\n## Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-10-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/30"
    }
  },
  {
    "title": "`PrizePool` uses `ERC20` for `ERC721`",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `PrizePool` defines `using SafeERC20 for IERC721;` which means the `SafeERC20.safeTransferFrom` function will be used in `awardExternalERC721`.\nHowever, this function is just a wrapper for `contract.transferFrom` with a return-value and success check.\n\nThus this call actually calls `ERC721.transferFrom` instead of `ERC721.safeTransferFrom` and does not call the important `onERC721Received` check for contracts.\n\n## Impact\nERC721s can be awarded to contracts that don't know how to handle it and they can get stuck.\n\n## Recommended Mitigation Steps\nRemove the `using SafeERC20 for IERC721;` line.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-pooltogether-findings",
      "repo": "https://github.com/code-423n4/2021-10-pooltogether-findings",
      "url": "https://github.com/code-423n4/2021-10-pooltogether-findings/issues/28"
    }
  },
  {
    "title": "Lack of revert messages",
    "body": "# Handle\n\n0xsanson\n\n\n# Vulnerability details\n\n## Impact\nIn almost all the require statements in the code the revert message is missing. This can cause issues for the users who can't determine the cause for their failing transactions.\n\n## Proof of Concept\nUse `grep -n 'require' *.sol` for the full list.\n```\nAuction.sol:48:        require(!initialized);\nAuction.sol:55:        require(auctionOngoing);\nAuction.sol:56:        require(!hasBonded);\nAuction.sol:76:        require(auctionOngoing);\nAuction.sol:77:        require(hasBonded);\nAuction.sol:78:        require(bondTimestamp + ONE_DAY > block.number);\nAuction.sol:79:        require(msg.sender == auctionBonder);\nAuction.sol:98:            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\nAuction.sol:112:        require(auctionOngoing);\nAuction.sol:113:        require(hasBonded);\nAuction.sol:114:        require(bondTimestamp + ONE_DAY <= block.number);\nAuction.sol:144:            require(bounty.active);\nBasket.sol:54:        require(_tokens.length == _weights.length);\nBasket.sol:61:            require(_tokens[i] != address(0));\nBasket.sol:62:            require(_weights[i] > 0);\nBasket.sol:65:                require(_tokens[i] != tokenList[x]);\nBasket.sol:77:        require(auction.auctionOngoing() == false);\nBasket.sol:78:        require(amount > 0);\nBasket.sol:90:        require(auction.auctionOngoing() == false);\nBasket.sol:91:        require(amount > 0);\nBasket.sol:92:        require(balanceOf(msg.sender) >= amount);\nBasket.sol:134:        require(newPublisher != address(0));\nBasket.sol:137:            require(pendingPublisher.publisher == newPublisher);\nBasket.sol:138:            require(block.number >= pendingPublisher.block + TIMELOCK_DURATION);\nBasket.sol:153:        require(newLicenseFee >= factory.minLicenseFee() && newLicenseFee != licenseFee);\nBasket.sol:155:            require(pendingLicenseFee.licenseFee == newLicenseFee);\nBasket.sol:156:            require(block.number >= pendingLicenseFee.block + TIMELOCK_DURATION);\nBasket.sol:174:            require(block.number >= pendingWeights.block + TIMELOCK_DURATION);\nBasket.sol:208:        require(msg.sender == publisher || msg.sender == address(auction));\nBasket.sol:209:        require(auction.auctionOngoing() == false);\nBasket.sol:245:        require(msg.sender == address(auction));\nBasket.sol:250:        require(msg.sender == address(publisher));\nFactory.sol:56:        require(newOwnerSplit <= 2e17); // 20%\nFactory.sol:74:        require(licenseFee >= minLicenseFee);\nFactory.sol:95:        require(bProposal.basket == address(0));\n```\n\n## Tools Used\ngrep\n\n## Recommended Mitigation Steps\nConsider adding a simple message in all require statements.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-09-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/258"
    }
  },
  {
    "title": "Same tokens added to bounty",
    "body": "# Handle\n\ngoatbug\n\n\n# Vulnerability details\n\n## Impact\n\nEven if the same token is added as a bounty, they will be treated as seperate bounties and require 2 transfers of the same token to claim.\n\n    function addBounty(IERC20 token, uint256 amount) public override returns (uint256) {\n        // add bounty to basket\n        token.safeTransferFrom(msg.sender, address(this), amount);\n        _bounties.push(Bounty({\n            token: address(token),\n            amount: amount,\n            active: true\n        }));\n\n        uint256 id = _bounties.length - 1;\n        emit BountyAdded(token, amount, id);\n        return id;\n    }\n\n## Proof of Concept\n\nAnother optimization: Bounties further keep being added to the list and never deleted. Gas could be saved by removing bounties instead of setting their active flag to false. \n\n## Tools Used\n\n## Recommended Mitigation Steps\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-09-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/253"
    }
  },
  {
    "title": "Unecessary transfer trips",
    "body": "# Handle\n\ngoatbug\n\n\n# Vulnerability details\n\n## Impact\n\nIn createBasket (Factory), tokens are first transsferred from the creator, to the factory, before being approved and then transfered to the Basket.\n\nThe function is atomic and the tokens could simply be written to be transferred straight to Basket to save a lot of gas, especially on large numbers of tokens in a basket.\n\n        for (uint256 i = 0; i < bProposal.weights.length; i++) {\n            IERC20 token = IERC20(bProposal.tokens[i]);\n            token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n            token.safeApprove(address(newBasket), bProposal.weights[i]);\n        }\n\n        newBasket.mintTo(BASE, msg.sender);\n\n## Proof of Concept\nProvide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.\n\n## Tools Used\n\n## Recommended Mitigation Steps\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-09-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/245"
    }
  },
  {
    "title": "Fee on transfer tokens can lead to incorrect approval",
    "severity": "medium",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Fee on transfer tokens can lead to incorrect approval\n\nThe\n[createBasket](https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Factory.sol#L106)\nfunction does not account for tokens with fee on transfer.\n\n``` solidity\nfunction createBasket(uint256 idNumber) external override returns (IBasket) {\n    // ...\n    for (uint256 i = 0; i < bProposal.weights.length; i++) {\n        IERC20 token = IERC20(bProposal.tokens[i]);\n        token.safeTransferFrom(msg.sender, address(this), bProposal.weights[i]);\n        token.safeApprove(address(newBasket), bProposal.weights[i]);\n    }\n    // ...\n}\n```\n\nThe function `safeTransferFrom` may not transfer exactly\n`bProposal.weights[i]` amount of tokens, for tokens with a fee on\ntransfer. This means that the `safeApprove` call in the next line would\nbe approving more tokens than what was received, leading to accounting\nissues.\n\n### Recommended Mitigation Steps\n\nIt is recommended to find the balance of the current contract before and\nafter the `transferFrom` to see how much tokens were received, and\napprove only what was received.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-09-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/236"
    }
  },
  {
    "title": "Replace `tokenList.length` by existing variable `length`",
    "body": "# Handle\n\nhrkrshnn\n\n\n# Vulnerability details\n\n## Replace `tokenList.length` by existing variable `length`\n\n``` diff\nmodified   contracts/contracts/Basket.sol\n@@ -61,7 +61,7 @@ contract Basket is IBasket, ERC20Upgradeable {\n             require(_tokens[i] != address(0));\n             require(_weights[i] > 0);\n\n-            for (uint256 x = 0; x < tokenList.length; x++) {\n+            for (uint256 x = 0; x < length; x++) {\n                 require(_tokens[i] != tokenList[x]);\n             }\n```\n\nContext:\n<https://github.com/code-423n4/2021-09-defiProtocol/blob/main/contracts/contracts/Basket.sol#L64>\n\nThe value `tokenList.length` is read from memory and therefore requires\na `mload(...)` (6 gas for `push memory_offset` + `mload`). On the other\nhand, this value is already available in the stack as `length` and could\njust be `dup-ed` (3 gas). Saves 3 gas for each loop iteration of the\ninterior loop.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-09-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-09-defiprotocol-findings/issues/230"
    }
  },
  {
    "title": "Handle of deflationary tokens",
    "severity": "minor",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nConcentratedLiquidityPoolManager may not work with weird ERC20s, e.g. deflationary tokens that could break the calculations if you do not verify how many tokens were actually transferred (the actual amount transferred is balanceOf this token before and after).\n\n## Recommended Mitigation Steps\nConsider supporting deflationary / rebasing / etc tokens by extra checking the balances before/after or strictly inform your users not to use such tokens if they don't want to lose them.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-sushitrident-2-findings",
      "repo": "https://github.com/code-423n4/2021-09-sushitrident-2-findings",
      "url": "https://github.com/code-423n4/2021-09-sushitrident-2-findings/issues/65"
    }
  },
  {
    "title": "`public` functions can be `external`",
    "body": "# Handle\n\npants\n\n\n# Vulnerability details\n\nThese `public` functions are never called by their contract:\n- `TempusAMM.getSwapAmountToEndWithEqualShares()`\n- `TempusAMM.getRate()`\n- `AaveTempusPool.currentInterestRate()`\n- `AaveTempusPool.numAssetsPerYieldToken()`\n- `AaveTempusPool.numYieldTokensPerAsset()`\n- `CompoundTempusPool.currentInterestRate()`\n- `CompoundTempusPool.numAssetsPerYieldToken()`\n- `CompoundTempusPool.numYieldTokensPerAsset()`\n- `LidoTempusPool.currentInterestRate()`\n- `LidoTempusPool.numAssetsPerYieldToken()`\n- `LidoTempusPool.numYieldTokensPerAsset()`\n- `ERC20FixedSupply.decimals()`\n- `ERC20OwnerMintableToken.burn()`\n- `ERC20OwnerMintableToken.burnFrom()`\n- `PoolShare.decimals()`\n- `PermanentlyOwnable.renounceOwnership()`\n- `TempusController.depositYieldBearing()`\n- `TempusController.depositBacking()`\n- `TempusController.redeemToYieldBearing()`\n- `TempusController.redeemToBacking()`\n- `TempusPool.estimatedMintedShares()`\n- `TempusPool.estimatedRedeem()`\n\nTherefore, their visibility can be reduced to `external`.\n\n## Impact\n`external` functions are cheaper than `public` functions.\n\n## Proof of Concept\nhttps://gus-tavo-guim.medium.com/public-vs-external-functions-in-solidity-b46bcf0ba3ac\n\n## Tool Used\nManual code review.\n\n## Recommended Mitigation Steps\nDefine these functions as `external`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tempus-findings",
      "repo": "https://github.com/code-423n4/2021-10-tempus-findings",
      "url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/45"
    }
  },
  {
    "title": "Unused imports",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nThere are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. Examples of such imports are:\n\n In TempusAMMUserDataHelpers\n  import \"@balancer-labs/v2-solidity-utils/contracts/openzeppelin/IERC20.sol\";\n\nIn TempusController\n  import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\nIn TempusAMM\n  import \"@balancer-labs/v2-solidity-utils/contracts/helpers/WordCodec.sol\";\n\n## Recommended Mitigation Steps\nConsider removing them to reduce deployment gas usage.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tempus-findings",
      "repo": "https://github.com/code-423n4/2021-10-tempus-findings",
      "url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/33"
    }
  },
  {
    "title": "Gas: `ERC20OwnerMintableToken.burn` should use caller",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `ERC20OwnerMintableToken.burn` function loads the `manager` storage field for the `_burn(manager, amount)` field.\nOne can save gas by using `_burn(msg.sender, amount)` as it was already verified that `msg.sender == manager`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tempus-findings",
      "repo": "https://github.com/code-423n4/2021-10-tempus-findings",
      "url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/27"
    }
  },
  {
    "title": "Steal tokens from TempusController",
    "severity": "major",
    "body": "# Handle\n\ngpersoon\n\n\n# Vulnerability details\n\n## Impact\nThe function _depositAndProvideLiquidity can be used go retrieve arbitrary ERC20 tokens from the TempusController.sol contract.\n\nAs the test contract of TempusController.sol https://goerli.etherscan.io/address/0xd4330638b87f97ec1605d7ec7d67ea1de5dd7aaa shows, it has indeed ERC20 tokens.\n\nThe problem is due to the fact that you supply an arbitrary tempusAMM to depositAndProvideLiquidity and thus to _depositAndProvideLiquidity. \ntempusAMM could be a fake contract that supplies values that are completely fake.\n\nAt the end of the function _depositAndProvideLiquidity, ERC20 tokens are send to the user. If you can manipulate the variables ammTokens,  mintedShares  and sharesUsed you can send back\nany tokens held in the contract\n\"ammTokens[0].safeTransfer(msg.sender, mintedShares - sharesUsed[0]);\"\n\nThe Proof of Concept shows an approach to do this. \n\n\n## Proof of Concept\nhttps://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L73-L79\n\nhttps://github.com/code-423n4/2021-10-tempus/blob/63f7639aad08f2bba717830ed81e0649f7fc23ee/contracts/TempusController.sol#L304-L335\n\nCreate a fake Vault contract (fakeVault) with the following functions:\nfakeVault.getPoolTokens(poolId) --> returns {TokenToSteal1,TokenToSteal2},{fakeBalance1,fakeBalance2},0\nfakeVault.JoinPoolRequest() --> do nothing\nfakeVault.joinPool() --> do nothing\n\nCreate a fake Pool contract (fakePool) with the following functions:\nfakePool.yieldBearingToken() --> returns fakeYieldBearingToken\nfakePool.deposit() --> returns fakeMintedShares,....\n\nCreate a fake ammTokens contract with the following functions:\ntempusAMM.getVault() --> returns fakeVault\ntempusAMM.getPoolId() --> returns 0\ntempusAMM.tempusPool() --> returns fakePool\n\n\ncall depositAndProvideLiquidity(fakeTempusAMM,1,false) // false -> yieldBearingToken\n_getAMMDetailsAndEnsureInitialized returns fakeVault,0, {token1,token2},{balance1,balance2}\n_deposit(fakePool,1,false) calls _depositYieldBearing which calls fakePool.deposit()  and returns fakeMintedShares\n_provideLiquidity(...)  calculates a vale of ammLiquidityProvisionAmounts\n_provideLiquidity(...)  skips the safeTransferFrom because sender == address(this)) \nthe calls to fakeVault.JoinPoolRequest() and fakeVault.joinPool() can be faked.\n_provideLiquidity(...)  returns the value ammLiquidityProvisionAmounts\n\nNow fakeMintedShares - ammLiquidityProvisionAmounts number of TokenToSteal1 and TokenToSteal2 are transferred to msg.sender\n\nAs you can both manipulate TokenToSteal1 and fakeMintedShares, you can transfer any token to msg.sender\n\n## Tools Used\n\n## Recommended Mitigation Steps\nCreate a whitelist for tempusAMMs\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tempus-findings",
      "repo": "https://github.com/code-423n4/2021-10-tempus-findings",
      "url": "https://github.com/code-423n4/2021-10-tempus-findings/issues/10"
    }
  },
  {
    "title": "Only prepare tx when the fee is present",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nYou can only prepare the second tx in function sendTransfer if the t.fee > 0. This will avoid useless external call when there is no fee or the user himself calls this function.\n\ttxns[1].to = t.token;\n\ttxns[1].data = abi.encodeWithSelector(IERC20.transfer.selector, msg.sender, t.fee);\n\n## Recommended Mitigation Steps\nif (t.fee > 0) {...}\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-ambire-findings",
      "repo": "https://github.com/code-423n4/2021-10-ambire-findings",
      "url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/65"
    }
  },
  {
    "title": "No ERC20 safe* versions called & no return values checked",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nSome tokens (like USDT) don't correctly implement the EIP20 standard and their `transfer`/`transferFrom` function return `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.\n\nNon-safe transfers are used in:\n- `Zapper.recoverFunds`\n- `IdentityFactory.withdraw`\n\nThese occurrences also do **not** check the `success` return boolean of the transfer.\n\n## Impact\nTokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the protocol as they revert the transaction because of the missing return value.\n\n## Recommended Mitigation Steps\n\nWe recommend using OpenZeppelin’s `SafeERC20` versions with the `safeTransfer` and `safeTransferFrom` functions that handle the return value check as well as non-standard-compliant tokens.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-ambire-findings",
      "repo": "https://github.com/code-423n4/2021-10-ambire-findings",
      "url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/35"
    }
  },
  {
    "title": "`Zapper` should safeApprove(0) first",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nSome tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value.\nThey must first be approved by zero and then the actual allowance must be approved.\n\n```solidity\nIERC20(token).safeApprove(address(operator), 0);\nIERC20(token).safeApprove(address(operator), amount);\n```\n\nThe `Zapper.approve/approveMaxMany` function approves the `spender` without resetting it to zero first.\n\n## Impact\nWhen trying to re-approve an already approved token, all transactions revert and the protocol cannot be used.\n\n## Recommended Mitigation Steps\nApprove with a zero amount first before setting the actual amount.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-ambire-findings",
      "repo": "https://github.com/code-423n4/2021-10-ambire-findings",
      "url": "https://github.com/code-423n4/2021-10-ambire-findings/issues/32"
    }
  },
  {
    "title": "balanceOf should be a _view_ function",
    "body": "# Handle\n\n0xsanson\n\n\n# Vulnerability details\n\n## Impact\nIn the ERC20 interface (inside swivel/Abstract.sol), there's this line:\n```js\nfunction balanceOf(address) virtual external returns (uint256);\n```\nThis should be a view function.\n\n## Proof of Concept\nhttps://github.com/Swivel-Finance/gost/blob/v2/test/swivel/Abstracts.sol#L8\n\n## Tools Used\neditor\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-swivel-findings",
      "repo": "https://github.com/code-423n4/2021-09-swivel-findings",
      "url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/157"
    }
  },
  {
    "title": "Unsafe handling of underlying tokens",
    "severity": "major",
    "body": "# Handle\n\n0xsanson\n\n\n# Vulnerability details\n\n## Impact\nNot every ERC20 token follows OpenZeppelin's recommendation. It's possible (inside ERC20 standard) that a `transferFrom` doesn't revert upon failure but returns `false`.\n\nThe code doesn't check these return values. For example `uToken.transferFrom(msg.sender, o.maker, a);` in `initiateVaultFillingZcTokenInitiate` can be exploited by the msg.sender to initiate a trade without sending any underlying.\n\n## Proof of Concept\n`grep 'transfer' Swivel.sol`\n\n## Tools Used\neditor\n\n## Recommended Mitigation Steps\nConsider using [OpenZeppelin's library](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol) with _safe_ versions of transfer functions.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-09-swivel-findings",
      "repo": "https://github.com/code-423n4/2021-09-swivel-findings",
      "url": "https://github.com/code-423n4/2021-09-swivel-findings/issues/155"
    }
  },
  {
    "title": "Unused imports",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nThere are unused imports. They will increase the size of deployment with no real benefit. Consider removing unused imports to save some gas. \n\nExamples of such imports are: \n\nin contract PoolKeeper\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\n\nimported twice:\nimport \"../interfaces/IERC20DecimalsWrapper.sol\";\n\nin contract PoolCommitter\nimport \"../interfaces/IOracleWrapper.sol\";\n\n## Recommended Mitigation Steps\nRemove unnecessary imports.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-10-tracer-findings",
      "url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/33"
    }
  },
  {
    "title": "No ERC20 `safeApprove` versions called",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nSome tokens don't correctly implement the EIP20 standard and their `approve` function returns `void` instead of a success boolean. Calling these functions with the correct EIP20 function signatures will always revert.\n\nCalls to `.approve` with user-defined tokens are made in:\n- `PoolCommitter.setQuoteAndPool`\n\n## Impact\nTokens that don't correctly implement the latest EIP20 spec, like USDT, will be unusable in the mentioned contracts as they revert the transaction because of the missing return value.\n\n## Recommended Mitigation Steps\nWe recommend using OpenZeppelin’s `SafeERC20` versions with the `safeApprove` function that handle the return value check as well as non-standard-compliant tokens.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-10-tracer-findings",
      "url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/20"
    }
  },
  {
    "title": "Deposits don't work with fee-on transfer tokens",
    "severity": "medium",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere are ERC20 tokens that may make certain customizations to their ERC20 contracts.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\nOthers are rebasing tokens that increase in value over time like Aave's aTokens (`balanceOf` changes over time).\n\n\n## Impact\nThe `PoolCommiter.commit()` function will store the entire `amount` in the commitment but with fee-on-transfer tokens, fewer tokens will be transferred which leads to inconsistencies with the `pool.longBalance()` and in `uncommit`.\n\n## Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring routines\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-10-tracer-findings",
      "url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/17"
    }
  },
  {
    "title": "LeveragedPool has require statements which are also checked in library",
    "body": "# Handle\n\nloop\n\n\n# Vulnerability details\n\nWhen making external calls to ERC20 functions LeveragedPool checks for zero addresses. These checks are already available in the OpenZeppelin ERC20 implementation which is used. This results in redundant checks which increase gas costs when calling these functions. \n\n## Proof of Concept\nRequire statements used in LeveragedPool:\n- https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L148\n- https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L163-L164\n- https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L234\n- https://github.com/tracer-protocol/perpetual-pools-contracts/blob/646360b0549962352fe0c3f5b214ff8b5f73ba51/contracts/implementation/LeveragedPool.sol#L251\n\nChecks in OpenZeppelin implementation:\n- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L225-L226\n- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L252\n- https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol#L275\n\n## Tools Used\nRemix\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tracer-findings",
      "repo": "https://github.com/code-423n4/2021-10-tracer-findings",
      "url": "https://github.com/code-423n4/2021-10-tracer-findings/issues/10"
    }
  },
  {
    "title": "Cache basketAsERC20.totalSupply()",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nHere basketAsERC20.totalSupply() does not change inside the loop so it can be called outside the loop to avoid multiple duplicate external calls:\n  uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n\n## Recommended Mitigation Steps\nCache basketAsERC20.totalSupply() in a temporary variable and re-use it.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-10-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/88"
    }
  },
  {
    "title": "Basket: No need for initialized variable",
    "body": "# Handle\n\nkenzo\n\n\n# Vulnerability details\n\n__ERC20_init already checks whether the contract is initialized, so saving your own variable is redundant and unnecessary write to global state.\n\n## Impact\nGas for writing global state.\n\n## Proof of Concept\nBasket's initialize calls __ERC20_init:\nhttps://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Basket.sol#L54\n__ERC20_init has the modifier initializer :\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/ERC20Upgradeable.sol#L54\ninitializer checks whether contract is init:\nhttps://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/proxy/utils/Initializable.sol#L47\n\n## Tools Used\n\n## Recommended Mitigation Steps\nRemove unnecessary initialized var from Basket\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-10-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/63"
    }
  },
  {
    "title": "Auction bonder can steal user funds if bond block is high enough",
    "severity": "medium",
    "body": "# Handle\n\nkenzo\n\n\n# Vulnerability details\n\nAfter an auction has started, as time passes and according to the bondBlock, newRatio (which starts at 2*ibRatio) gets smaller and smaller and therefore less and less tokens need to remain in the basket.\nThis is not capped, and after a while, newRatio can become smaller than current ibRatio.\n\n## Impact\nIf for some reason nobody has bonded and settled an auction and the publisher didn't stop it, a malicious user can wait until newRatio < ibRatio, or even until newRatio ~= 0 (for an initial ibRatio of ~1e18 this happens after less than 3.5 days after auction started), and then bond and settle and steal user funds.\n\n## Proof of Concept\nThese are the vulnerable lines:\nhttps://github.com/code-423n4/2021-10-defiprotocol/blob/main/contracts/contracts/Auction.sol#L95:#L105\n```\n        uint256 a = factory.auctionMultiplier() * basket.ibRatio();\n        uint256 b = (bondBlock - auctionStart) * BASE / factory.auctionDecrement();\n        uint256 newRatio = a - b;\n\n        (address[] memory pendingTokens, uint256[] memory pendingWeights) = basket.getPendingWeights();\n        IERC20 basketAsERC20 = IERC20(address(basket));\n\n        for (uint256 i = 0; i < pendingWeights.length; i++) {\n            uint256 tokensNeeded = basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE;\n            require(IERC20(pendingTokens[i]).balanceOf(address(basket)) >= tokensNeeded);\n        }\n\n```\nThe function verifies that ```pendingTokens[i].balanceOf(basket) >= basketAsERC20.totalSupply() * pendingWeights[i] * newRatio / BASE / BASE```. This is the formula that will be used later to mint/burn/withdraw user funds.\nAs bondBlock increases, newRatio will get smaller, and there is no check on this.\nAfter a while we'll arrive at a point where ```newRatio ~= 0```, so ```tokensNeeded = newRatio*(...) ~= 0```, so the attacker could withdraw nearly all the tokens using outputTokens and outputWeights, and leave just scraps in the basket.\n\n## Tools Used\nManual analysis, hardhat.\n\n## Recommended Mitigation Steps\nYour needed condition/math might be different, and you might also choose to burn the bond while you're at it, but I think at the minimum you should add a sanity check in settleAuction:\n```\nrequire (newRatio > basket.ibRatio());\n```\nMaybe you would require newRatio to be > BASE but not sure.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-defiprotocol-findings",
      "repo": "https://github.com/code-423n4/2021-10-defiprotocol-findings",
      "url": "https://github.com/code-423n4/2021-10-defiprotocol-findings/issues/51"
    }
  },
  {
    "title": "Token Can Deny Execution of `sweepFees()` Function",
    "severity": "minor",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nThe `sweepFees()` function utilises OpenZeppelin's `SafeERC20` library to ensure token transfers are successful. In the event of an unsuccessful token transfer, the transaction will revert with a relevant revert message. However, due to the nature of these reverts, it's possible for one of these tokens to intentionally or unintentionally revert to deny execution of the initial `sweepFees()` call. This may result in considerable gas costs if the function has already iterated a number of times. \n\n## Proof of Concept\n\nhttps://github.com/code-423n4/2021-10-tally/blob/main/contracts/swap/Swap.sol#L243-L259\n\n## Tools Used\n\nManual code review\n\n## Recommended Mitigation Steps\n\nConsider implementing Solidity's `try` and `catch` statement to correctly emit an event if a single token sweep was unsuccessful without denying execution of the entire call to `sweepFees()`. \n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/81"
    }
  },
  {
    "title": "Users can avoid paying fees for ETH swaps",
    "severity": "medium",
    "body": "# Handle\n\npants\n\n\n# Vulnerability details\n\nUsers can call `Swap.swapByQuote()` to execute an ETH swap (where they receive ETH) without paying swap fee for the gained ETH. They can trick the system by setting `zrxBuyTokenAddress` to an address of a malicious contract and making it think they have executed an ERC20 swap when they have actually executed an ETH swap. In this case, the system will give them the ETH they got from the swap (`boughtETHAmount`) without charging any swap fees for it, because the systems consideres this ETH as \"refunded ETH\" that wasn't part of the \"ERC20\" swap.\n\n## Impact\nUsers can execute ETH swap without paying swap fees for the ETH the got from the swap.\n\n## Proof of Concept\nThe steps of the attack are:\n1. Deploy a malicious contract (denoted by `M`), that will be used for `zrxBuyTokenAddress`.\n2. Call `Swap.swapByQuote()` with `zrxBuyTokenAddress=M` and `minimumAmountReceived=0`. The rest of the arguments should specify our ETH swap, nothing special here.\n3. Define `M` to return `0` and `1` at the first and second times when `fillZrxQuote` calls `zrxBuyTokenAddress.balanceOf(address(this))`, respectively.\n4. As a result, `boughtERC20Amount` now equals `1` and the function will \"return any refunded ETH\" to the caller, without charging any swap fees on it. This ETH is actually the output of that ETH swap.\n\n## Tool Used\nManual code review.\n\n## Recommended Mitigation Steps\nCharge swap fees for the \"refunded ETH\" on ERC20 swaps (when `boughtERC20Amount > 0`), or require `boughtETHAmount == 0`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/68"
    }
  },
  {
    "title": "Gas: SafeMath is not needed when using Solidity version 0.8",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `Swap` contract uses Solidity version 0.8 which already implements overflow checks by default.\nAt the same time, it uses the `SafeMath` library which is more gas expensive than the 0.8 overflow checks.\n\nIt should just use the built-in checks and remove `SafeMath` from the dependencies:\n\n```solidity\n// @audit can just normal arithmetic here\nuint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n\n// uint256 toTransfer = (SWAP_FEE_DIVISOR - swapFee) * boughtERC20Amount / SWAP_FEE_DIVISOR;\n\n// same with many other computations\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/42"
    }
  },
  {
    "title": "Gas: minReceived check can be simplified",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThe `minimumAmountReceived` check in `Swap.swapByQuote` is implemented like this:\n\n```solidity\nrequire(\n    (\n        !signifiesETHOrZero(zrxBuyTokenAddress) &&\n        boughtERC20Amount >= minimumAmountReceived\n    ) ||\n    (\n        signifiesETHOrZero(zrxBuyTokenAddress) &&\n        boughtETHAmount >= minimumAmountReceived\n    ),\n    \"Swap::swapByQuote: Minimum swap proceeds requirement not met\"\n);\n```\n\nIt can be simplified to this which performs less calls to `signifiesETHOrZero` and less logical operators:\n\n```solidity\nrequire( (signifiesETHOrZero(zrxBuyTokenAddress) ? boughtETHAmount : boughtERC20Amount) >= minimumAmountReceived, \"...\");\n```\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/41"
    }
  },
  {
    "title": "Contract does not work well with fee-on transfer tokens",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nThere exist ERC20 tokens that made certain customizations to their contract.\nOne type of these tokens is deflationary tokens that charge a certain fee for every `transfer()` or `transferFrom()`.\n\nThe `Swap.swapByQuote` function performs a `safeTransferFrom(msg.sender, this, amountToSell)` and then approves the same `amountToSell` which will be more than what the Swap contract actually received due to fees.\n\n## Impact\nThe `zrxAllowanceTarget` contract is allowed to transfer more than what was transferred to the contract post fees.\nIf the `Swap` contract accumulated swap fees in this token, part of them (`amountToSell - amountToSellPostFees`) can be stolen/are allowed to be transferred from the Swap contract.\n\n## Recommended Mitigation Steps\nOne possible mitigation is to measure the asset change right before and after the asset-transferring `IERC20(zrxSellTokenAddress).safeTransferFrom(msg.sender, address(this), amountToSell)` call, and then only approve the `zrxAllowanceTarget` with the difference.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/40"
    }
  },
  {
    "title": "Arbitrary contract call allows attackers to steal ERC20 from users' wallets",
    "severity": "major",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L212\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n```\n\nA call to an arbitrary contract with custom calldata is made in `fillZrxQuote()`, which means the contract can be an ERC20 token, and the calldata can be `transferFrom` a previously approved user.\n\n### Impact\n\nThe wallet balances (for the amount up to the allowance limit) of the tokens that users approved to the contract can be stolen.\n\n### PoC\n\nGiven:\n\n- Alice has approved 1000 WETH to `Swap.sol`;\n\nThe attacker can:\n\n```\nTallySwap.swapByQuote(\n    address(WETH),\n    0,\n    address(WETH),\n    0,\n    address(0),\n    address(WETH),\n    abi.encodeWithSignature(\n        \"transferFrom(address,address,uint256)\",\n        address(Alice),\n        address(this),\n        1000 ether\n    )\n)\n```\n\nAs a result, 1000 WETH will be stolen from Alice and sent to the attacker.\n\nThis PoC has been tested on a forking network.\n\n### Recommendation\n\nConsider adding a whitelist for `zrxTo` addresses.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/37"
    }
  },
  {
    "title": "Unused ERC20 tokens are not refunded",
    "severity": "medium",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nBased on the context and comments in the code, we assume that it's possible that there will be some leftover sell tokens, not only when users are selling unwrapped ETH but also for ERC20 tokens.\n\nHowever, in the current implementation, only refunded ETH is returned (L158).\n\nBecause of this, the leftover tkoens may be left in the contract unintentionally.\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L153-L181\n\n```solidity=153\nif (boughtERC20Amount > 0) {\n    // take the swap fee from the ERC20 proceeds and return the rest\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtERC20Amount).div(SWAP_FEE_DIVISOR);\n    IERC20(zrxBuyTokenAddress).safeTransfer(msg.sender, toTransfer);\n    // return any refunded ETH\n    payable(msg.sender).transfer(boughtETHAmount);\n\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtERC20Amount,\n        boughtERC20Amount.sub(toTransfer)\n    );\n} else {\n\n    // take the swap fee from the ETH proceeds and return the rest. Note\n    // that if any 0x protocol fee is refunded in ETH, it also suffers\n    // the swap fee tax\n    uint256 toTransfer = SWAP_FEE_DIVISOR.sub(swapFee).mul(boughtETHAmount).div(SWAP_FEE_DIVISOR);\n    payable(msg.sender).transfer(toTransfer);\n    emit SwappedTokens(\n        zrxSellTokenAddress,\n        zrxBuyTokenAddress,\n        amountToSell,\n        boughtETHAmount,\n        boughtETHAmount.sub(toTransfer)\n    );\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/36"
    }
  },
  {
    "title": "Consider removing `Math.sol`",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nMost of the functions in `Math.sol` are unused but one: `subOrZero(uint256 a, uint256 b)`.\n\nEven for `subOrZero()`, it's only been used 2 times, both are unnecessary as they will revert when underflows anyway.\n\nRemoving `Math.sol` will make the code simpler and improve readability.\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L215-L222\n\n```solidity\nif(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n    erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n    require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n}\n```\n\n### Recommendation\n\nChange to:\n\n```solidity\nif(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n    erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)) - originalERC20Balance;\n    require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/35"
    }
  },
  {
    "title": "Wrong calculation of `erc20Delta` and `ethDelta`",
    "severity": "major",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-tally/blob/c585c214edb58486e0564cb53d87e4831959c08b/contracts/swap/Swap.sol#L200-L225\n\n```solidity\nfunction fillZrxQuote(\n    IERC20 zrxBuyTokenAddress,\n    address payable zrxTo,\n    bytes calldata zrxData,\n    uint256 ethAmount\n) internal returns (uint256, uint256) {\n    uint256 originalERC20Balance = 0;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        originalERC20Balance = zrxBuyTokenAddress.balanceOf(address(this));\n    }\n    uint256 originalETHBalance = address(this).balance;\n\n    (bool success,) = zrxTo.call{value: ethAmount}(zrxData);\n    require(success, \"Swap::fillZrxQuote: Failed to fill quote\");\n\n    uint256 ethDelta = address(this).balance.subOrZero(originalETHBalance);\n    uint256 erc20Delta;\n    if(!signifiesETHOrZero(address(zrxBuyTokenAddress))) {\n        erc20Delta = zrxBuyTokenAddress.balanceOf(address(this)).subOrZero(originalERC20Balance);\n        require(erc20Delta > 0, \"Swap::fillZrxQuote: Didn't receive bought token\");\n    } else {\n        require(ethDelta > 0, \"Swap::fillZrxQuote: Didn't receive bought ETH\");\n    }\n\n    return (erc20Delta, ethDelta);\n}\n```\n\nWhen a user tries to swap unwrapped ETH to ERC20, even if there is a certain amount of ETH refunded, at L215, `ethDelta` will always be `0`. \n\nThat's because `originalETHBalance` already includes the `msg.value` sent by the caller.\n\nLet's say the ETH balance of the contract is `1 ETH` before the swap.\n\n- A user swaps `10 ETH` to USDC;\n- `originalETHBalance` will be `11 ETH`;\n- If there is `1 ETH` of refund;\n- `ethDelta` will be `0` as the new balance is `2 ETH` and `subOrZero(2, 11)` is `0`.\n\nSimilarly, `erc20Delta` is also computed wrong.\n\nConsider a special case of a user trying to arbitrage from `WBTC` to `WBTC`, the `originalERC20Balance` already includes the input amount, `erc20Delta` will always be much lower than the actual delta amount.\n\nFor example, for an arb swap from `1 WBTC` to `1.1 WBTC`, the `ethDelta` will be `0.1 WBTC` while it should be `1.1 WBTC`.\n\n### Impact\n\n- User can not get ETH refund for swaps from ETH to ERC20 tokens;\n- Arb swap with the same input and output token will suffer the loss of almost all of their input amount unexpectedly.\n\n### Recommendation\n\nConsider subtracting the input amount from the originalBalance.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-tally-findings",
      "repo": "https://github.com/code-423n4/2021-10-tally-findings",
      "url": "https://github.com/code-423n4/2021-10-tally-findings/issues/34"
    }
  },
  {
    "title": "Use Minimal Interface for gas optimizations",
    "body": "# Handle\n\nhack3r-0m\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L14\n\n`ERC20Upgradeable` is a superset of `ERC20` and in this case, only ERC20 functions are required to be called on ibbtc, so `IERC20` can be used.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/91"
    }
  },
  {
    "title": "WrappedIbbtcEth contract will use stalled price for mint/burn if updatePricePerShare wasn't run properly",
    "severity": "major",
    "body": "# Handle\n\nhyh\n\n\n# Vulnerability details\n\n## Impact\nMalicious user can monitor SetPricePerShare event and, if it was run long enough time ago and market moved, but, since there were no SetPricePerShare fired, the contract's pricePerShare is outdated, so a user can mint() with pricePerShare that is current for contract, but outdated for market, then wait for price update and burn() with updated pricePerShare, yielding risk-free profit at expense of contract holdings.\n\n## Proof of Concept\nWrappedIbbtcEth updates pricePerShare variable by externally run updatePricePerShare function. The variable is then used in mint/burn/transfer functions without any additional checks, even if outdated/stalled. This can happen if the external function wasn't run for any reason.\nThe variable is used via balanceToShares function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L155\n\nThis is feasible as updatePricePerShare to be run by off-chain script being a part of the system, and malfunction of this script leads to contract exposure by stalling the price. The malfunction can happen both by internal reasons (bugs) and by external ones (any system-level dependencies, network outrages).\nupdatePricePerShare function: https://github.com/code-423n4/2021-10-badgerdao/blob/main/contracts/WrappedIbbtcEth.sol#L72\n\n## Recommended Mitigation Steps\nThe risk comes with system design. Wrapping price updates with contract level variable for gas costs minimization is a viable approach, but it needs to be paired with corner cases handling. One of the ways to reduce the risk is as follows:\n\nIntroduce a threshold variable for maximum time elapsed since last pricePerShare update to WrappedIbbtcEth contract.\n\nThen 2 variants of transferFrom and transfer functions can be introduced, both check condition {now - time since last price update < threshold}. If condition holds both variants do the transfer. If it doesn't the first variant reverts, while the second do costly price update.\nI.e. it will be cheap transfer, that works only if price is recent, and full transfer, that is similar to the first when price is recent, but do price update on its own when price is stalled. This way this full transfer is guaranteed to run and is usually cheap, costing more if price is stalled and it does the update.\n\nAfter this whenever scheduled price update malfunctions (for example because of network conditions), the risk will be limited by market volatility during threshold time at maximum, i.e. capped.\n\nExample code:\n\n\t\t// Added threshold\n\n    uint256 public pricePerShare;\n    uint256 public lastPricePerShareUpdate;\n\t\tuint256 public priceUpdateThreshold;\n\t\t\n\t\tevent SetPriceUpdateThreshold(uint256 priceUpdateThreshold);\n\t\t\n    /// ===== Permissioned: Price update threshold =====\n    function setPriceUpdateThreshold(uint256 _priceUpdateThreshold) external onlyGovernance {\n        priceUpdateThreshold = _priceUpdateThreshold;\n        emit SetPriceUpdateThreshold(priceUpdateThreshold);\n    }\n\t\t\n\t\t// The only difference with current transfer code is that Full versions call balanceToSharesFull\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 amountInShares = balanceToShares(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\t\t\n    function transferFromFull(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 amountInShares = balanceToSharesFull(amount);\n\n        _transfer(sender, recipient, amountInShares);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amountInShares, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    function transferFull(address recipient, uint256 amount) public virtual override returns (bool) {\n        uint256 amountInShares = balanceToSharesFull(amount);\n\n        _transfer(_msgSender(), recipient, amountInShares);\n        return true;\n    }\n\t\t\n\t\t// Now balanceToShares first checks if the price is stale\n\t\t// And reverts if it is\n\t\t// While balanceToSharesFull do the same check\n\t\t// But asks for price instead of reverting\n\t\t// Having guaranteed execution with increased costs sometimes\n\t\t// Which is fully deterministic, as user can track SetPricePerShare event\n\t\t// To understand whether it be usual or increased gas cost if the function be called now\n\n    function balanceToShares(uint256 balance) public view returns (uint256) {\n\t\t\t\trequire(block.timestamp < lastPricePerShareUpdate + priceUpdateThreshold, \"Price is stalled\");\n        return balance.mul(1e18).div(pricePerShare);\n    }\n\t\t\n    function balanceToSharesFull(uint256 balance) public view returns (uint256) {\n\t\t\t\tif (block.timestamp >= lastPricePerShareUpdate + priceUpdateThreshold) {\n\t\t\t\t\t\tupdatePricePerShare();\n\t\t\t\t}\n        return balance.mul(1e18).div(pricePerShare);\n    }\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/86"
    }
  },
  {
    "title": "Immutable variable",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\n'immutable' greatly reduces gas costs. There is a variable that does not change so it can be marked as immutable to improve the gas costs:\n  ERC20Upgradeable public ibbtc;\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/81"
    }
  },
  {
    "title": "The design of `wibBTC` is not fully compatible with the current Curve StableSwap pool",
    "severity": "major",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nPer the documentation, `wibBTC` is designed for a Curve StableSwap pool. However, the design of `wibBTC` makes the balances change dynamically and automatically. This is unusual for an ERC20 token, and it's not fully compatible with the current Curve StableSwap pool.\n\nSpecifically, a Curve StableSwap pool will maintain the balances of its `coins` based on the amount of tokens added, removed, and exchanged each time. In another word, it can not adopt the dynamic changes of the balances that happened automatically.\n\nThe pool's actual dynamic balance of `wibBTC` will deviate from the recorded balance in the pool contract as the `pricePerShare` increases.\n\nFurthermore, there is no such way in Curve StableSwap similar to the `sync()` function of UNI v2, which will force sync the stored `reserves` to match the balances.\n\n### PoC\n\nGiven:\n\n- The current `pricePerShare` is: `1`;\n- The Curve pool is newly created with 0 liquidity;\n\n1. Alice added `100 wibBTC` and `100 wBTC` to the Curve pool; Alice holds 100% of the pool;\n2. After 1 month with no activity (no other users, no trading), and the `pricePerShare` of `ibBTC` increases to `1.2`;\n3. Alice removes all the liquidity from the Curve pool.\n\nWhile it's expected to receive `150 wibBTC` and `100 wBTC`, Alice actually can only receive `100 wibBTC` and `100 wBTC`.\n\n### Recommendation\n\nConsider creating a revised version of the Curve StableSwap contract that can handle dynamic balances properly.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/65"
    }
  },
  {
    "title": "The `value` parameter of the `Transfer` event is wrong",
    "severity": "minor",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131\n\n```solidity\nfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n    /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n    uint256 amountInShares = balanceToShares(amount);\n\n    _transfer(_msgSender(), recipient, amountInShares);\n    return true;\n}\n```\n\nhttps://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/deps/@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol#L215-L224\n\n```solidity\nfunction _transfer(address sender, address recipient, uint256 amount) internal virtual {\n    require(sender != address(0), \"ERC20: transfer from the zero address\");\n    require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(sender, recipient, amount);\n\n    _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n    _balances[recipient] = _balances[recipient].add(amount);\n    emit Transfer(sender, recipient, amount);\n}\n```\n\nAs an ERC20 token, the `Transfer` event is an essential feature used very broadly across various interfaces (wallet clients, explorers, and portfolio trackers) and off-chain tracking scenarios.\n\nThe users, tools, and service providers usually assume that when you transfer X amount of ERC20 token, there will be a `Transfer` event with the exact amount X being emitted.\n\nHowever, in the current implementation, the `value` parameter of the `Transfer` event is not the amount passed in, but the amount of the underlying shares.\n\nThis could cause major confusion for the users and could potentially malfunction tools and services.\n\n### PoC\n\nGiven:\n\n- The `pricePerShare` is: `1.5`\n\n1. Alice `mint()` with `100 ibBTC`; A `Transfer` event with `value: 100` will be emitted; The `balanceOf()` will show `150 wibBTC` instead.\n2. Alice `transfer()` `150 wibBTC` to Bob; A `Transfer` event with `value: 100` will be emitted; The `balanceOf()` will show `0 wibBTC`.\n\n### Recommendation\n\nConsider overriding `_burn()`, `_mint()` and `_transfer()` and use the amount of `wibBTC` rather than the amount of `ibBTC` as the `value` parameter of the `Transfer` event.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/62"
    }
  },
  {
    "title": "Inconsistent use of `_msgSender()`",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\n`msg.sender` vs internal call of `_msgSender()`.\n\nhttps://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtc.sol#L23-L36\n\n```solidity\nmodifier onlyPendingGovernance() {\n    require(msg.sender == pendingGovernance, \"onlyPendingGovernance\");\n    _;\n}\n\nmodifier onlyGovernance() {\n    require(msg.sender == governance, \"onlyGovernance\");\n    _;\n}\n\nmodifier onlyOracle() {\n    require(msg.sender == address(oracle), \"onlyOracle\");\n    _;\n}\n```\n\nhttps://github.com/code-423n4/2021-10-badgerdao/blob/9c0ea7b3b02675211446f6c81750c5f3c0a86370/contracts/WrappedIbbtcEth.sol#L123-L131\n\n```solidity\nfunction transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n    /// The _balances mapping represents the underlying ibBTC shares (\"non-rebased balances\")\n    /// Some naming confusion emerges due to maintaining original ERC20 var names\n\n    uint256 amountInShares = balanceToShares(amount);\n\n    _transfer(_msgSender(), recipient, amountInShares);\n    return true;\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-badgerdao-findings",
      "repo": "https://github.com/code-423n4/2021-10-badgerdao-findings",
      "url": "https://github.com/code-423n4/2021-10-badgerdao-findings/issues/54"
    }
  },
  {
    "title": "`LibERC20Token.approveIfBelow` should approve(0) first",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nSome tokens (like [USDT L199](https://etherscan.io/address/0xdac17f958d2ee523a2206206994597c13d831ec7#code)) do not work when changing the allowance from an existing non-zero allowance value.\nThey must first be approved by zero and then the actual allowance must be approved.\n\n```solidity\nIERC20(token).safeApprove(address(operator), 0);\nIERC20(token).safeApprove(address(operator), amount);\n```\n\nThis leads to an issue in `LibERC20Token.approveIfBelow`'s `safeIncreaseAllowance` call which does _not_ `safeApprove(0)` first.\n\n## Impact\nWhen using one of these unsupported tokens, all transactions revert and the protocol cannot be used.\n\n## Recommended Mitigation Steps\nSafeapprove with a zero amount first before setting the actual amount.\nOr just approve the max amount once for each token to circumvent this issue and save gas.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-slingshot-findings",
      "repo": "https://github.com/code-423n4/2021-10-slingshot-findings",
      "url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/81"
    }
  },
  {
    "title": "Adding unchecked directive can save gas",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nFor the arithmetic operations that will never over/underflow, using the unchecked directive (Solidity v0.8 has default overflow/underflow checks) can save some gas from the unnecessary internal over/underflow checks.\n\nFor example:\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/lib/LibERC20Token.sol#L18-L32\n\n```solidity=18\nif (currentAllowance < amount) {\n    // we can optimise gas by using uint256(-1) instead of `amount`\n    // using amount is safer, but then each time we interacting with token\n    // we have to approve it.\n    // For now, let's go with more secure option,\n    // when we add whitelisting for tokens and revoke \"super admin\" option for updating modules\n    // we can go for gas and change it to uint256.max\n    //\n    // however gas usage base on tests looks like this:\n    // - with amount:       min 126003, max 442559, avg 249189\n    // - with uint256(-1):  min 141006, max 499514, avg 277865\n    // so we will spend more at first run (when we need to save all uint256 bits),\n    // but then we will gain in next runs.\n    token.safeIncreaseAllowance(spender, amount - currentAllowance);\n}\n```\n\n`amount - currentAllowance` will never underflow.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-slingshot-findings",
      "repo": "https://github.com/code-423n4/2021-10-slingshot-findings",
      "url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/68"
    }
  },
  {
    "title": "`IUniswapModule.sol` use an immutable variable `router` can save gas and simplify implementation",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\n`UniswapModule.sol` can be changed into a regular (non-abstract) contract. And add an immutable variable `router` and set the value for it in the constructor function.\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/module/IUniswapModule.sol#L34-L34\n\n```solidity=34\naddress router = getRouter();\n```\n\nThen, L34 and `getRouter()` can be removed and save 1 internal call and reduce the code size.\n\n`SushiSwapModule.sol` and `UniswapModule.sol` will no longer be needed as the router can be configurated at deployment.\n\n### Recommendation\n\nChange to:\n\n```solidity\ncontract UniV2Module is ISlingshotModule {\n    using LibERC20Token for IERC20;\n\n    address public immutable router;\n    \n    constructor (address _router) {\n        router = _router;\n    }\n\n    /// @param amount Amount of the token being exchanged\n    /// @param path Array of token addresses to swap\n    /// @param tradeAll If true, it overrides totalAmountIn with current token balance\n    function swap(\n        uint256 amount,\n        address[] memory path,\n        bool tradeAll\n    ) external payable {\n        require(path.length > 0, \"UniswapModule: path length must be >0\");\n\n        if (tradeAll) {\n            amount = IERC20(path[0]).balanceOf(address(this));\n        }\n\n        IERC20(path[0]).approveIfBelow(router, amount);\n\n        // for now, we only supporting .swapExactTokensForTokens()\n        // amountOutMin is 1, because all we care is final check or output in Slingshot contract\n        IUniswapV2Router02(router).swapExactTokensForTokensSupportingFeeOnTransferTokens(\n            amount,\n            1, // amountOutMin\n            path,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-slingshot-findings",
      "repo": "https://github.com/code-423n4/2021-10-slingshot-findings",
      "url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/61"
    }
  },
  {
    "title": "`initialBalance` for native token is wrong",
    "severity": "medium",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L65-L92\n\n```solidity=65{81,88}\nfunction executeTrades(\n    address fromToken,\n    address toToken,\n    uint256 fromAmount,\n    TradeFormat[] calldata trades,\n    uint256 finalAmountMin,\n    address depricated\n) external nonReentrant payable {\n    depricated;\n    require(finalAmountMin > 0, \"Slingshot: finalAmountMin cannot be zero\");\n    require(trades.length > 0, \"Slingshot: trades cannot be empty\");\n    for(uint256 i = 0; i < trades.length; i++) {\n        // Checks to make sure that module exists and is correct\n        require(moduleRegistry.isModule(trades[i].moduleAddress), \"Slingshot: not a module\");\n    }\n\n    uint256 initialBalance = _getTokenBalance(toToken);\n    _transferFromOrWrap(fromToken, _msgSender(), fromAmount);\n\n    executioner.executeTrades(trades);\n\n    uint finalBalance;\n    if (toToken == nativeToken) {\n        finalBalance = _getTokenBalance(address(wrappedNativeToken));\n    } else {\n        finalBalance = _getTokenBalance(toToken);\n    }\n    uint finalOutputAmount = finalBalance - initialBalance;\n    ...\n```\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/Slingshot.sol#L157-L163\n\n```solidity=157\nfunction _getTokenBalance(address token) internal view returns (uint256) {\n    if (token == nativeToken) {\n        return address(executioner).balance;\n    } else {\n        return IERC20(token).balanceOf(address(executioner));\n    }\n}\n```\n\nWhen users swap to native token (ETH), the `initialBalance` should use the balance of `wrappedNativeToken` instead of native token balance, because `finalBalance` is the balance of `wrappedNativeToken`.\n\nIn the current implementation, when the `toToken` is the native token, `initialBalance` will be the ether balance of `executioner` contract. Therefore, when the ether balance of `executioner` is not 0, `finalOutputAmount` will be wrong.\n\nThe attacker can transfer a certain amount of ETH to the `executioner` contract and malfunction the protocol. Causing fund loss to users because `finalOutputAmount` is lower than the actual swapped amount, or DoS due to `finalAmountMin` cant be met.\n\n### PoC\n\nGiven:\n\n- The attacker send 0.25 ETH to the `executioner` contract;\n- The price of ETH in USDC is: 4000\n\n1. Alice swaps 5000 USDC to 1.25 ETH with `finalAmountMin` set to `1 ETH`;\n2. Alice will get 1 ETH out and lose 0.25 ETH;\n3. Bob swaps 1000 USDC to 0.25 ETH with `finalAmountMin` set to `1 wei`;\n4. Bob's transaction fails due to `finalAmountMin` cant being met.\n\n### Recommendation\n\nConsider updating `_getTokenBalance()` and return `IERC20(wrappedNativeToken).balanceOf(address(executioner));` when `token == nativeToken`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-slingshot-findings",
      "repo": "https://github.com/code-423n4/2021-10-slingshot-findings",
      "url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/59"
    }
  },
  {
    "title": "`CurveModule.sol#swap()` Unused parameter",
    "body": "# Handle\n\nWatchPug\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-10-slingshot/blob/9c0432cca2e43731d5a0ae9c151dacf7835b8719/contracts/module/CurveModule.sol#L41-L60\n\n```solidity=41\nfunction swap(\n    address curvePool,\n    address iToken,\n    address jToken,\n    int128 i,\n    int128 j,\n    uint256 dx,\n    bool tradeAll,\n    bool underlyingTokens\n) external payable {\n    if (tradeAll) {\n        dx = IERC20(iToken).balanceOf(address(this));\n    }\n\n    IERC20(iToken).approveIfBelow(curvePool, dx);\n\n    underlyingTokens\n        ? ICurvePool(curvePool).exchange_underlying(i, j, dx, uint256(1))\n        : ICurvePool(curvePool).exchange(i, j, dx, uint256(1));\n}\n```\n\nThe parameter `jToken` is unused.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-10-slingshot-findings",
      "repo": "https://github.com/code-423n4/2021-10-slingshot-findings",
      "url": "https://github.com/code-423n4/2021-10-slingshot-findings/issues/56"
    }
  },
  {
    "title": "`TributeAccrual.availableTribute()` & `TributeAccrual.availableGovernanceTribute()` Distributes Tributes Unfairly",
    "severity": "medium",
    "body": "# Handle\n\nleastwood\n\n\n# Vulnerability details\n\n## Impact\n\nConviction scores are calculating by taking the user's balance and multiplying it by the time elapsed. This score is updated upon each token transfer, or alternatively by directly calling `ERC20ConvictionScore.updateConvictionScore()`. The `availableTribute()` and `availableGovernanceTribute()` functions calculate a user's share by calculating their percentage of the total conviction score to find the amount owed to them.\n\nThis is shown in the following statement where `userCS` is the user's conviction score and `totalCS` is the protocol's total conviction score:\n```\nreturn amount.mul(userCS).div(totalCS);\n```\n\nThe tribute amount that can be successfully claimed disproportionally favours users who have updated their conviction score more recently and who are early to claim their allocated tribute.\n\n## Proof of Concept\n\nConsider the following POC:\n- Two users Alice and Bob both have a conviction score of 5 at time = 1.\n- Time advances such that time = 2.\n- Bob calls `updateConvictionScore()` which sets his conviction score to `5 * time = 10` where time = 2.\n- Therefore, the total conviction score is now 15 and Alice and Bob's individual conviction scores are 5 and 10 respectively.\n- Bob attempts to call `claimTribute()` where the tribute to claim is of size 15 tokens. As a result, Bob receives 10 tokens according to the calculation mentioned above (`(15*10)/15`).\n- Alice updates her conviction score and also attempts to call `claimTribute()`, receiving 7.5 tokens in the process.\n- As a result, a total of 22.5 tokens were transferred out despite the tribute amount being only 15 tokens in total.\n\nAs you can see from the above example, the amount of tokens transferred favours user's who claim early and update their conviction score. It is entirely possible that due to the finite amount of tokens stored in the contract, a number of user's won't be able to successfully claim their allocated tribute.\n\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dependencies/TributeAccrual.sol#L93-L112\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dependencies/TributeAccrual.sol#L117-L136\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dependencies/TributeAccrual.sol#L156\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dependencies/TributeAccrual.sol#L179\nhttps://github.com/code-423n4/2021-11-fairside/blob/main/contracts/dependencies/ERC20ConvictionScore.sol#L476-L479\n\n## Tools Used\n\nManual code review.\n\n## Recommended Mitigation Steps\n\nThere is no easy solution to the mentioned issue. Ideally, all users should have an up to date conviction score whenever `claimTribute()` or `claimGovernanceTribute()` are called, although this would be an incredibly gas intensive mitigation. Alternatively, the protocol's total conviction score can be calculated by tracking the total minted balance of `FSD.sol`'s token and multiplying this by a running total of time elapsed. This will need to be adjusted whenever tokens are minted or burned and updated during tribute claims.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-11-fairside-findings",
      "url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/104"
    }
  },
  {
    "title": "`!= 0` costs less gass compared to ` > 0` for unsigned integer",
    "body": "# Handle\n\n0x0x0x\n\n\n# Vulnerability details\n\n## Finding\n`!= 0` costs less gass compared to ` > 0` for unsigned integer\n\n## Occurences\n\n```\ncontracts/dao/FairSideDAO.sol:306:            proposalCount >= proposalId && proposalId > 0,\ncontracts/dependencies/ERC20ConvictionScore.sol:129:                upper = center > 0 ? center - 1 : 0;\ncontracts/dependencies/ERC20ConvictionScore.sol:176:        if (locked > 0) {\ncontracts/dependencies/ERC20ConvictionScore.sol:280:        if (checkpointCount > 0) {\ncontracts/dependencies/ERC20ConvictionScore.sol:308:        if (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {\ncontracts/dependencies/Withdrawable.sol:58:        require(reserveAmount > 0, \"FSD::withdraw: Insufficient Withdrawal\");\ncontracts/network/FSDNetwork.sol:230:            costShareBenefit % 10 ether == 0 && costShareBenefit > 0,\ncontracts/token/FSD.sol:174:        require(bonded > 0, \"FSD::mintHatch: Insufficient Deposit\");\ncontracts/token/FSDVesting.sol:127:            tokenClaim > 0,\n```\n\n## Recommended Mitigation Steps\n\nChange `> 0` with `!= 0`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-11-fairside-findings",
      "url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/77"
    }
  },
  {
    "title": "Missing SafeMath & SafeCasts",
    "severity": "minor",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nSome calculations don't use `SafeMath` or do unsafe casts:\n\nExamples:\n- `ERC20ConvictionScore._updateConvictionScore`: `bool hasMinimumGovernanceBalance = (int256(balance) + amount) >= governanceMinimumBalance;`\n- `FSDNetwork.openCostShareRequest`: `user.availableCostShareBenefits - user.openCostShareBenefits`\n- `FSD.mint`: `getReserveBalance() - bonded`\n- `FSD.mint`: `int256(bonded)`\n- `FSD.burn`: `-int256(capitalDesired)`\n\n## Impact\nNot using SafeMath could lead to under-/overflows in certain cases.\nIt also makes it hard to reason about the code, as the reverts only happen at a place that is far from the original overflow/unsafe cast.\nUpdating to a newer Solidity version will break a lot of the code.\n\n## Recommendation\nUse SafeMath by default.\nEven if it seems like it's not needed in some places, it could still be that there is some code path that leads to issues that one didn't think of, or gets implemented in the future.\n\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-11-fairside-findings",
      "url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/71"
    }
  },
  {
    "title": "Underflow in `ERC20ConvictionScore._writeCheckpoint`",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nIn `ERC20ConvictionScore._writeCheckpoint`, when the `nCheckpoints` is zero, the `Checkpoint memory checkpoint = checkpoints[user][nCheckpoints - 1]` underflows and reads the `type(uint256).max` index instead.\n\n## Impact\nThis does not currently lead to issues at the moment as when `nCheckpoints == 0`, it always writes to checkpoint zero (skipping the first `if` branch).\n\nBut relying on this underflow is bad practice, and will break the contract when updating the solidity version to `>=0.8`.\n\n## Recommended Mitigation Steps\nMove the variable declaration into the first branch of the `if` which checks that `nCheckpoints > 0`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-11-fairside-findings",
      "url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/70"
    }
  },
  {
    "title": "ERC20ConvictionScore._writeCheckpoint` does not write to storage on same block",
    "severity": "major",
    "body": "# Handle\n\ncmichel\n\n\n# Vulnerability details\n\nIn `ERC20ConvictionScore._writeCheckpoint`, when the checkpoint is overwritten (`checkpoint.fromBlock == blockNumber`), the new value is set to the `memory checkpoint` structure and never written to storage.\n\n```solidity\n// @audit this is MEMORY, setting new convictionScore doesn't write to storage\nCheckpoint memory checkpoint = checkpoints[user][nCheckpoints - 1];\n\nif (nCheckpoints > 0 && checkpoint.fromBlock == blockNumber) {\n    checkpoint.convictionScore = newCS;\n}\n```\n\nUsers that have their conviction score updated several times in the same block will only have their first score persisted.\n\n#### POC\n- User updates their conviction with `updateConvictionScore(user)`\n- **In the same block**, the user now redeems an NFT conviction using `acquireConviction(id)`. This calls `_increaseConvictionScore(user, amount)` which calls `_writeCheckpoint(..., prevConvictionScore + amount)`. The updated checkpoint is **not** written to storage, and the user lost their conviction NFT. (The conviction/governance totals might still be updated though, leading to a discrepancy.)\n\n## Impact\nUsers that have their conviction score updated several times in the same block will only have their first score persisted.\n\nThis also applies to the total conviction scores `TOTAL_CONVICTION_SCORE` and `TOTAL_GOVERNANCE_SCORE` (see `_updateConvictionTotals`) which is a big issue as these are updated a lot of times each block.\n\nIt can also be used for inflating a user's conviction by first calling `updateConvictionScore` and then creating conviction tokens with `tokenizeConviction`. The `_resetConviction` will not actually reset the user's conviction.\n\n## Recommended Mitigation Steps\nDefine the `checkpoint` variable as a `storage` pointer:\n\n```solidity\nCheckpoint storage checkpoint = checkpoints[user][nCheckpoints - 1];\n```\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-fairside-findings",
      "repo": "https://github.com/code-423n4/2021-11-fairside-findings",
      "url": "https://github.com/code-423n4/2021-11-fairside-findings/issues/69"
    }
  },
  {
    "title": "Unused imported contract in xVader",
    "body": "# Handle\n\nhack3r-0m\n\n\n# Vulnerability details\n\nhttps://github.com/code-423n4/2021-11-vader/blob/main/contracts/x-vader/XVader.sol#L5\n\nimports `ERC20Votes.sol` and inherits from it, but the constructor uses `ERC20Permit` ( https://github.com/code-423n4/2021-11-vader/blob/main/contracts/x-vader/XVader.sol#L18 )\n\nso import can be changed to `ERC20Permit`.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-vader-findings",
      "repo": "https://github.com/code-423n4/2021-11-vader-findings",
      "url": "https://github.com/code-423n4/2021-11-vader-findings/issues/269"
    }
  },
  {
    "title": "safe transfer of tokens",
    "body": "# Handle\n\npauliax\n\n\n# Vulnerability details\n\n## Impact\nSome token transfers use SafeERC20 library, some don't, e.g.:\n```solidity\n vader.transferFrom(msg.sender, address(this), _amount); \n vader.safeTransfer(recipient, amount);\n```\nEven though you probably know the implementation of this token and trust it, it would be better to unify transfers across the codebase.\n\n## Recommended Mitigation Steps\nA safe approach is to use this library everywhere where transfers are happening.\n\n",
    "dataSource": {
      "name": "code-423n4/2021-11-vader-findings",
      "repo": "https://github.com/code-423n4/2021-11-vader-findings",
      "url": "https://github.com/code-423n4/2021-11-vader-findings/issues/234"
    }
  }
]